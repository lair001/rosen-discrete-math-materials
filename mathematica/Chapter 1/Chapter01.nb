(* Content-type: application/vnd.wolfram.mathematica *)

(*** Wolfram Notebook File ***)
(* http://www.wolfram.com/nb *)

(* CreatedBy='Mathematica 11.3' *)

(*CacheID: 234*)
(* Internal cache information:
NotebookFileLineBreakTest
NotebookFileLineBreakTest
NotebookDataPosition[       158,          7]
NotebookDataLength[    419004,      11103]
NotebookOptionsPosition[    319758,       9439]
NotebookOutlinePosition[    345069,       9938]
CellTagsIndexPosition[    344157,       9905]
WindowFrame->Normal*)

(* Beginning of Notebook Content *)
Notebook[{

Cell[CellGroupData[{
Cell["The Foundations: Logic and Proofs", "BookChapterTitle",
 CounterAssignments->{{
   "ChapterNumber", 
    1}},ExpressionUUID->"c09afbd1-27d0-443f-b74d-f99f24e3478f"],

Cell[CellGroupData[{

Cell["Introduction", "Section",ExpressionUUID->"6fbcc4d5-94cd-4b66-9603-6adbbbfb15da"],

Cell[TextData[{
 "This chapter describes how ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used to further your understanding of logic and proofs. In \
particular, we describe how to construct truth tables, check the validity of \
logical arguments, and verify logical equivalence. In the final two sections, \
we provide examples of how ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used as part of proofs, specifically to find counterexamples, carry \
out proofs by exhaustion, and search for witnesses for existence proofs."
}], "Text",ExpressionUUID->"2edb58d2-6b53-4e74-9ffd-a137d125d08f"]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.1 Propositional Logic", "Section",
 CellTags->"Section1",ExpressionUUID->"109df940-8540-4a38-8867-0f4b046f6b0b"],

Cell[TextData[{
 "In this section, we will discuss how to use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to explore propositional logic. Specifically, we will see how to use \
logical connectives, describe the connection between logical implication and \
conditional statements in a program, show how to create truth tables for \
compound propositions, and demonstrate how to carry out bit operations."
}], "Text",ExpressionUUID->"babc3d43-172f-4704-aa99-1b639e9c37bf"],

Cell[TextData[{
 "In the Wolfram Language, the truth values true and false are represented by \
the symbols ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 ". Propositions can be represented by symbols (variables) such as ",
 StyleBox["p", "Code"],
 ", ",
 StyleBox["q", "Code"],
 ", or ",
 StyleBox["prop1", "Code"],
 ". Note that if you have not yet made an assignment to a symbol, entering it \
will return the name."
}], "Text",ExpressionUUID->"1da7ac06-4d2f-435a-b190-24db1d45789a"],

Cell[CellGroupData[{

Cell[BoxData["prop1"], "Input",
 CellLabel->"In[1]:=",ExpressionUUID->"f3fc2257-be33-4207-80ea-5a7290173d1f"],

Cell[BoxData["prop1"], "Output",
 CellLabel->"Out[1]=",ExpressionUUID->"ad0c2bb3-9140-402d-9a06-6524bf3b1620"]
}, Open  ]],

Cell[TextData[{
 "Once you have assigned a value, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " will evaluate the symbol to the assigned value whenever it appears."
}], "Text",ExpressionUUID->"7cdbc6a1-585c-4172-b34b-964fe2b72c24"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"prop1", "=", "True"}]], "Input",
 CellLabel->"In[2]:=",ExpressionUUID->"dbd36cee-1ac6-482e-9532-7b3b938a1f13"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[2]=",ExpressionUUID->"8fb698b2-902a-4df8-bf0b-ab4c8af68132"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData["prop1"], "Input",
 CellLabel->"In[3]:=",ExpressionUUID->"aceb354a-7cdf-4932-841c-c7e0eadde96a"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[3]=",ExpressionUUID->"08e76539-1d30-4931-8130-195b55044cf0"]
}, Open  ]],

Cell[TextData[{
 "You can cause ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to \[OpenCurlyDoubleQuote]forget\[CloseCurlyDoubleQuote] the assigned \
value using either the function ",
 StyleBox[ButtonBox["Clear",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Clear"], "FunctionLink"],
 " or the ",
 StyleBox[ButtonBox["Unset",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Unset"], "FunctionLink"],
 " (",
 StyleBox["=.", "Code"],
 ") operator. Both of the expressions below have the effect of removing the \
assigned value from the symbol ",
 StyleBox["prop1", "Code"],
 ". Neither expression returns an output."
}], "Text",ExpressionUUID->"3d5e4e90-2ac0-4cc6-96a2-ea689f922729"],

Cell[BoxData[
 RowBox[{"Clear", "[", "prop1", "]"}]], "Input",
 CellLabel->"In[4]:=",ExpressionUUID->"551926cf-97ae-4695-ae56-e3f731835626"],

Cell[BoxData[
 RowBox[{"prop1", "=."}]], "Input",
 CellLabel->"In[5]:=",ExpressionUUID->"177fbc41-62eb-4275-a34e-b348616d5d6d"],

Cell[CellGroupData[{

Cell["Logical Connectives", "Subsection",
 CellTags->"Section1a",ExpressionUUID->"d5c17553-5774-4cf0-98a2-09a70a625fd1"],

Cell[TextData[{
 "The Wolfram Language supports all of the basic logical operators discussed \
in the textbook. We illustrate negation (",
 StyleBox[ButtonBox["Not",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Not"], "FunctionLink"],
 ", ",
 StyleBox["!", "Code"],
 "), conjunction (",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 ", ",
 StyleBox["&&", "Code"],
 "), disjunction (",
 StyleBox[ButtonBox["Or",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Or"], "FunctionLink"],
 ", ",
 StyleBox["||", "Code"],
 "), exclusive or (",
 StyleBox[ButtonBox["Xor",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Xor"], "FunctionLink"],
 "), implication (",
 StyleBox[ButtonBox["Implies",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Implies"], "FunctionLink"],
 "), and the biconditional (",
 StyleBox[ButtonBox["Equivalent",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Equivalent"], "FunctionLink"],
 "). Note that in the Wolfram Language these are referred to as Boolean \
operators, and expressions formed from them are Boolean expressions. "
}], "Text",ExpressionUUID->"31ed25ab-df9e-479e-9ff8-0f867e723d62"],

Cell[TextData[{
 "For all of the operators, you can enter expressions in standard form, that \
is, by putting the names of the operators at the head of an expression with \
truth values or other expressions as operands",
 ". ",
 "For example, the computations ",
 Cell[BoxData[
  FormBox[
   RowBox[{"T", " ", "\[Or]", " ", "F"}], TraditionalForm]],ExpressionUUID->
  "4178b670-35ba-4b9a-bb00-38c2cd32acb2"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{"T", " ", "\[Implies]", " ", 
    RowBox[{"(", 
     RowBox[{"F", " ", "\[And]", " ", "T"}], ")"}]}], TraditionalForm]],
  ExpressionUUID->"4089ef0b-d651-42a8-9c4f-551149809f37"],
 ", and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"T", "\[CirclePlus]", " ", "T"}], TraditionalForm]],
  ExpressionUUID->"55de82d1-7afc-4e51-b763-2f35f4016eaf"],
 " are shown below."
}], "Text",ExpressionUUID->"68ebd539-b3f7-49c3-94fb-fd2b9e61b595"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Or", "[", 
  RowBox[{"True", ",", "False"}], "]"}]], "Input",
 CellLabel->"In[6]:=",ExpressionUUID->"f97ec2ee-6108-4ec5-b0da-cff78f301cab"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[6]=",ExpressionUUID->"4f2efab2-df08-42ce-93aa-79373fc9b186"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Implies", "[", 
  RowBox[{"True", ",", 
   RowBox[{"And", "[", 
    RowBox[{"False", ",", "True"}], "]"}]}], "]"}]], "Input",
 CellLabel->"In[7]:=",ExpressionUUID->"f7db5dd6-58c1-4c4a-825c-579ce7fa7e97"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[7]=",ExpressionUUID->"6447c302-5c19-49a5-a105-bd2157791d30"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Xor", "[", 
  RowBox[{"True", ",", "True"}], "]"}]], "Input",
 CellLabel->"In[8]:=",ExpressionUUID->"523622dc-0f70-42b7-9917-bec5587cb715"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[8]=",ExpressionUUID->"6c985d50-7111-4fd7-86d7-e54df25afa1b"]
}, Open  ]],

Cell[TextData[{
 "For negation, conjunction, and disjunction, you can use the infix operators \
",
 StyleBox["!", "Code"],
 ", ",
 StyleBox["&&", "Code"],
 ", and ",
 StyleBox["||", "Code"],
 " instead. These are commonly used in place of \[Not], \[And], and \[Or] \
that can be easily typed on a standard keyboard. The computations below show ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Not]", "T"}], TraditionalForm]],ExpressionUUID->
  "d0e67c61-6549-4f82-91ef-85ab9f19e6f6"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"T", "\[Or]", "F"}], ")"}], "\[And]", "T"}], TraditionalForm]],
  ExpressionUUID->"41ece325-a92e-4066-9267-8af95d3689fc"],
 " using the operators ",
 StyleBox["!", "Code"],
 ", ",
 StyleBox["&&", "Code"],
 ", and ",
 StyleBox["||", "Code"],
 "."
}], "Text",ExpressionUUID->"3d13a13d-0876-4b56-9a72-bdd71c71dae2"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"!", "True"}]], "Input",
 CellLabel->"In[9]:=",ExpressionUUID->"7a1f44b2-3e06-493e-9df4-ec6bd22e91c5"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[9]=",ExpressionUUID->"5a2e9c58-a454-4cdd-87cf-ef293a7f20e9"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{"True", "||", "False"}], ")"}], "&&", "True"}]], "Input",
 CellLabel->"In[10]:=",ExpressionUUID->"7c535ce5-d226-4278-a2e2-d426f8eb14a8"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[10]=",ExpressionUUID->"162a1e5b-f343-48d8-b1c7-848127680f31"]
}, Open  ]],

Cell[TextData[{
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " also allows you to enter and compute with expressions using the \
traditional symbols. You enter the symbol by pressing the escape key, \
followed by a sequence identifying the symbol, and then the escape key once \
again. The Wolfram Language refers to this as an alias. For example, entering \
\[EscapeKey]",
 StyleBox["and\[EscapeKey] ", "InlineCode"],
 "produces the traditional symbol for conjunction."
}], "Text",ExpressionUUID->"8891c6df-83d0-4689-886d-ba29bf6f4342"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"True", " ", "\[And]", " ", "False"}]], "Input",
 CellLabel->"In[11]:=",ExpressionUUID->"96fa0e90-4e25-4306-9a7e-c4744f364467"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[11]=",ExpressionUUID->"5230ad4b-830e-426d-b404-1bb1bedac38e"]
}, Open  ]],

Cell[TextData[{
 "An alias is the only way to produce an infix implication operator, via \
\[EscapeKey]",
 StyleBox["\[ThinSpace]=>\[EscapeKey] ", "InlineCode"],
 "(escape, followed by equals, the greater than sign, and terminating with \
escape)."
}], "Text",ExpressionUUID->"db369c88-b90e-4bea-94bd-95e092f8a167"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"False", " ", "\[Implies]", " ", "False"}]], "Input",
 CellLabel->"In[12]:=",ExpressionUUID->"107bd348-bb14-412b-98aa-3e82967ba0ca"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[12]=",ExpressionUUID->"43f2c530-764a-44af-8ee1-6a7630f43728"]
}, Open  ]],

Cell["\<\
In this manual, we will typically not use aliases as part of commands, since \
it is less clear how to imitate such commands. However, for convenience, we \
include a table of the operators defined in the textbook along with their \
names in the Wolfram Language and their infix representations with and \
without aliases. \
\>", "Text",ExpressionUUID->"83408c68-841b-46d2-ac10-cd0348290a85"],

Cell[TextData[Cell[BoxData[GridBox[{
   {"name", "function", 
    RowBox[{"without", " ", "alias"}], "alias", "symbol"},
   {"negation", 
    StyleBox["Not", "Code"], 
    StyleBox["!", "Code"], 
    StyleBox[
     RowBox[{"\[EscapeKey]", 
      StyleBox["not", "InlineCode"], "\[EscapeKey]"}]], "\[Not]"},
   {"conjunction", 
    StyleBox["And", "Code"], 
    StyleBox["&&", "Code"], 
    StyleBox[
     RowBox[{"\[EscapeKey]", 
      StyleBox["and", "InlineCode"], "\[EscapeKey]"}]], "\[And]"},
   {
    RowBox[{"exclusive", " ", "or"}], 
    StyleBox["Xor", "Code"], " ", 
    StyleBox[
     RowBox[{"\[EscapeKey]", 
      StyleBox["xor", "InlineCode"], "\[EscapeKey]"}]], "\[Xor]"},
   {"disjunction", 
    StyleBox["Or", "Code"], 
    StyleBox["||", "Code"], 
    StyleBox[
     RowBox[{"\[EscapeKey]", 
      StyleBox["or", "InlineCode"], "\[EscapeKey]"}]], "\[Or]"},
   {"biconditional", 
    StyleBox["Equivalent", "Code"], " ", 
    StyleBox[
     RowBox[{"\[EscapeKey]", 
      StyleBox["equiv", "InlineCode"], "\[EscapeKey]"}]], "\[Equivalent]"},
   {"implication", 
    StyleBox["Implies", "Code"], " ", 
    StyleBox[
     RowBox[{"\[EscapeKey]", "=", 
      RowBox[{">", "\[EscapeKey]"}]}], "InputForm"], "\[Implies]"}
  },
  GridBoxDividers->{
   "Columns" -> {{True}}, "ColumnsIndexed" -> {}, "Rows" -> {{True}}, 
    "RowsIndexed" -> {}}]],
 FontFamily->
  "Times",ExpressionUUID->"64999d1a-99db-4cd5-b457-cf49fd0767fc"]], "Text",
 TextAlignment->Center,ExpressionUUID->"12d2b6aa-1027-4414-b2e4-5aaf9df34172"],

Cell["\<\
Note that the symbol for exclusive or used by the Wolfram Language differs \
from that in the textbook. In addition, the order in which the operators \
appear in the table above is the order of precedence that the operators have \
in the Wolfram Language. Observe that the order of precedence of the \
biconditional and implication operators is the reverse of the order specified \
in the textbook. It is always a good idea to use parentheses liberally \
whenever precedence is in doubt.\
\>", "Text",ExpressionUUID->"71f489b8-bfb2-4788-be63-160c78310b52"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Conditional Statements", "Subsection",
 CellTags->"Section1b",ExpressionUUID->"e1072977-7b75-482e-ace2-136198601e49"],

Cell[TextData[{
 "We saw above that the Wolfram Language includes the operator ",
 StyleBox[ButtonBox["Implies",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Implies"], "FunctionLink"],
 " for evaluating logical implication. In mathematical logic, \
\[OpenCurlyDoubleQuote]if ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]],ExpressionUUID->
  "5204541d-ecac-4992-9942-4b6b548a89de"],
 ", then ",
 Cell[BoxData[
  FormBox["q", TraditionalForm]],ExpressionUUID->
  "08932698-6765-45a8-99ec-16717d159d1c"],
 "\[CloseCurlyDoubleQuote] has a very specific meaning, as described in \
detail in the text. In computer programming, and the Wolfram Language in \
particular, conditional statements also appear very frequently, but have a \
slightly different meaning."
}], "Text",ExpressionUUID->"23e10dd7-687a-4d9f-9a7a-09bf3b53925c"],

Cell["\<\
From the perspective of formal logic, a conditional statement is, like any \
other proposition, a sentence that is either true or false. In most computer \
programming languages, when we talk about a conditional statement, we are not \
referring to a kind of proposition. Rather, conditional statements are used \
to selectively execute portions of code. Consider the following example of a \
function, which adds 1 to the input value if the input is less than or equal \
to 5 and not otherwise.\
\>", "Text",ExpressionUUID->"64b749df-0b43-448c-ac2e-9c239d039bc1"],

Cell[BoxData[
 RowBox[{
  RowBox[{"ifExample", "[", "x_", "]"}], " ", ":=", " ", 
  RowBox[{"If", "[", 
   RowBox[{
    RowBox[{"x", "\[LessEqual]", "5"}], ",", 
    RowBox[{"x", "+", "1"}], ",", "x"}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[13]:=",ExpressionUUID->"ca788508-ce68-49c7-83da-1d888270e477"],

Cell[TextData[{
 "(To type the inequality into ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", you type \[OpenCurlyDoubleQuote]x<=5\[CloseCurlyDoubleQuote]. The \
graphical front end will automatically turn the key combination \
\[OpenCurlyDoubleQuote]<=\[CloseCurlyDoubleQuote] into \[LessEqual] unless \
you have set options to prevent it from doing so.) We now see that this \
function works as promised."
}], "Text",ExpressionUUID->"afcae5e4-caba-43ae-9684-a68102b5a824"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ifExample", "[", "3", "]"}]], "Input",
 CellLabel->"In[14]:=",ExpressionUUID->"578be923-4f3f-49f2-a6e7-5dcf31caf11c"],

Cell[BoxData["4"], "Output",
 CellLabel->"Out[14]=",ExpressionUUID->"05f54868-10d2-441e-b061-f4a53c1b6ed1"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ifExample", "[", "7", "]"}]], "Input",
 CellLabel->"In[15]:=",ExpressionUUID->"3b81d40f-03bc-45bb-955e-f403f5857a22"],

Cell[BoxData["7"], "Output",
 CellLabel->"Out[15]=",ExpressionUUID->"1a06df00-81c6-4785-babd-d39dec06797a"]
}, Open  ]],

Cell[TextData[{
 "Because this is our first Wolfram Language function, let us spend a moment \
breaking down the general structure before detailing the workings of the \
conditional statement. First, we have the name of the function, ",
 StyleBox["ifExample", "Code"],
 ". Note that symbols for built-in Wolfram Language functions typically begin \
with capital letters, so making a habit of naming functions you define with \
initial letters in lower case helps ensure that you do not accidentally try \
to assign to a built-in function. "
}], "Text",ExpressionUUID->"2375c7f0-c889-4c94-aae3-e4759571c422"],

Cell[TextData[{
 "Following the name of the function, we specify the arguments that will be \
accepted by the function enclosed in brackets. The underscore (",
 StyleBox["_", "Code"],
 "), referred to as ",
 StyleBox[ButtonBox["Blank",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Blank"], "FunctionLink"],
 ", indicates that this is a parameter and that the symbol preceding the \
underscore is the name that will be used to refer to the parameter. "
}], "Text",ExpressionUUID->"ddaed04e-3ebb-4668-ab5b-c184cd10ddae"],

Cell[TextData[{
 "Then comes the operator ",
 StyleBox[":=", "Code"],
 ", the delayed assignment operator. The difference between using ",
 StyleBox[ButtonBox["Set",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Set"], "FunctionLink"],
 " (",
 StyleBox["=", "Code"],
 ") and ",
 StyleBox[ButtonBox["SetDelayed",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SetDelayed"], "FunctionLink"],
 " (",
 StyleBox[":=",
  FontWeight->"Bold"],
 ") is that the delayed assignment ensures that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " does not attempt to evaluate the function definition until the function is \
actually invoked. Generally speaking, ",
 StyleBox[ButtonBox["SetDelayed",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SetDelayed"], "FunctionLink"],
 " (",
 StyleBox[":=",
  FontWeight->"Bold"],
 ") should typically be used when you define a function, whereas ",
 StyleBox[ButtonBox["Set",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Set"], "FunctionLink"],
 " (",
 StyleBox["=", "Code"],
 ") is appropriate for assigning values to variables."
}], "Text",ExpressionUUID->"d2a3b362-9223-475b-99e8-2f00fbf33bd2"],

Cell[TextData[{
 "On the right-hand side of the delayed assignment operator is the expression \
that determine what to do with the argument. In this case, the body of the \
function makes use of the ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " function to choose between two possible results. Note that we provided \
three arguments, separated by commas, to ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 ". The first argument, ",
 StyleBox["x<=5", "Code"],
 ", specifies the condition. ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " evaluates this expression to determine which of the branches, that is, \
which of the other two arguments, to execute. If the condition is true, then ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " evaluates the second argument, ",
 StyleBox["x+1", "Code"],
 ", and this is the value of the function. This is traditionally called the \
\[OpenCurlyDoubleQuote]then\[CloseCurlyDoubleQuote] clause. If the condition \
specified in the first argument is false, then the third argument, called the \
\[OpenCurlyDoubleQuote]else\[CloseCurlyDoubleQuote] clause, is evaluated."
}], "Text",ExpressionUUID->"7309181e-4b12-4d85-bb7e-9f6d4382730b"],

Cell[TextData[{
 "It is important to be aware of two additional variations on the ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " function. First, you are allowed to omit the \[OpenCurlyDoubleQuote]else\
\[CloseCurlyDoubleQuote] and provide only two arguments. As you can see in \
the example below, when the condition is false, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " appears to return nothing. In fact, the expression returns the special \
symbol ",
 StyleBox[ButtonBox["Null",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Null"], "FunctionLink"],
 ", which does not produce output."
}], "Text",ExpressionUUID->"4a11ad0d-5400-4b28-815c-e8f8e8982cd6"],

Cell[BoxData[
 RowBox[{"If", "[", 
  RowBox[{
   RowBox[{"3", "<", "1"}], ",", "5"}], "]"}]], "Input",
 CellLabel->"In[16]:=",ExpressionUUID->"e1a45144-3f09-4c19-9641-f424ce8e8b5a"],

Cell[TextData[{
 "The second variation on ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " has four arguments. The Wolfram Language is very strict with regards to \
conditional statements. Specifically, it only evaluates the second argument \
if the result of evaluating the condition is the symbol ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 ". Moreover, it only evaluates the third argument when the result of the \
condition is ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 ". However, many expressions do not evaluate to either of these symbols. In \
these cases, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " returns the ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " function unevaluated. For example, in the expression below, the symbol ",
 StyleBox["z", "Code"],
 " has not been assigned a value and thus ",
 StyleBox["z > 5", "Code"],
 " cannot be resolved to a truth value."
}], "Text",ExpressionUUID->"cdec9525-9b49-4bd9-8827-eb41f91f5cfb"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"If", "[", 
  RowBox[{
   RowBox[{"z", ">", "5"}], ",", "4", ",", "11"}], "]"}]], "Input",
 CellLabel->"In[17]:=",ExpressionUUID->"5bcf1726-6b6e-49ca-a17e-bbf95af762a4"],

Cell[BoxData[
 RowBox[{"If", "[", 
  RowBox[{
   RowBox[{"z", ">", "5"}], ",", "4", ",", "11"}], "]"}]], "Output",
 CellLabel->"Out[17]=",ExpressionUUID->"eb2e5f5d-aac1-4190-a2a9-673e802e08e6"]
}, Open  ]],

Cell["\<\
By specifying a fourth argument, you can give explicit instructions on how to \
handle this situation.\
\>", "Text",ExpressionUUID->"5362ab6d-740c-4b54-bd90-0f84d27c039a"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"If", "[", 
  RowBox[{
   RowBox[{"z", ">", "5"}], ",", "4", ",", "11", ",", "0"}], "]"}]], "Input",
 CellLabel->"In[18]:=",ExpressionUUID->"ab5bcb79-814d-4937-a619-5ca4f19af0c7"],

Cell[BoxData["0"], "Output",
 CellLabel->"Out[18]=",ExpressionUUID->"12dab3bf-7e99-4c95-8980-21a42b8a536a"]
}, Open  ]],

Cell[TextData[{
 "This fourth argument is useful if there is some question of whether or not ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " will be able to resolve the condition into a truth value. We will \
typically not use the fourth argument, however, since in nearly all cases, a \
failure to properly evaluate the condition indicates an error in either our \
function definition or the input to it and providing the fourth argument will \
only hide such errors from us."
}], "Text",ExpressionUUID->"c6f7b4b5-ceaa-4610-8eca-8438f49c3a15"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Evaluating Expressions", "Subsection",
 CellTags->"Section1c",ExpressionUUID->"29c005f5-10b1-48f1-8b03-6e03264b0412"],

Cell[TextData[{
 "In the textbook, you saw how to construct truth tables by hand. Here, we \
will see how to have ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " create them for us. We begin by considering the simplest case of a \
compound proposition: the negation of a single propositional variable."
}], "Text",ExpressionUUID->"4b115896-0cc5-4ee6-ba2d-b6172181b38c"],

Cell[BoxData[
 RowBox[{"prop2", " ", ":=", " ", 
  RowBox[{"!", "p"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[19]:=",ExpressionUUID->"0ee772e1-70da-4aad-b2a7-35fc763796cb"],

Cell[TextData[{
 "Note that we have defined the proposition ",
 StyleBox["prop2", "Code"],
 " as an expression in terms of the symbol ",
 StyleBox["p", "Code"],
 ", which has not been assigned. We can determine the truth value of ",
 StyleBox["prop2", "Code"],
 " in one of two ways. The obvious way is to assign a truth value to ",
 StyleBox["p", "Code"],
 " and then ask ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " for the value of ",
 StyleBox["prop2", "Code"],
 " as follows."
}], "Text",ExpressionUUID->"86a65796-bf53-4a1f-9334-0c4548efa2f9"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"p", " ", "=", " ", "False"}]], "Input",
 CellLabel->"In[20]:=",ExpressionUUID->"7bc8e863-3705-49e7-bdba-ea3ea38a8796"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[20]=",ExpressionUUID->"6a215bd6-7de7-49c8-8e2f-0551af22e00a"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData["prop2"], "Input",
 CellLabel->"In[21]:=",ExpressionUUID->"545f2af9-2e63-4b48-8f55-986759a27dd0"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[21]=",ExpressionUUID->"6e3aba34-3b17-4ea1-8033-c92a570a9b3d"]
}, Open  ]],

Cell[TextData[{
 "The drawback of this approach, however, is that our variable ",
 StyleBox["p", "Code"],
 " is now identified with false and if we want to use it as a name again, we \
need to manually ",
 StyleBox[ButtonBox["Unset",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Unset"], "FunctionLink"],
 " (",
 StyleBox["=.", "Code"],
 ") it."
}], "Text",ExpressionUUID->"ba0c24fc-32e9-4562-bbca-b169f2cc5ea0"],

Cell[BoxData[
 RowBox[{"p", "=."}]], "Input",
 CellLabel->"In[22]:=",ExpressionUUID->"3980938c-7d85-483d-bd04-8ff56a12e780"],

Cell[TextData[{
 "The better approach is to use the ",
 StyleBox[ButtonBox["ReplaceAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ReplaceAll"], "FunctionLink"],
 " operator (",
 StyleBox["/.", "Code"],
 "). This function has a variety of uses, one of which is to allow you to \
evaluate an expression for particular values of variables without the need to \
assign (and then ",
 StyleBox[ButtonBox["Clear",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Clear"], "FunctionLink"],
 ") values to the variables. We first demonstrate its use, and then we will \
explain the syntax."
}], "Text",ExpressionUUID->"782e7775-8321-4a6c-a994-77c559c21e72"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"prop2", "/.", 
  RowBox[{"p", "\[Rule]", "True"}]}]], "Input",
 CellLabel->"In[23]:=",ExpressionUUID->"f83a0b0c-a81a-4f04-83b6-7cb7e1283d5f"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[23]=",ExpressionUUID->"c11f7658-289a-4023-bdb0-aaa07ef2705c"]
}, Open  ]],

Cell[TextData[{
 "On the left-hand side of the ",
 StyleBox["/.", "Code"],
 " operator is the expression to be evaluated. In this case, we have the \
symbol ",
 StyleBox["prop2", "Code"],
 " on the left, which was assigned to be ",
 StyleBox["!p", "Code"],
 ". On the right-hand side of the operator, we indicate the substitution to \
be made using the notation ",
 StyleBox["a\[Rule]b", "Code"],
 ", called a ",
 StyleBox[ButtonBox["Rule",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Rule"], "FunctionLink"],
 ", to indicate that ",
 StyleBox["a", "Code"],
 " is replaced by ",
 StyleBox["b", "Code"],
 ". Note that you obtain the arrow by typing a hyphen followed by the greater \
than symbol (",
 StyleBox["->", "Code"],
 "). The ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " front end will automatically turn that into the arrow character."
}], "Text",ExpressionUUID->"712a2e62-ed93-4576-9be6-8c9bc26f7e5c"],

Cell[TextData[{
 "In order to substitute for more than one variable, list the substitutions \
as rules separated by commas and enclosed in braces",
 ". ",
 "The following evaluates the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[And]", 
    RowBox[{"(", 
     RowBox[{"\[Not]", "q"}], ")"}]}], TraditionalForm]],ExpressionUUID->
  "7562a1c0-b07d-4d36-8c96-700bfa7ba5e5"],
 " for ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]],ExpressionUUID->
  "41bb1662-ec9d-4e4f-8c27-411f6e41586a"],
 " true and ",
 Cell[BoxData[
  FormBox["q", TraditionalForm]],ExpressionUUID->
  "3bc72be7-3b2e-42a0-bca8-be8b1919f517"],
 " false."
}], "Text",ExpressionUUID->"3296a06d-c30e-4931-9172-8bcbaef189f9"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"p", "&&", 
   RowBox[{"(", 
    RowBox[{"!", "q"}], ")"}]}], "/.", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"p", "\[Rule]", "True"}], ",", 
    RowBox[{"q", "\[Rule]", "False"}]}], "}"}]}]], "Input",
 CellLabel->"In[24]:=",ExpressionUUID->"98489b31-82ce-4812-a67e-01eb42b55fc0"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[24]=",ExpressionUUID->"77ab5b9d-71a1-4c90-8694-225c93fb1941"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Truth Tables and Loops", "Subsection",
 CellTags->"Section1d",ExpressionUUID->"0f8838d4-0c4d-46b1-9825-2167fddcf4e2"],

Cell[TextData[{
 "The Wolfram Language has a built-in function for producing a truth table, \
",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 ", which will be described in Section 1.2. While the built-in function is \
useful, it is worthwhile to consider how such tables can be created using \
more primitive programming tools. In this section, we will see how to create \
truth tables using only basic loop constructs."
}], "Text",ExpressionUUID->"f6b2d3c5-2290-4911-aa2e-a6411f4af5b6"],

Cell[TextData[{
 "To make a truth table for a proposition, we need to evaluate the \
proposition at all possible truth values of all of the different variables. \
To do this, we make use of loops (refer to the Introduction for a general \
discussion of loops in the Wolfram Language). Specifically, we want to loop \
over the two possible truth values, true and false, so we will construct a \
loop over the list ",
 StyleBox["{True, False}", "Code"],
 "."
}], "Text",ExpressionUUID->"b804e20b-b88a-4482-9c36-c012e39e4ec2"],

Cell[TextData[{
 "In the Wolfram Language, the ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " function is used to create a loop that executes commands for each member \
of a list. The ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " function requires two arguments. The first argument is the expression that \
you want evaluated, typically involving one or more variables that change \
during the execution of the loop. The second argument specifies the iterative \
behavior and can take several forms. The form we will be using here is ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"i", ",", 
     RowBox[{"{", 
      RowBox[{
       SubscriptBox["i", "1"], ",", 
       SubscriptBox["i", "2"], ",", "\[Ellipsis]"}], "}"}]}], "}"}], 
   TraditionalForm]],ExpressionUUID->"77d41875-c3ed-4313-a2c0-752555d54845"],
 ". The character ",
 Cell[BoxData[
  FormBox["i", TraditionalForm]],ExpressionUUID->
  "e0965b66-d171-4b99-a02c-4eb498a06868"],
 " represents the loop variable and the list ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{
     SubscriptBox["i", "1"], ",", 
     SubscriptBox["i", "2"], ",", "\[Ellipsis]"}], "}"}], TraditionalForm]],
  ExpressionUUID->"e7b7dc39-4ade-44a9-b000-9aa5ea1eda6b"],
 " represents an explicit list of particular values that will be assigned to \
the loop variable."
}], "Text",ExpressionUUID->"042bca9d-d444-4e27-81f4-457d32109458"],

Cell[TextData[{
 "The first example will be to produce a truth table for the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Not]", "p"}], TraditionalForm]],ExpressionUUID->
  "93fac305-4375-41fd-9bc5-2f183e1dc67e"],
 ". Each iteration in the loop, therefore, should print out one line of the \
truth table. Since a ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " loop does not produce any output unless explicitly told to do so (it \
normally returns ",
 StyleBox[ButtonBox["Null",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Null"], "FunctionLink"],
 "), we will use the ",
 StyleBox[ButtonBox["Print",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Print"], "FunctionLink"],
 " function to tell the loop what should be displayed. The ",
 StyleBox[ButtonBox["Print",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Print"], "FunctionLink"],
 " function takes any number of arguments and displays them concatenated \
together. In this example, we want to display the value of the propositional \
variable ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]],ExpressionUUID->
  "dcef5309-54f3-434b-980f-45bc321c98dd"],
 " and the truth value of the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Not]", "p"}], TraditionalForm]],ExpressionUUID->
  "a79eff13-faf0-4f66-8348-a9244e22507d"],
 ". We will explicitly insert some space between the two truth values by \
putting ",
 StyleBox["\" \"", "Code"],
 " as an argument as well. Therefore, the first argument to ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " will be ",
 StyleBox["Print[p,\" \",!p]", "Code"],
 "."
}], "Text",ExpressionUUID->"af886618-38f2-4b9a-8d33-4cf1d0fd76e6"],

Cell[TextData[{
 "For the second argument, the specification of the iteration, we must \
provide the name of the loop variable, in this case ",
 StyleBox["p", "Code"],
 ", and the list of values that we want assigned to that variable in each \
iteration, namely true and false. Therefore, the second argument will be ",
 StyleBox["{p,{True,False}}", "Code"],
 "."
}], "Text",ExpressionUUID->"cfac9852-e6bf-4126-991c-cb2f6991c60f"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"Print", "[", 
    RowBox[{"p", ",", "\"\< \>\"", ",", 
     RowBox[{"!", "p"}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", 
     RowBox[{"{", 
      RowBox[{"True", ",", "False"}], "}"}]}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[25]:=",ExpressionUUID->"ae3268e0-1b19-420c-95c7-1e339bd848f1"],

Cell[CellGroupData[{

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "True", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "False"}],
  SequenceForm[True, " ", False],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[25]:=",ExpressionUUID->"088efda8-6ae3-4a19-9a9f-024c2ee92a6c"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "False", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[False, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[25]:=",ExpressionUUID->"48c2520b-e785-44d5-aee3-330239d70cfa"]
}, Open  ]]
}, Open  ]],

Cell[TextData[{
 "As a second example, we will construct the truth table for ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "\[And]", "q"}], ")"}], "\[Implies]", "p"}], 
   TraditionalForm]],ExpressionUUID->"7aae3361-b1c9-4cbf-b351-ed29450ab508"],
 ". Notice that there are two variables instead of one. This indicates that \
two loops should be used, one for each variable. In most programming \
languages, the technique of \[OpenCurlyDoubleQuote]nesting\
\[CloseCurlyDoubleQuote] loops is the approach that you would need to take. \
In effect, you use a ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " function as the first argument to another ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " function. This approach is illustrated below."
}], "Text",ExpressionUUID->"4ebf6fbf-9cfb-4055-8c59-602579045d8f"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Do", "[", "\[IndentingNewLine]", 
  RowBox[{
   RowBox[{"Do", "[", 
    RowBox[{
     RowBox[{"Print", "[", 
      RowBox[{"p", ",", "\"\< \>\"", ",", "q", ",", "\"\< \>\"", ",", 
       RowBox[{"Implies", "[", 
        RowBox[{
         RowBox[{"p", "&&", "q"}], ",", "p"}], "]"}]}], "]"}], ",", 
     RowBox[{"{", 
      RowBox[{"q", ",", 
       RowBox[{"{", 
        RowBox[{"True", ",", "False"}], "}"}]}], "}"}]}], "]"}], ",", 
   "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"p", ",", 
     RowBox[{"{", 
      RowBox[{"True", ",", "False"}], "}"}]}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[26]:=",ExpressionUUID->"2ba65e53-b530-4b34-a9f8-ec158bf41d2f"],

Cell[CellGroupData[{

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "True", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[True, " ", True, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[26]:=",ExpressionUUID->"f98b7884-3375-4d0d-aa85-2bc19d06c111"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "True", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "False", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[True, " ", False, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[26]:=",ExpressionUUID->"170bf41e-364d-487a-835e-1c26c0329c9e"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "False", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[False, " ", True, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[26]:=",ExpressionUUID->"8baf9255-31d8-4ac5-bd8f-e99a7cd05f67"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "False", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "False", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[False, " ", False, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[26]:=",ExpressionUUID->"3cbdc326-dcd1-4abf-a4b3-8f72895e8802"]
}, Open  ]]
}, Open  ]],

Cell[TextData[{
 "However, there is another way. The ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " syntax allows you to provide more than one iteration specification. For \
this example, we want both variables ",
 StyleBox["p", "Code"],
 " and ",
 StyleBox["q", "Code"],
 " to take on both truth values, so we provide the iteration specifications \
for both of them. ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " ensures that it executes the expression in the first argument with every \
possible pair of values for ",
 StyleBox["p", "Code"],
 " and ",
 StyleBox["q", "Code"],
 "."
}], "Text",ExpressionUUID->"7f8c6579-378f-4d96-9691-df4ee08ed6ee"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Do", "[", 
  RowBox[{
   RowBox[{"Print", "[", 
    RowBox[{"p", ",", "\"\< \>\"", ",", "q", ",", "\"\< \>\"", ",", 
     RowBox[{"Implies", "[", 
      RowBox[{
       RowBox[{"p", "&&", "q"}], ",", "p"}], "]"}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", 
     RowBox[{"{", 
      RowBox[{"True", ",", "False"}], "}"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"q", ",", 
     RowBox[{"{", 
      RowBox[{"True", ",", "False"}], "}"}]}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[27]:=",ExpressionUUID->"90e6a2fa-9f72-410b-8e5b-e8bd09f2d6e5"],

Cell[CellGroupData[{

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "True", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[True, " ", True, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[27]:=",ExpressionUUID->"5f750161-60ed-4a92-b3cd-cfb54073d783"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "True", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "False", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[True, " ", False, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[27]:=",ExpressionUUID->"c69a8623-97c8-4534-9fc6-dd6eccab8226"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "False", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[False, " ", True, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[27]:=",ExpressionUUID->"d0811962-22f0-4294-8c4c-6acd4642796f"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{
  "False", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "False", 
   "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "True"}],
  SequenceForm[False, " ", False, " ", True],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[27]:=",ExpressionUUID->"db600ea2-2a0e-45b3-bdfc-ab9e13470151"]
}, Open  ]]
}, Open  ]],

Cell[TextData[{
 "Note that the output indicates that the proposition, ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "\[And]", "q"}], ")"}], "\[Implies]", "p"}], 
   TraditionalForm]],ExpressionUUID->"879836a6-314d-4152-81c0-897d7779a05f"],
 ", is a tautology. In fact, this is the rule of inference called \
simplification, discussed in Section 1.6 of the textbook."
}], "Text",ExpressionUUID->"4cc3cd64-25ed-4574-b13a-d521b33804b7"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Logic and Bit Operations", "Subsection",
 CellTags->"Section1e",ExpressionUUID->"dc41b0cd-d50f-4ce8-a063-042e483cfd23"],

Cell[TextData[{
 "We can also use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to explore the bit operations OR, AND, and XOR. Recall that bit operations \
correspond to logical operators by equating 1 with true and 0 with false. The \
Wolfram Language provides a lot of support for working with bits and bit \
strings. Here, we will briefly introduce the relevant functions. Our main \
goal of this section, however, will be to develop a function essentially from \
scratch for computing with bit strings, in order to further illustrate \
programming in the Wolfram Language",
 StyleBox[".",
  FontSlant->"Italic"]
}], "Text",ExpressionUUID->"1459c6f9-0d74-4db7-857d-a3a2360f5c60"],

Cell[CellGroupData[{

Cell["The Built-In Functions", "Subsubsection",ExpressionUUID->"ebae6291-fc82-4bcd-95d3-dcc037e30ad0"],

Cell[TextData[{
 "The Wolfram Language provides several functions corresponding to the basic \
logical operations for operation on bits: ",
 StyleBox[ButtonBox["BitAnd",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitAnd"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["BitOr",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitOr"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["BitXor",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitXor"], "FunctionLink"],
 ", and ",
 StyleBox[ButtonBox["BitNot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitNot"], "FunctionLink"],
 ". With the exception of ",
 StyleBox[ButtonBox["BitNot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitNot"], "FunctionLink"],
 ", these operations operate as you would expect. For example, you can \
compute ",
 Cell[BoxData[
  FormBox[
   RowBox[{"1", "\[And]", "0"}], TraditionalForm]],ExpressionUUID->
  "e8ddeb49-1eba-4ba5-a1bc-5fe7e3de37ca"],
 " as follows."
}], "Text",ExpressionUUID->"e3e3c596-0dcf-402e-b1ad-e0fc722e2909"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitAnd", "[", 
  RowBox[{"1", ",", "0"}], "]"}]], "Input",
 CellLabel->"In[28]:=",ExpressionUUID->"fc6a6f05-962b-4304-824b-bd7cebbea9d2"],

Cell[BoxData["0"], "Output",
 CellLabel->"Out[28]=",ExpressionUUID->"04641b18-6797-4e06-bac6-3274390ff5d4"]
}, Open  ]],

Cell[TextData[{
 "In addition, you are not limited to two arguments. For example, computing \
",
 Cell[BoxData[
  FormBox[
   RowBox[{"0", "\[Or]", "0", "\[Or]", "1", "\[Or]", "0"}], TraditionalForm]],
  ExpressionUUID->"e50ea99e-a5a0-48de-b288-bee5f79a825e"],
 " requires only one application of ",
 StyleBox[ButtonBox["BitOr",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitOr"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"cf64246d-41f6-4997-b8b2-af643e00933c"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitOr", "[", 
  RowBox[{"0", ",", "0", ",", "1", ",", "0"}], "]"}]], "Input",
 CellLabel->"In[29]:=",ExpressionUUID->"207ff25a-f358-476b-a8e1-496dc266b0e9"],

Cell[BoxData["1"], "Output",
 CellLabel->"Out[29]=",ExpressionUUID->"c713ccf0-014e-4c51-8f73-47938e1e6df1"]
}, Open  ]],

Cell[TextData[{
 "Conveniently, the bitwise functions are ",
 StyleBox[ButtonBox["Listable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Listable"], "FunctionLink"],
 ". This means that the function is automatically threaded over lists that \
are given as arguments. This can be made clearer by demonstrating with \
another listable function: addition."
}], "Text",ExpressionUUID->"d414696f-6259-46fa-9fe8-b0f4243d3343"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"{", 
   RowBox[{"1", ",", "2", ",", "3"}], "}"}], "+", 
  RowBox[{"{", 
   RowBox[{"a", ",", "b", ",", "c"}], "}"}]}]], "Input",
 CellLabel->"In[30]:=",ExpressionUUID->"9c8f9d34-497d-4bd7-9f4b-1770c0746025"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"1", "+", "a"}], ",", 
   RowBox[{"2", "+", "b"}], ",", 
   RowBox[{"3", "+", "c"}]}], "}"}]], "Output",
 CellLabel->"Out[30]=",ExpressionUUID->"0287c41f-bc0c-46eb-b683-e21c3f776d79"]
}, Open  ]],

Cell[TextData[{
 "Because addition is listable, when it is applied to two lists of equal \
length, it returns the list formed by acting on corresponding elements of the \
lists. In the current context, this means we can apply the bitwise operations \
to bit strings by representing the bit strings as lists. For example, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"10010", "\[And]", "01011"}], TraditionalForm]],ExpressionUUID->
  "81eb0586-29ec-457e-9917-568828316242"],
 " can be computed as shown below."
}], "Text",ExpressionUUID->"971c41ad-c33f-4790-938f-2859cf0a7f56"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitAnd", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"0", ",", "1", ",", "0", ",", "1", ",", "1"}], "}"}]}], 
  "]"}]], "Input",
 CellLabel->"In[31]:=",ExpressionUUID->"4ef5e046-faed-492e-82e3-54c96eb5f702"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"0", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}]], "Output",
 CellLabel->"Out[31]=",ExpressionUUID->"62259230-072c-469c-8452-ada5b9bf53fa"]
}, Open  ]],

Cell[TextData[{
 "The bitwise functions actually operate on integers, not just the bits 0 and \
1",
 ". ",
 "For example, we can apply ",
 StyleBox[ButtonBox["BitOr",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitOr"], "FunctionLink"],
 " to 18 and 5."
}], "Text",ExpressionUUID->"76464125-5304-4605-98a8-2ac0a1d2d78c"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitOr", "[", 
  RowBox[{"18", ",", "5"}], "]"}]], "Input",
 CellLabel->"In[32]:=",ExpressionUUID->"8eaf7572-29f2-4909-a7a5-702f2df5c673"],

Cell[BoxData["23"], "Output",
 CellLabel->"Out[32]=",ExpressionUUID->"d318d5c3-cd78-4ad9-ad8e-91c4c4def82f"]
}, Open  ]],

Cell[TextData[{
 "The reason for this result is that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " applied the bitwise OR to the binary representations of the integers 18 \
and 5",
 ". ",
 "You can use the function ",
 StyleBox[ButtonBox["IntegerDigits",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/IntegerDigits"], "FunctionLink"],
 " with an integer as the first coordinate and 2 as the second coordinate to \
see the binary representation of an integer."
}], "Text",ExpressionUUID->"c088fc42-172b-4167-93ce-8570e861196a"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"IntegerDigits", "[", 
  RowBox[{"18", ",", "2"}], "]"}]], "Input",
 CellLabel->"In[33]:=",ExpressionUUID->"a12ae2f4-3090-4d3e-a7be-505b0064d623"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}]], "Output",
 CellLabel->"Out[33]=",ExpressionUUID->"1736af2c-78fc-49cb-96de-471c3734f547"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"IntegerDigits", "[", 
  RowBox[{"5", ",", "2"}], "]"}]], "Input",
 CellLabel->"In[34]:=",ExpressionUUID->"1d95f4c9-20ca-446f-9e9a-c96633e1be57"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "0", ",", "1"}], "}"}]], "Output",
 CellLabel->"Out[34]=",ExpressionUUID->"b14bf0d7-43c2-40c0-8a78-a5e9977b1836"]
}, Open  ]],

Cell[TextData[{
 "We need to pad the result for 5 with 0s in order to have lists of equal \
size and then we can apply ",
 StyleBox[ButtonBox["BitOr",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitOr"], "FunctionLink"],
 " on the lists of bits as we did above."
}], "Text",ExpressionUUID->"6520bf56-fa44-4537-a6ee-cd859c8f6b3a"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitOr", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"0", ",", "0", ",", "1", ",", "0", ",", "1"}], "}"}]}], 
  "]"}]], "Input",
 CellLabel->"In[35]:=",ExpressionUUID->"2176c7ac-aa13-4d89-858e-f8b153b1e32e"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "0", ",", "1", ",", "1", ",", "1"}], "}"}]], "Output",
 CellLabel->"Out[35]=",ExpressionUUID->"187e842a-de46-43a5-99e9-98b4d43da51d"]
}, Open  ]],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["FromDigits",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/FromDigits"], "FunctionLink"],
 " function reverses ",
 StyleBox[ButtonBox["IntegerDigits",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/IntegerDigits"], "FunctionLink"],
 ". ",
 "Given a list of bits and second argument 2, it will return the integer with \
that binary representation."
}], "Text",ExpressionUUID->"3ab8fd89-e71c-4d9d-aa14-58287b155638"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"FromDigits", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "0", ",", "1", ",", "1", ",", "1"}], "}"}], ",", "2"}], 
  "]"}]], "Input",
 CellLabel->"In[36]:=",ExpressionUUID->"f8beabfc-690f-4832-ac58-15045b66358c"],

Cell[BoxData["23"], "Output",
 CellLabel->"Out[36]=",ExpressionUUID->"50dd0d9d-3ae0-4492-bbfc-0be4ed6b2463"]
}, Open  ]],

Cell[TextData[{
 "Understanding the operation of ",
 StyleBox[ButtonBox["BitNot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitNot"], "FunctionLink"],
 " is a bit more complicated. As expected, it accepts only one argument, \
although again, it will automatically thread through a list. The results on 0 \
and 1, however, are not what you would expect."
}], "Text",ExpressionUUID->"8d0e7214-843b-4f41-a9ac-8823c26e43f5"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitNot", "[", "0", "]"}]], "Input",
 CellLabel->"In[37]:=",ExpressionUUID->"390aeada-eff9-445c-8d93-c3915e2fa9d9"],

Cell[BoxData[
 RowBox[{"-", "1"}]], "Output",
 CellLabel->"Out[37]=",ExpressionUUID->"1a433bc3-c40e-4bd1-b437-218e8f8d5449"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitNot", "[", "1", "]"}]], "Input",
 CellLabel->"In[38]:=",ExpressionUUID->"66e4abca-f87f-4888-82ec-31b871d2a61f"],

Cell[BoxData[
 RowBox[{"-", "2"}]], "Output",
 CellLabel->"Out[38]=",ExpressionUUID->"c36ed259-f65c-4777-9515-8e7599764b8b"]
}, Open  ]],

Cell[TextData[{
 "The reason for these results is that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " represents integers in two\[CloseCurlyQuote]s complement form with an \
unlimited number of digits. Interested readers should refer to the \
information prior to Exercise 46 in Section 4.2 of the textbook for an \
explanation of two\[CloseCurlyQuote]s complement. For this context, it is \
enough to know that ",
 StyleBox[ButtonBox["BitNot",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitNot"], "FunctionLink"],
 " applied to an integer ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "ec16f098-c5d7-4fa9-91c9-f7bb7e3d4bbb"],
 " will always return ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"-", "1"}], "-", "n"}], TraditionalForm]],ExpressionUUID->
  "246fe3b7-a7fa-4a70-a01c-e96c356b2cd6"],
 ", but that it will behave exactly as expected relative to the other \
functions. For example, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"1", "\[And]", 
    RowBox[{"(", 
     RowBox[{"\[Not]", "0"}], ")"}]}], TraditionalForm]],ExpressionUUID->
  "e0af4126-5bac-46b4-9348-2a4fe5c50179"],
 " results in 1, as it should. "
}], "Text",ExpressionUUID->"308a6155-887c-4fd3-bf52-69c374c04734"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BitAnd", "[", 
  RowBox[{"1", ",", 
   RowBox[{"BitNot", "[", "0", "]"}]}], "]"}]], "Input",
 CellLabel->"In[39]:=",ExpressionUUID->"0717c471-e923-4d91-a2fc-c13dc55dc3a6"],

Cell[BoxData["1"], "Output",
 CellLabel->"Out[39]=",ExpressionUUID->"5ea9236c-d84c-4cff-afa0-5757885d58c0"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Creating a New Bitwise And", "Subsubsection",ExpressionUUID->"cb07fe57-3c47-4972-874b-e7541a727d2a"],

Cell["\<\
As mentioned above, we will use the bitwise operations as an opportunity to \
further explore the Wolfram Language\[CloseCurlyQuote]s programming \
capabilities and some important functions. Specifically, we will build a \
bitwise conjunction function that behaves much like the built-in function for \
bits and lists of bits. \
\>", "Text",ExpressionUUID->"7d6762bd-65d0-4c05-b09d-aea44bbd6830"],

Cell[TextData[{
 "We begin by creating a function that applies only to a pair of bits. Later, \
we will extend it to bit strings. We name our function ",
 StyleBox["and", "Code"],
 ". Since Wolfram Language symbols are case-sensitive, this is different from \
the built-in function ",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 ". "
}], "Text",ExpressionUUID->"e045f207-649e-4b65-87ea-0e11d8154d81"],

Cell[TextData[{
 "To implement ",
 StyleBox["and", "Code"],
 ", we will make use of the ",
 StyleBox[ButtonBox["Switch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Switch"], "FunctionLink"],
 " function. ",
 StyleBox[ButtonBox["Switch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Switch"], "FunctionLink"],
 " is an important mechanism for controlling flow in a program. It is \
equivalent to a series of if statements, but its structure makes it more \
efficient and more easily understood",
 ". ",
 StyleBox[ButtonBox["Switch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Switch"], "FunctionLink"],
 " is executed in the form"
}], "Text",ExpressionUUID->"192263eb-ef4d-4dd8-93fb-7f4f14e36f13"],

Cell[BoxData[
 RowBox[{"Switch", "[", 
  RowBox[{
  Cell["expr", "CodeVar",ExpressionUUID->
    "06f72ad0-7119-48e6-b58e-f7e6f572c7c1"], ",", Cell[TextData[Cell[BoxData[
    FormBox[
     SubscriptBox["form", "1"], TraditionalForm]],ExpressionUUID->
    "eb92c80a-e77a-41f8-873d-f6b264d78b14"]], "CodeVar",ExpressionUUID->
    "73532c07-5d50-416b-be74-3cfc9bc0e14c"], ",", Cell[TextData[Cell[BoxData[
    FormBox[
     SubscriptBox["value", "1"], TraditionalForm]],ExpressionUUID->
    "1e040051-72a6-44d1-beea-69c75eab4356"]], "CodeVar",ExpressionUUID->
    "2f22d214-b94e-4164-b0df-753485114934"], ",", Cell[TextData[Cell[BoxData[
    FormBox[
     SubscriptBox["form", "2"], TraditionalForm]],ExpressionUUID->
    "a6bc0ab2-2bff-4c5d-b967-4a865314fd13"]], "CodeVar",ExpressionUUID->
    "675dd36d-51e9-4c94-ad1f-5cc7963fb3c2"], ",", Cell[TextData[Cell[BoxData[
    FormBox[
     SubscriptBox["value", "2"], TraditionalForm]],ExpressionUUID->
    "3d10be45-7bd8-4db9-9690-8140d457bb14"]], "CodeVar",ExpressionUUID->
    "aed94eb5-7c14-4cc5-b416-8543cf4b512b"], ",", "..."}], "]"}]], "myCode",Ex\
pressionUUID->"a9f75772-9c82-4fb6-be6d-cf466fce0198"],

Cell[TextData[{
 "The first argument is an expression that is evaluated. The rest of the \
arguments are in form/value pairs. ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " checks the result of evaluating the expression against the forms, one at a \
time and in order. If it finds a match, then it stops checking and returns \
the value associated with the matching form. If none of the forms match, then \
the result is the ",
 StyleBox[ButtonBox["Switch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Switch"], "FunctionLink"],
 " function unevaluated. "
}], "Text",ExpressionUUID->"8319f899-96db-45e5-b4ac-cf86af344ae8"],

Cell[TextData[{
 "Our ",
 StyleBox["and", "Code"],
 " function will accept two arguments. The expression we give to ",
 StyleBox[ButtonBox["Switch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Switch"], "FunctionLink"],
 " will be the list formed from the two arguments. The rest of the ",
 StyleBox[ButtonBox["Switch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Switch"], "FunctionLink"],
 " will essentially be the truth table for conjunction. The forms will be all \
the possible pairs of 0s and 1s, and the values will be 0 or 1 as appropriate."
}], "Text",ExpressionUUID->"41864553-8168-4f20-8f2a-3542edf27b01"],

Cell[BoxData[
 RowBox[{
  RowBox[{"and", "[", 
   RowBox[{"p_", ",", "q_"}], "]"}], ":=", 
  RowBox[{"Switch", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "1"}], "}"}], ",", "1", ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "0"}], "}"}], ",", "0", ",", 
    RowBox[{"{", 
     RowBox[{"0", ",", "1"}], "}"}], ",", "0", ",", 
    RowBox[{"{", 
     RowBox[{"0", ",", "0"}], "}"}], ",", "0"}], "]"}]}]], "Input",
 CellLabel->"In[40]:=",ExpressionUUID->"698dec49-4f72-452a-8b48-93c35d4891a2"],

Cell[TextData[{
 "The ",
 StyleBox["and", "Code"],
 " function we created now works as expected on bits and does nothing if it \
is given other input."
}], "Text",ExpressionUUID->"8c0a5a3e-92d9-404d-a35a-c1c8eee22f80"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"and", "[", 
  RowBox[{"1", ",", "1"}], "]"}]], "Input",
 CellLabel->"In[41]:=",ExpressionUUID->"ed7489ad-f7a7-4ef6-a09d-2ab391a8397f"],

Cell[BoxData["1"], "Output",
 CellLabel->"Out[41]=",ExpressionUUID->"9ff2a98f-194a-42ca-bdbf-5ea5d1099c90"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"and", "[", 
  RowBox[{"1", ",", "0"}], "]"}]], "Input",
 CellLabel->"In[42]:=",ExpressionUUID->"589619c2-6341-4f7c-9594-7c6efb699981"],

Cell[BoxData["0"], "Output",
 CellLabel->"Out[42]=",ExpressionUUID->"823eecc4-475a-4e25-9849-402c55afd530"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"and", "[", 
  RowBox[{"18", ",", "5"}], "]"}]], "Input",
 CellLabel->"In[43]:=",ExpressionUUID->"a17abbbe-b43e-47d5-82bd-a2ac8d567ca5"],

Cell[BoxData[
 RowBox[{"Switch", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"18", ",", "5"}], "}"}], ",", "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"1", ",", "1"}], "}"}], ",", "1", ",", "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"1", ",", "0"}], "}"}], ",", "0", ",", "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"0", ",", "1"}], "}"}], ",", "0", ",", "\[IndentingNewLine]", 
   RowBox[{"{", 
    RowBox[{"0", ",", "0"}], "}"}], ",", "0"}], "]"}]], "Output",
 CellLabel->"Out[43]=",ExpressionUUID->"95ba0556-2c46-47e6-b980-ba1d1774cdfa"]
}, Open  ]],

Cell[TextData[{
 "We can handle ",
 StyleBox["nonbit",
  IgnoreSpellCheck->True],
 " input a bit more elegantly by adding one more form/value pair. Using a ",
 StyleBox[ButtonBox["Blank",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Blank"], "FunctionLink"],
 " (",
 StyleBox["_", "Code"],
 ") for the form will create a default value. By creating a message \
associated to the ",
 StyleBox["and", "Code"],
 " function, we can display a useful error message, as illustrated below. The \
message is defined by setting the symbol ",
 Cell[BoxData[
  FormBox[
   RowBox[{"f", "::", "tag"}], TraditionalForm]],ExpressionUUID->
  "f818b4ac-0cb4-4f8b-9497-771f5cab7d4b"],
 " equal to the message in quotation marks, where ",
 Cell[BoxData[
  FormBox["f", TraditionalForm]],ExpressionUUID->
  "acda0676-95a6-4193-a61d-2724144c6b26"],
 " is the name of the function and ",
 Cell[BoxData[
  FormBox["tag", TraditionalForm]],ExpressionUUID->
  "697a2b81-34f6-41f0-94a1-069ccdd17698"],
 " is the \[OpenCurlyDoubleQuote]name\[CloseCurlyDoubleQuote] of the message. \
When this symbol is given as the argument to the ",
 StyleBox[ButtonBox["Message",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Message"], "FunctionLink"],
 " function, the message is shown."
}], "Text",ExpressionUUID->"978802b3-ad6a-45af-a6b5-461643ca7376"],

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"and", "::", "arg"}], "=", 
   "\"\<and called with non-bit arguments.\>\""}], ";"}]], "Input",
 InitializationCell->True,
 CellLabel->"In[44]:=",ExpressionUUID->"d0f8f5b6-763e-4954-8666-1058b1cc13a9"],

Cell[BoxData[
 RowBox[{
  RowBox[{"and", "[", 
   RowBox[{"p_", ",", "q_"}], "]"}], ":=", 
  RowBox[{"Switch", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "1"}], "}"}], ",", "1", ",", 
    RowBox[{"{", 
     RowBox[{"1", ",", "0"}], "}"}], ",", "0", ",", 
    RowBox[{"{", 
     RowBox[{"0", ",", "1"}], "}"}], ",", "0", ",", 
    RowBox[{"{", 
     RowBox[{"0", ",", "0"}], "}"}], ",", "0", ",", "_", ",", 
    RowBox[{"Message", "[", 
     RowBox[{"and", "::", "arg"}], "]"}]}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[45]:=",ExpressionUUID->"4a70430e-1d68-4903-b31c-b4ea275eea1c"],

Cell["Now, applying and to 18 and 5 produces a more useful result.", "Text",ExpressionUUID->"2a3b9682-87cc-45d4-86f2-0958a207c994"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"and", "[", 
  RowBox[{"18", ",", "5"}], "]"}]], "Input",
 CellLabel->"In[46]:=",ExpressionUUID->"345075b6-b2a6-4304-843b-19eb4afcc465"],

Cell[BoxData[
 TemplateBox[{
  "and","arg","\"and called with non-bit arguments.\"",2,46,1,
   22491408190133476437,"Local","Global`and"},
  "MessageTemplate2"]], "Message", "MSG",
 CellLabel->
  "During evaluation of \
In[46]:=",ExpressionUUID->"d823a3ae-6da6-46c3-9a8e-72730b46d4c8"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Threading and Listable", "Subsubsection",ExpressionUUID->"7a8880d9-0506-4c1b-8bd9-d3248bfb8ae6"],

Cell["\<\
We saw above that the Wolfram Language\[CloseCurlyQuote]s built-in function \
extends to lists of integers without any additional effort on our part. Here, \
we will see that it is easy to make our function do that as well.\
\>", "Text",ExpressionUUID->"071d999b-01f1-4d34-aac8-64427db700ec"],

Cell[TextData[{
 "The Wolfram Language provides ",
 StyleBox[ButtonBox["Map",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Map"], "FunctionLink"],
 " (",
 StyleBox["/@", "Code"],
 ") and ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " to facilitate the creation of functions that act on elements of lists. We \
describe ",
 StyleBox[ButtonBox["Map",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Map"], "FunctionLink"],
 " first."
}], "Text",ExpressionUUID->"26f52c64-b683-4b3f-bdbb-ae0254550a94"],

Cell[TextData[{
 "Given a function of one argument, such as ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"f", "(", "x", ")"}], "=", 
    SuperscriptBox["x", "2"]}], TraditionalForm]],ExpressionUUID->
  "a23cfe77-b197-408e-9c88-6aa4169347ea"],
 ", ",
 StyleBox[ButtonBox["Map",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Map"], "FunctionLink"],
 " causes ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to apply the function to all the elements of a list. First, define the \
function."
}], "Text",ExpressionUUID->"d9987abf-491f-44b7-93dc-8c118d6d34d4"],

Cell[BoxData[
 RowBox[{
  RowBox[{"f", "[", "x_", "]"}], " ", ":=", " ", 
  RowBox[{"x", "^", "2"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[47]:=",ExpressionUUID->"30e6b2d2-a84e-46f0-b176-7150dd20059d"],

Cell[TextData[{
 "Now, call ",
 StyleBox[ButtonBox["Map",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Map"], "FunctionLink"],
 " with the name of the function as the first argument and the list of input \
values as the second."
}], "Text",ExpressionUUID->"7a7945bc-eb95-45bc-8cad-7b70bcf93d66"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Map", "[", 
  RowBox[{"f", ",", 
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6"}], "}"}]}], 
  "]"}]], "Input",
 CellLabel->"In[48]:=",ExpressionUUID->"88d50cbb-6438-47f5-8e45-bdd0d63f3287"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "4", ",", "9", ",", "16", ",", "25", ",", "36"}], 
  "}"}]], "Output",
 CellLabel->"Out[48]=",ExpressionUUID->"4ff8a4ad-32f9-442d-b665-3307e5993340"]
}, Open  ]],

Cell[TextData[{
 "The result, as you see above, is the list of the results of applying the \
function to each element of the list",
 ". ",
 "The same result can be obtained with the ",
 StyleBox["/@", "Code"],
 " operator, as shown below."
}], "Text",ExpressionUUID->"7cf352dd-aa67-4e20-adee-e730563477e9"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"f", "/@", 
  RowBox[{"{", 
   RowBox[{"1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6"}], 
   "}"}]}]], "Input",
 CellLabel->"In[49]:=",ExpressionUUID->"53da44be-628e-4746-a5f0-0d105f82c502"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "4", ",", "9", ",", "16", ",", "25", ",", "36"}], 
  "}"}]], "Output",
 CellLabel->"Out[49]=",ExpressionUUID->"912c7170-9b1f-4b4e-88cc-ca4ceae7bc6f"]
}, Open  ]],

Cell[TextData[{
 "When a function has more than one argument, as ",
 StyleBox["and", "Code"],
 " does, ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " can be used. Like ",
 StyleBox[ButtonBox["Map",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Map"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " takes two arguments with the first being a function. The second argument \
is a list of lists. Provided that each of the inner lists is of the same \
length, the result of ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " is the list formed by evaluating the function on tuples of arguments from \
corresponding positions in the lists. For example, we can apply ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"g", "(", 
     RowBox[{"x", ",", "y"}], ")"}], "=", 
    RowBox[{
     SuperscriptBox["x", "2"], "+", 
     SuperscriptBox["y", "3"]}]}], TraditionalForm]],ExpressionUUID->
  "46a0613c-f29b-49ee-a59d-f99e331b6a90"],
 " to ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], TraditionalForm]],
  ExpressionUUID->"6ca7cdc6-74b3-440a-b01c-4e76f3a539e1"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"a", ",", "b", ",", "c"}], "}"}], TraditionalForm]],
  ExpressionUUID->"a7ca6bd7-d41e-409a-b0c6-3375cc0452d5"],
 " in order to obtain ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{
     RowBox[{"g", "(", 
      RowBox[{"1", ",", "a"}], ")"}], ",", 
     RowBox[{"g", "(", 
      RowBox[{"2", ",", "b"}], ")"}], ",", 
     RowBox[{"g", "(", 
      RowBox[{"3", ",", "c"}], ")"}]}], "}"}], TraditionalForm]],
  ExpressionUUID->"90e64f81-60bc-4bac-ac65-5d7141b414f4"],
 "."
}], "Text",ExpressionUUID->"f913754d-dda2-4206-a523-d808faaa31bf"],

Cell[BoxData[
 RowBox[{
  RowBox[{"g", "[", 
   RowBox[{"x_", ",", "y_"}], "]"}], ":=", 
  RowBox[{
   RowBox[{"x", "^", "2"}], "+", 
   RowBox[{"y", "^", "3"}]}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[50]:=",ExpressionUUID->"80c37b41-b5ae-4668-ae58-ec4bcfdcf0be"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"MapThread", "[", 
  RowBox[{"g", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "2", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"a", ",", "b", ",", "c"}], "}"}]}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[51]:=",ExpressionUUID->"5ea47883-d3e2-4436-82b9-ab0a3aebf812"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"1", "+", 
    SuperscriptBox["a", "3"]}], ",", 
   RowBox[{"4", "+", 
    SuperscriptBox["b", "3"]}], ",", 
   RowBox[{"9", "+", 
    SuperscriptBox["c", "3"]}]}], "}"}]], "Output",
 CellLabel->"Out[51]=",ExpressionUUID->"ce059617-08fc-47fb-b9da-81ddf3a391cc"]
}, Open  ]],

Cell[TextData[{
 "Using ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 ", we can compute ",
 Cell[BoxData[
  FormBox[
   RowBox[{"10010", "\[And]", "01011"}], TraditionalForm]],ExpressionUUID->
  "2368696f-8087-41b6-97c7-b056a03ec8fe"],
 " as illustrated below."
}], "Text",ExpressionUUID->"3ae96b85-0cdb-47d5-b8ff-eda36400604b"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"MapThread", "[", 
  RowBox[{"and", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"0", ",", "1", ",", "0", ",", "1", ",", "1"}], "}"}]}], "}"}]}],
   "]"}]], "Input",
 CellLabel->"In[52]:=",ExpressionUUID->"bc891f51-b065-459e-ae5a-a7925a5624d5"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"0", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}]], "Output",
 CellLabel->"Out[52]=",ExpressionUUID->"b298f36b-e69f-43af-8e6a-7697b73c591a"]
}, Open  ]],

Cell[TextData[{
 "This shows how to thread a function in a particular case. However, what we \
really want is for our ",
 StyleBox["and", "Code"],
 " function to behave like this automatically. Fortunately, this is such a \
common requirement for functions, that the Wolfram Language provides a very \
easy way to do this. The attribute ",
 StyleBox[ButtonBox["Listable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Listable"], "FunctionLink"],
 " indicates that the function should be automatically threaded over lists \
whenever the function is given a list as its argument. The ",
 StyleBox[ButtonBox["SetAttributes",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SetAttributes"], "FunctionLink"],
 " function causes ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to associate the attribute specified in the second argument with the \
symbol in the first argument."
}], "Text",ExpressionUUID->"90479869-e881-4a0e-b4fa-cd8ed4ac9f07"],

Cell[BoxData[
 RowBox[{"SetAttributes", "[", 
  RowBox[{"and", ",", "Listable"}], "]"}]], "Input",
 InitializationCell->True,
 CellLabel->"In[53]:=",ExpressionUUID->"302b854e-c91b-4e9f-97ad-4baba163f813"],

Cell[TextData[{
 "Now, applying ",
 StyleBox["and", "Code"],
 " to lists works just as the built-in ",
 StyleBox[ButtonBox["BitAnd",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BitAnd"], "FunctionLink"],
 " does."
}], "Text",ExpressionUUID->"bf518505-d91c-4428-8d65-31f59bc080dd"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"and", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"0", ",", "1", ",", "0", ",", "1", ",", "1"}], "}"}]}], 
  "]"}]], "Input",
 CellLabel->"In[54]:=",ExpressionUUID->"499b10d8-3b7d-436c-bfc2-e9aa45c41e7c"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"0", ",", "0", ",", "0", ",", "1", ",", "0"}], "}"}]], "Output",
 CellLabel->"Out[54]=",ExpressionUUID->"f4fb110a-e8cb-4238-ac0d-f513338427c6"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.2 Applications of Propositional Logic", "Section",
 CellTags->"Section2",ExpressionUUID->"24baadba-7542-43af-84e4-181f4a4bb1ec"],

Cell[TextData[{
 "In this section, we will describe how ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "\[CloseCurlyQuote]s computational abilities can be used to solve applied \
problems in propositional logic. In particular, we will consider consistency \
for system specifications and Smullyan logic puzzles."
}], "Text",ExpressionUUID->"61915f6c-7ecd-437e-836f-c9913c741f2d"],

Cell[CellGroupData[{

Cell["System Specifications", "Subsection",
 CellTags->"Section2a",ExpressionUUID->"57c1656b-f950-4ad4-829a-bfa697ba05c8"],

Cell["\<\
The textbook describes how system specifications can be translated into \
propositional logic and how it is important that the specifications be \
consistent. As suggested by the textbook, one way to determine whether a set \
of specifications is consistent is with truth tables.\
\>", "Text",ExpressionUUID->"34b7fa87-c2f9-4395-9c4c-37b533db849a"],

Cell[TextData[{
 "Recall that a collection of propositions is consistent when there is an \
assignment of truth values to the propositional variables that makes all of \
the propositions in the collection true simultaneously. For example, consider \
the following collection of compound propositions: ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[Rule]", 
    RowBox[{"(", 
     RowBox[{"q", "\[And]", "r"}], ")"}]}], TraditionalForm]],ExpressionUUID->
  "58162bab-dfb9-4ca7-a8b8-14a84f57b198"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[Or]", "q"}], TraditionalForm]],ExpressionUUID->
  "233d23c8-94c8-40bf-8eca-b3bb388a4ef1"],
 ", and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[Or]", 
    RowBox[{"\[Not]", "r"}]}], TraditionalForm]],ExpressionUUID->
  "fa9e9a63-f195-4590-a357-c08b85f8d44a"],
 ". We can see that these propositions are consistent because we can satisfy \
all three with the assignment ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "=", "false"}], TraditionalForm]],ExpressionUUID->
  "7a234275-148f-4bd7-a5a8-02e94d24005f"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{"q", "=", "true"}], TraditionalForm]],ExpressionUUID->
  "7733eaa0-5eaf-4d12-96de-298b3fdc1495"],
 ", and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"r", "=", "false"}], TraditionalForm]],ExpressionUUID->
  "da2c9e4f-9570-4498-905f-2ac3da0c3c61"],
 ". We can confirm this by evaluating the list of propositions with that \
assignment of truth values. "
}], "Text",ExpressionUUID->"60d63228-8079-4cc5-84f7-5bbea0a35a2b"],

Cell[TextData[{
 "Above, we saw that you can evaluate an expression using the replacement \
operator ",
 StyleBox["/.", "Code"],
 ". On the left side of the replacement operator, we put the expression we \
want evaluated, in this case a list of the three logical propositions. On the \
right side of the ",
 StyleBox["/.", "Code"],
 ", we enter the assignments as a list of rules of the form ",
 StyleBox["s -> v", "Code"],
 " for symbol ",
 StyleBox["s", "Code"],
 " and value ",
 StyleBox["v", "Code"],
 "."
}], "Text",ExpressionUUID->"6188f7d7-6615-4f62-a325-56d4e4f79ef6"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"{", 
   RowBox[{
    RowBox[{"Implies", "[", 
     RowBox[{"p", ",", 
      RowBox[{"q", "&&", "r"}]}], "]"}], ",", 
    RowBox[{"p", "||", "q"}], ",", 
    RowBox[{"p", "||", 
     RowBox[{"(", 
      RowBox[{"!", "r"}], ")"}]}]}], "}"}], "/.", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"p", "\[Rule]", "False"}], ",", 
    RowBox[{"q", "\[Rule]", "True"}], ",", 
    RowBox[{"r", "\[Rule]", "False"}]}], "}"}]}]], "Input",
 CellLabel->"In[55]:=",ExpressionUUID->"381533c6-c463-4264-bbac-d32c93530c5c"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "True", ",", "True"}], "}"}]], "Output",
 CellLabel->"Out[55]=",ExpressionUUID->"91d07e90-63e7-40f7-9af6-61163a094489"]
}, Open  ]],

Cell[TextData[{
 "To determine if a collection of propositions is consistent, we can create a \
truth table. In the previous section, we created truth tables from scratch \
using the ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " function to loop through all possible assignments of truth values to the \
variables. In this section, we will instead use the Wolfram Langauge built-in \
function ",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"07f05c80-921d-4e2f-b7fa-de1775ee9a39"],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 " function produces the truth values obtained by replacing the variables by \
all possible combinations of true and false. Its first argument is the \
expression to be evaluated and the second argument is a list of the \
propositional variables."
}], "Text",ExpressionUUID->"4d95b7b4-71e8-42a7-8df8-d84bf6fe55a8"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BooleanTable", "[", 
  RowBox[{
   RowBox[{"p", "&&", 
    RowBox[{"(", 
     RowBox[{"!", "q"}], ")"}]}], ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[56]:=",ExpressionUUID->"3c9fe861-588a-44e2-b6a4-94c90fbb2fbf"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "True", ",", "False", ",", "False"}], "}"}]], "Output",\

 CellLabel->"Out[56]=",ExpressionUUID->"c1daba39-4f09-4d87-98c3-188db981c511"]
}, Open  ]],

Cell[TextData[{
 "Note that, unlike a truth table you construct by hand, ",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 " does not show the assignments to the propositional variables. We can see \
the values of the propositional variables by making the first argument a list \
that includes them."
}], "Text",ExpressionUUID->"7ad7b632-4e11-4f61-9e06-ed90c969da29"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"BooleanTable", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"p", ",", "q", ",", 
     RowBox[{"p", "&&", 
      RowBox[{"(", 
       RowBox[{"!", "q"}], ")"}]}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[57]:=",ExpressionUUID->"e02237b1-f92d-4282-801e-a63703412eda"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"True", ",", "True", ",", "False"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"True", ",", "False", ",", "True"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"False", ",", "True", ",", "False"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"False", ",", "False", ",", "False"}], "}"}]}], "}"}]], "Output",
 CellLabel->"Out[57]=",ExpressionUUID->"98a0f29b-6ab3-4f4b-9d76-511e60d750bb"]
}, Open  ]],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["TableForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TableForm"], "FunctionLink"],
 " function will make the output easier to read. We will apply ",
 StyleBox[ButtonBox["TableForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TableForm"], "FunctionLink"],
 " with the postfix operator (",
 StyleBox["//", "Code"],
 "). The postfix operator allows you to put the name of a function after an \
expression. It is commonly used for functions that affect the display of a \
result and has the benefit of making the main part of the command being \
evaluated easier to read."
}], "Text",ExpressionUUID->"4300d1e4-d3ee-46cc-b382-819c2d5ef1be"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"BooleanTable", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q", ",", 
      RowBox[{"p", "&&", 
       RowBox[{"(", 
        RowBox[{"!", "q"}], ")"}]}]}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"p", ",", "q"}], "}"}]}], "]"}], "//", "TableForm"}]], "Input",
 CellLabel->"In[58]:=",ExpressionUUID->"9414eee6-fb45-475d-ba02-1d6c8469aebe"],

Cell[BoxData[
 TagBox[GridBox[{
    {"True", "True", "False"},
    {"True", "False", "True"},
    {"False", "True", "False"},
    {"False", "False", "False"}
   },
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}},
   GridBoxSpacings->{"Columns" -> {
       Offset[0.27999999999999997`], {
        Offset[2.0999999999999996`]}, 
       Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
       Offset[0.2], {
        Offset[0.4]}, 
       Offset[0.2]}, "RowsIndexed" -> {}}],
  Function[BoxForm`e$, 
   TableForm[BoxForm`e$]]]], "Output",
 CellLabel->
  "Out[58]//TableForm=",ExpressionUUID->"d8999938-27f1-4e71-9346-\
b3131d3534c7"]
}, Open  ]],

Cell["\<\
Returning to the question of consistency, consider Example 4 from Section 1.2 \
of the text. We translate the three specifications into list of propositions \
that follows.\
\>", "Text",ExpressionUUID->"63d08faa-4e09-4329-9eaf-54305078c976"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"specEx4", "=", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"p", "||", "q"}], ",", 
    RowBox[{"!", "p"}], ",", 
    RowBox[{"Implies", "[", 
     RowBox[{"p", ",", "q"}], "]"}]}], "}"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[59]:=",ExpressionUUID->"18bd6003-aff1-4582-9eb3-3ff3f0633a2f"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"p", "||", "q"}], ",", 
   RowBox[{"!", "p"}], ",", 
   RowBox[{"p", "\[Implies]", "q"}]}], "}"}]], "Output",
 CellLabel->"Out[59]=",ExpressionUUID->"50dc90e9-9272-45af-8092-237ef7c3e2c7"]
}, Open  ]],

Cell[TextData[{
 "Then we can construct the truth table using ",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"82dd6dce-8a88-4a0c-98e0-1ae535667a85"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"BooleanTable", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q", ",", "specEx4"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"p", ",", "q"}], "}"}]}], "]"}], "//", "TableForm"}]], "Input",
 CellLabel->"In[60]:=",ExpressionUUID->"59d6ff5c-08ec-46de-87bd-5d3968f2a4b4"],

Cell[BoxData[
 InterpretationBox[GridBox[{
    {"True", "True", GridBox[{
       {"True"},
       {"False"},
       {"True"}
      },
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxSpacings->{"Columns" -> {
          Offset[0.27999999999999997`], {
           Offset[0.7]}, 
          Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
          Offset[0.2], {
           Offset[0.1]}, 
          Offset[0.2]}, "RowsIndexed" -> {}}]},
    {"True", "False", GridBox[{
       {"True"},
       {"False"},
       {"False"}
      },
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxSpacings->{"Columns" -> {
          Offset[0.27999999999999997`], {
           Offset[0.7]}, 
          Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
          Offset[0.2], {
           Offset[0.1]}, 
          Offset[0.2]}, "RowsIndexed" -> {}}]},
    {"False", "True", GridBox[{
       {"True"},
       {"True"},
       {"True"}
      },
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxSpacings->{"Columns" -> {
          Offset[0.27999999999999997`], {
           Offset[0.7]}, 
          Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
          Offset[0.2], {
           Offset[0.1]}, 
          Offset[0.2]}, "RowsIndexed" -> {}}]},
    {"False", "False", GridBox[{
       {"False"},
       {"True"},
       {"True"}
      },
      GridBoxAlignment->{
       "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
        "RowsIndexed" -> {}},
      GridBoxSpacings->{"Columns" -> {
          Offset[0.27999999999999997`], {
           Offset[0.7]}, 
          Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
          Offset[0.2], {
           Offset[0.1]}, 
          Offset[0.2]}, "RowsIndexed" -> {}}]}
   },
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}},
   GridBoxSpacings->{"Columns" -> {
       Offset[0.27999999999999997`], {
        Offset[2.0999999999999996`]}, 
       Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
       Offset[0.2], {
        Offset[0.4]}, 
       Offset[0.2]}, "RowsIndexed" -> {}}],
  TableForm[{{True, True, {True, False, True}}, {
    True, False, {True, False, False}}, {False, True, {True, True, True}}, {
    False, False, {False, True, True}}}]]], "Output",
 CellLabel->
  "Out[60]//TableForm=",ExpressionUUID->"5681ddb0-aa53-438d-8513-\
592ce559ba15"]
}, Open  ]],

Cell[TextData[{
 "Notice that, because ",
 StyleBox["specEx4", "Code"],
 " is itself a list, ",
 StyleBox[ButtonBox["TableForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TableForm"], "FunctionLink"],
 " displays the results from the three component propositions as a column \
within the row corresponding to the values for ",
 StyleBox["p", "Code"],
 " and ",
 StyleBox["q", "Code"],
 ". ",
 "We see that the only assignment of truth values that results in all three \
statements being satisfied is with ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "=", "false"}], TraditionalForm]],ExpressionUUID->
  "83e4ffb1-93a4-4f02-975e-4ab1cf5c2d74"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"q", "=", "true"}], TraditionalForm]],ExpressionUUID->
  "d463ddfb-ee09-4d10-9ffb-8b1235987b13"],
 "."
}], "Text",ExpressionUUID->"b12c9d71-e394-4313-a1b0-2aa1b6a70cce"],

Cell[TextData[{
 "We can make the output a bit easier to read if, instead of considering the \
truth table for the list of the propositions, we consider the proposition \
formed by the conjunction of the individual propositions:",
 " ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "\[Or]", "q"}], ")"}], "\[And]", 
    RowBox[{"(", 
     RowBox[{"\[Not]", "p"}], ")"}], "\[And]", 
    RowBox[{"(", 
     RowBox[{"p", "\[Rule]", "q"}], ")"}]}], TraditionalForm]],
  ExpressionUUID->"99358043-4de3-428e-b1ae-2e530736c686"],
 "."
}], "Text",ExpressionUUID->"aa431adb-7afd-4056-9c5a-b164f644a147"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"specEx4b", "=", 
  RowBox[{"And", "[", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "||", "q"}], ")"}], ",", 
    RowBox[{"!", "p"}], ",", 
    RowBox[{"Implies", "[", 
     RowBox[{"p", ",", "q"}], "]"}]}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[61]:=",ExpressionUUID->"4c41e903-6bd4-49e0-908b-44eb9da0c5b5"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{"p", "||", "q"}], ")"}], "&&", 
  RowBox[{"!", "p"}], "&&", 
  RowBox[{"(", 
   RowBox[{"p", "\[Implies]", "q"}], ")"}]}]], "Output",
 CellLabel->"Out[61]=",ExpressionUUID->"45e81280-1fac-4f86-9149-855dd26fb7b0"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"BooleanTable", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q", ",", "specEx4b"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"p", ",", "q"}], "}"}]}], "]"}], "//", "TableForm"}]], "Input",
 CellLabel->"In[62]:=",ExpressionUUID->"f2ec5902-2fe5-473b-bbf2-74a0aa0557c9"],

Cell[BoxData[
 TagBox[GridBox[{
    {"True", "True", "False"},
    {"True", "False", "False"},
    {"False", "True", "True"},
    {"False", "False", "False"}
   },
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}},
   GridBoxSpacings->{"Columns" -> {
       Offset[0.27999999999999997`], {
        Offset[2.0999999999999996`]}, 
       Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
       Offset[0.2], {
        Offset[0.4]}, 
       Offset[0.2]}, "RowsIndexed" -> {}}],
  Function[BoxForm`e$, 
   TableForm[BoxForm`e$]]]], "Output",
 CellLabel->
  "Out[62]//TableForm=",ExpressionUUID->"ea750458-2e71-474c-a35e-\
bd1e8f2f481f"]
}, Open  ]],

Cell["\<\
In this case, the fact that the final truth value in the third row is true \
tells us that this assignment of truth values satisfies all of the \
propositions in the system specification.\
\>", "Text",ExpressionUUID->"b38192ea-b44d-4ce0-be13-13edc0c794e2"],

Cell[TextData[{
 "The Wolfram Language also has useful built-in functions for checking for \
consistency. The ",
 StyleBox[ButtonBox["SatisfiableQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiableQ"], "FunctionLink"],
 " function accepts the same arguments as ",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 " (a Boolean expression and the list of propositional variables). Note that \
you may not give a list of expressions as the first argument to ",
 StyleBox[ButtonBox["SatisfiableQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiableQ"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"1a77e955-d7bd-4a1c-8ea9-78196f55020c"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SatisfiableQ", "[", 
  RowBox[{"specEx4b", ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[63]:=",ExpressionUUID->"e733b919-fd1e-49f0-8c9d-f579676160f1"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[63]=",ExpressionUUID->"6db4fb37-90b9-4f2e-b3ea-68395a5f47d4"]
}, Open  ]],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["SatisfiabilityInstances",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiabilityInstances"], "FunctionLink"],
 " command will generate an assignment of truth values to the variables that \
do in fact satisfy the proposition, assuming it is satisfiable."
}], "Text",ExpressionUUID->"c7b5a468-557c-44e9-a235-1b6fc0bd7e35"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SatisfiabilityInstances", "[", 
  RowBox[{"specEx4b", ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[64]:=",ExpressionUUID->"995a32cb-41b3-4ead-bf10-6f9221345713"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"{", 
   RowBox[{"False", ",", "True"}], "}"}], "}"}]], "Output",
 CellLabel->"Out[64]=",ExpressionUUID->"1e332bf6-23c7-4e55-91b8-746a1a624cd1"]
}, Open  ]],

Cell[TextData[{
 "By providing a positive integer as an optional third argument, you can ask \
for more choices that make the proposition true. Below, we find all three \
ways that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[Rule]", "q"}], TraditionalForm]],ExpressionUUID->
  "8e0308cc-ad58-4ae9-aa47-3aab3e34440c"],
 " can be satisfied."
}], "Text",ExpressionUUID->"4c5e92bf-14d3-42ee-bea0-044fceb6175a"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SatisfiabilityInstances", "[", 
  RowBox[{
   RowBox[{"Implies", "[", 
    RowBox[{"p", ",", "q"}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}], ",", "3"}], "]"}]], "Input",
 CellLabel->"In[65]:=",ExpressionUUID->"047b984c-5f07-4973-966f-089a9deacc09"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"True", ",", "True"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"False", ",", "True"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"False", ",", "False"}], "}"}]}], "}"}]], "Output",
 CellLabel->"Out[65]=",ExpressionUUID->"a7b18779-8417-4ada-b577-6b38ee3b8963"]
}, Open  ]],

Cell[TextData[{
 "If we add, as in Example 5 from the textbook, the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"\[Not]", "q"}], TraditionalForm]],ExpressionUUID->
  "008b8bdd-7e27-4aeb-821a-00411f3910a6"],
 ", we see that all of the assignments yield false for the conjunction of all \
four propositions."
}], "Text",ExpressionUUID->"f5e0c196-c84f-4914-8887-65bc0ed000fd"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"specEx5", "=", 
  RowBox[{"specEx4b", " ", "&&", " ", 
   RowBox[{"!", "q"}]}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[66]:=",ExpressionUUID->"ce59ae3c-5985-4d4a-bf66-3fd4666602b0"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{"p", "||", "q"}], ")"}], "&&", 
  RowBox[{"!", "p"}], "&&", 
  RowBox[{"(", 
   RowBox[{"p", "\[Implies]", "q"}], ")"}], "&&", 
  RowBox[{"!", "q"}]}]], "Output",
 CellLabel->"Out[66]=",ExpressionUUID->"85b15e9a-9864-40f9-8fc7-1a3ca01ecea6"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"BooleanTable", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q", ",", "specEx5"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"p", ",", "q"}], "}"}]}], "]"}], "//", "TableForm"}]], "Input",
 CellLabel->"In[67]:=",ExpressionUUID->"88c2ff89-d4cc-4f52-a2cd-bf58fcc2197f"],

Cell[BoxData[
 TagBox[GridBox[{
    {"True", "True", "False"},
    {"True", "False", "False"},
    {"False", "True", "False"},
    {"False", "False", "False"}
   },
   GridBoxAlignment->{
    "Columns" -> {{Left}}, "ColumnsIndexed" -> {}, "Rows" -> {{Baseline}}, 
     "RowsIndexed" -> {}},
   GridBoxSpacings->{"Columns" -> {
       Offset[0.27999999999999997`], {
        Offset[2.0999999999999996`]}, 
       Offset[0.27999999999999997`]}, "ColumnsIndexed" -> {}, "Rows" -> {
       Offset[0.2], {
        Offset[0.4]}, 
       Offset[0.2]}, "RowsIndexed" -> {}}],
  Function[BoxForm`e$, 
   TableForm[BoxForm`e$]]]], "Output",
 CellLabel->
  "Out[67]//TableForm=",ExpressionUUID->"abf322a2-d192-4225-818d-\
5842cec387c7"]
}, Open  ]],

Cell[TextData[{
 "In addition, note that ",
 StyleBox[ButtonBox["SatisfiableQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiableQ"], "FunctionLink"],
 " returns false and ",
 StyleBox[ButtonBox["SatisfiabilityInstances",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiabilityInstances"], "FunctionLink"],
 " returns an empty list."
}], "Text",ExpressionUUID->"d5c7413d-5559-4446-9a68-d62ec5f0a7c3"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SatisfiableQ", "[", 
  RowBox[{"specEx5", ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[68]:=",ExpressionUUID->"9342b3dc-d4da-47fe-accd-4730a7a8b8ae"],

Cell[BoxData["False"], "Output",
 CellLabel->"Out[68]=",ExpressionUUID->"9e0b5ee5-0197-434b-9d57-9c36ea3677a3"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SatisfiabilityInstances", "[", 
  RowBox[{"specEx5", ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[69]:=",ExpressionUUID->"ad758a1e-4a8b-44ba-9ff8-92b3ca6e1e53"],

Cell[BoxData[
 RowBox[{"{", "}"}]], "Output",
 CellLabel->"Out[69]=",ExpressionUUID->"1a5e05b8-21a4-4068-92c1-d9e7aed4763e"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Logic Puzzles", "Subsection",
 CellTags->"Section2b",ExpressionUUID->"eff2eb80-9f53-4d45-96e1-83e66d3c018a"],

Cell["\<\
Recall the knights and knaves puzzle presented in Example 8 of Section 1.2 of \
the text. In this puzzle, you are asked to imagine an island on which each \
inhabitant is either a knight and always tells the truth or is a knave and \
always lies. You meet two people named A and B. Person A says \
\[OpenCurlyDoubleQuote]B is a knight\[CloseCurlyDoubleQuote] and person B \
says \[OpenCurlyDoubleQuote]The two of us are opposite types.\
\[CloseCurlyDoubleQuote] The puzzle is to determine which kind of inhabitants \
A and B are.\
\>", "Text",ExpressionUUID->"5201592a-6775-4f90-bb77-2bd659c3ca16"],

Cell[TextData[{
 "We can solve this problem using truth tables. First, we must write A\
\[CloseCurlyQuote]s and B\[CloseCurlyQuote]s statements as propositions. Let ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "26cb9579-7f6a-4807-b00c-c49e3f383a11"],
 " represent the statement that A is a knight and ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "10190d60-8d62-446a-a0c2-06c8faa55c75"],
 " represent the statement that B is a knight. Then, A\[CloseCurlyQuote]s \
statement is \[OpenCurlyDoubleQuote]",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "b283d322-037f-4ed2-b92f-5761166f3038"],
 ",\[CloseCurlyDoubleQuote] and B\[CloseCurlyQuote]s statement is \
\[OpenCurlyDoubleQuote]",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{"a", "\[And]", 
      RowBox[{"\[Not]", "b"}]}], ")"}], "\[Or]", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"\[Not]", "a"}], "\[And]", "b"}], ")"}]}], TraditionalForm]],
  ExpressionUUID->"69c803a7-a763-4e6d-bfa6-f5f8d0bd15f2"],
 ",\[CloseCurlyDoubleQuote] as discussed in the text."
}], "Text",ExpressionUUID->"c45ec1cb-4e12-4a36-82fd-b3ca0ea7d7d2"],

Cell[TextData[{
 "While these propositions precisely express the content of A\
\[CloseCurlyQuote]s and B\[CloseCurlyQuote]s assertions, it does not capture \
the additional information that A and B are making the statements. We know, \
for instance, that A either always tells the truth (knight) or always lies \
(knave). If A is a knight, then we know the statement \[OpenCurlyDoubleQuote]",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "ac2d5be2-3d26-45fa-9850-95d82863acb6"],
 "\[CloseCurlyDoubleQuote] is true. If A is not a knight, then we know the \
statement \[OpenCurlyDoubleQuote]",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "de402586-dc58-441e-8f97-a65f699ea4cb"],
 "\[CloseCurlyDoubleQuote] is false. In other words, the truth value of the \
proposition ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "5310ceff-581d-4dd1-a44a-119d95e0d515"],
 ", that is, A is a knight, is the same as the truth value of A\
\[CloseCurlyQuote]s statement, and likewise for B. Therefore, we can capture \
the meaning of \[OpenCurlyDoubleQuote]A says proposition ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]],ExpressionUUID->
  "22b62711-ce96-4e00-8647-d4f37fb22462"],
 "\[CloseCurlyDoubleQuote] by the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"a", "\[LeftRightArrow]", "p"}], TraditionalForm]],ExpressionUUID->
  "8627a0b8-2cd1-4959-92ac-a04ced3262c9"],
 ". Using the function ",
 StyleBox[ButtonBox["Equivalent",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Equivalent"], "FunctionLink"],
 ", we can express the two statements in the puzzle."
}], "Text",ExpressionUUID->"f7f6fa69-0383-40dc-b4df-19512823cba2"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ex7a", "=", 
  RowBox[{"Equivalent", "[", 
   RowBox[{"a", ",", "b"}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[70]:=",ExpressionUUID->"f6bba154-f9f0-4d57-aea0-f0125736101a"],

Cell[BoxData[
 RowBox[{"a", "\[Equivalent]", "b"}]], "Output",
 CellLabel->"Out[70]=",ExpressionUUID->"eaae6d6c-4dc3-4f7d-a54f-c112e5f77b32"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ex7b", "=", 
  RowBox[{"Equivalent", "[", 
   RowBox[{"b", ",", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"a", "&&", 
       RowBox[{"!", "b"}]}], ")"}], "||", 
     RowBox[{"(", 
      RowBox[{
       RowBox[{"!", "a"}], "&&", "b"}], ")"}]}]}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[71]:=",ExpressionUUID->"e5a82c6f-3127-45f7-8276-8fcc47d8ff1e"],

Cell[BoxData[
 RowBox[{"b", "\[Equivalent]", 
  RowBox[{
   RowBox[{"(", 
    RowBox[{"a", "&&", 
     RowBox[{"!", "b"}]}], ")"}], "||", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"!", "a"}], "&&", "b"}], ")"}]}]}]], "Output",
 CellLabel->"Out[71]=",ExpressionUUID->"c212a42e-476d-444e-b418-23a9f0bd96d1"]
}, Open  ]],

Cell[TextData[{
 "Like the system specifications above, a solution to this puzzle will \
consist of an assignment of truth values to the propositions ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "c9cbf727-ee51-4ce7-bb13-7899bf2f269a"],
 " and ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "9e4cdc99-d737-41ab-827d-ddf2d334ef3c"],
 " that make both people\[CloseCurlyQuote]s statements true."
}], "Text",ExpressionUUID->"9f7fedb8-6ae5-4b96-9873-ec5be5d0a1af"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"SatisfiabilityInstances", "[", 
  RowBox[{
   RowBox[{"ex7a", "&&", "ex7b"}], ",", 
   RowBox[{"{", 
    RowBox[{"a", ",", "b"}], "}"}], ",", "4"}], "]"}]], "Input",
 CellLabel->"In[72]:=",ExpressionUUID->"3a2779c4-827c-48ae-9105-c0924321cfa7"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"{", 
   RowBox[{"False", ",", "False"}], "}"}], "}"}]], "Output",
 CellLabel->"Out[72]=",ExpressionUUID->"f73e81cf-cd3a-4bb8-b54f-54c8ecba5743"]
}, Open  ]],

Cell[TextData[{
 "We see that both statements are satisfied when both propositions ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "f2a08890-b67e-4b10-9fad-cd704efc3fc3"],
 " and ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "077d85ba-551a-489c-b34b-ae2885e12486"],
 " are false, that is, when A and B are both knaves. Note also that since we \
asked, in the final argument, for as many as four different instances but \
only one was returned, we know that this is the only solution to the puzzle."
}], "Text",ExpressionUUID->"b498a621-0ea0-4a4a-99af-d654d9baa7d0"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.3 Propositional Equivalence", "Section",
 CellTags->"Section3",ExpressionUUID->"d1c43771-0c2f-4dff-b301-9f7e47bf2572"],

Cell[TextData[{
 "In this section, we consider logical equivalence of propositions. We will \
first look at the built-in functions for testing equivalence, and then we \
will create a function from scratch to accomplish the same goal. \
Additionally, we will use ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to solve the ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "b5ea56bb-ade4-4902-9538-7c4a4feb0407"],
 "-Queens problem as a satisfiability problem."
}], "Text",ExpressionUUID->"60a1e56b-f383-4224-9cf8-f064fcca4b69"],

Cell[CellGroupData[{

Cell["Built-In Functions", "Subsection",
 CellTags->"Section3a",ExpressionUUID->"182f68f5-fb92-4249-b54d-1424395ea9ad"],

Cell[TextData[{
 "Two propositions ",
 Cell[BoxData[
  FormBox["p", TraditionalForm]],ExpressionUUID->
  "ae6e7387-674d-45cb-8058-943cfcf02ffd"],
 " and ",
 Cell[BoxData[
  FormBox["q", TraditionalForm]],ExpressionUUID->
  "d55df516-bd57-4881-ae6b-250a075a3570"],
 " are logically equivalent if the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[LeftRightArrow]", "q"}], TraditionalForm]],ExpressionUUID->
  "c3900109-7667-4679-abd2-39320dec7e63"],
 " is a tautology. The Wolfram Language includes a function for checking \
whether a proposition is a tautology, ",
 StyleBox[ButtonBox["TautologyQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TautologyQ"], "FunctionLink"],
 ". This function uses the same arguments as ",
 StyleBox[ButtonBox["BooleanTable",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanTable"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["SatisfiableQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiableQ"], "FunctionLink"],
 ", and ",
 StyleBox[ButtonBox["SatisfiabilityInstances",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiabilityInstances"], "FunctionLink"],
 " do, as described above. Specifically, the first argument should be the \
proposition and the second argument should be a list of the propositional \
variables. "
}], "Text",ExpressionUUID->"7bfd1b3d-7dd6-4a0e-8898-36ffb3a30370"],

Cell[TextData[{
 "For example, we confirm that the DeMorgan\[CloseCurlyQuote]s law ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"\[Not]", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"p", "\[And]", "q"}], ")"}], "\[Congruent]", 
      RowBox[{"\[Not]", "p"}]}]}], "\[Or]", 
    RowBox[{"\[Not]", "q"}]}], TraditionalForm]],ExpressionUUID->
  "02f6780a-81bf-47b8-a373-97af2dbbc6e6"],
 " is a propositional equivalence below."
}], "Text",ExpressionUUID->"b85e8533-aaaf-4674-b6e8-7bf23a1a9411"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TautologyQ", "[", 
  RowBox[{
   RowBox[{"Equivalent", "[", 
    RowBox[{
     RowBox[{"!", 
      RowBox[{"(", 
       RowBox[{"p", "&&", "q"}], ")"}]}], ",", 
     RowBox[{
      RowBox[{"!", "p"}], "||", 
      RowBox[{"!", "q"}]}]}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}]}], "]"}]], "Input",
 CellLabel->"In[73]:=",ExpressionUUID->"cf49e959-2e84-42a0-9c7b-3d8c02a0c7de"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[73]=",ExpressionUUID->"23073764-9c86-45f8-b04e-bb5e83083713"]
}, Open  ]],

Cell[TextData[{
 "Remember that the ",
 StyleBox[ButtonBox["Equivalent",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Equivalent"], "FunctionLink"],
 " function, used above, is the Wolfram Language function for forming the \
biconditional and should not be confused with the notion of equivalence as \
used in Section 1.3 of the textbook. "
}], "Text",ExpressionUUID->"4b949389-fda5-42ee-b264-68b73f1b7c20"],

Cell[TextData[{
 "Note that the second argument to ",
 StyleBox[ButtonBox["TautologyQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TautologyQ"], "FunctionLink"],
 " is not generally necessary. The ",
 StyleBox[ButtonBox["BooleanVariables",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/BooleanVariables"], "FunctionLink"],
 " function, which determines the variables in a logical expression, will \
invisibly supply the missing argument. This is, in fact, true about most of \
the functions that require the variable list as the second argument. We \
demonstrate with the other DeMorgan\[CloseCurlyQuote]s law."
}], "Text",ExpressionUUID->"3d825ea3-dc28-4068-96b5-ea4153cf041e"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TautologyQ", "[", 
  RowBox[{"Equivalent", "[", 
   RowBox[{
    RowBox[{"!", 
     RowBox[{"(", 
      RowBox[{"p", "||", "q"}], ")"}]}], ",", 
    RowBox[{
     RowBox[{"!", "p"}], "&&", 
     RowBox[{"!", "q"}]}]}], "]"}], "]"}]], "Input",
 CellLabel->"In[74]:=",ExpressionUUID->"ec9e7122-8112-40b4-bfe1-0b14f74ef302"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[74]=",ExpressionUUID->"e2c996c7-d51e-4533-acd4-56e1a1715c6b"]
}, Open  ]],

Cell[TextData[{
 "You might find it convenient to have a single function that, given two \
propositions, will determine whether they are logically equivalent. In the \
Wolfram Language, this is easy to achieve. We just need to create a function \
that takes two propositions, uses the ",
 StyleBox[ButtonBox["Equivalent",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Equivalent"], "FunctionLink"],
 " function to create the biconditional, and then applies ",
 StyleBox[ButtonBox["TautologyQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TautologyQ"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"55ae7410-02c3-4c8d-a13c-eaba23d3cef8"],

Cell[BoxData[
 RowBox[{
  RowBox[{"equivalentQ", "[", 
   RowBox[{"p_", ",", "q_"}], "]"}], ":=", 
  RowBox[{"TautologyQ", "[", 
   RowBox[{"Equivalent", "[", 
    RowBox[{"p", ",", "q"}], "]"}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[75]:=",ExpressionUUID->"30a91e65-20bf-462e-b265-41812d7c130b"],

Cell["\<\
We apply this function to see if we can generalize \
DeMorgan\[CloseCurlyQuote]s laws to three variables.\
\>", "Text",ExpressionUUID->"966903e5-0514-44fe-8b21-b25c426a26a0"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"equivalentQ", "[", 
  RowBox[{
   RowBox[{"!", 
    RowBox[{"(", 
     RowBox[{"p", "||", "q", "||", "r"}], ")"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "&&", 
    RowBox[{"!", "q"}], "&&", 
    RowBox[{"!", "r"}]}]}], "]"}]], "Input",
 CellLabel->"In[76]:=",ExpressionUUID->"bdf3aea5-101b-4300-b5b9-36efd6293576"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[76]=",ExpressionUUID->"f937cfc7-bd5a-4773-b67b-2e3eaccc0807"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"equivalentQ", "[", 
  RowBox[{
   RowBox[{"!", 
    RowBox[{"(", 
     RowBox[{"p", "&&", "q", "&&", "r"}], ")"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "||", 
    RowBox[{"!", "q"}], "||", 
    RowBox[{"!", "r"}]}]}], "]"}]], "Input",
 CellLabel->"In[77]:=",ExpressionUUID->"04b90f42-1973-4c3f-9ea6-07caa2693e42"],

Cell[BoxData["True"], "Output",
 CellLabel->"Out[77]=",ExpressionUUID->"27cab972-fa1e-4a85-a352-789e6c20cdda"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Built from Scratch Function", "Subsection",
 CellTags->"Section3b",ExpressionUUID->"5657657d-bbe3-4ee8-80f4-5be8d952f98b"],

Cell[TextData[{
 "The Wolfram Language provides extensive built-in support for working with \
logical propositions and, in particular, checking propositional equivalence. \
Here, however, we are going to build a new function for checking whether or \
not two propositions are logically equivalent using a minimum of high-level \
functions. In fact, other than asking ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to evaluate propositional expressions for particular truth values assigned \
to propositional variables, we will make use only of the Wolfram Language\
\[CloseCurlyQuote]s essential programming functionality."
}], "Text",ExpressionUUID->"d2a30189-f32c-4227-baa7-06b7f473d1cc"],

Cell[TextData[{
 "There are two goals here. First, to illustrate more of the Wolfram Language\
\[CloseCurlyQuote]s programming abilities. Second, to reveal some of the more \
fundamental concepts and methods used in ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". "
}], "Text",ExpressionUUID->"a35136ca-4871-44d7-9d5a-5bd961731823"],

Cell[TextData[{
 "We will create a function ",
 StyleBox["myEquivalentQ", "Code"],
 " that has the same effect as the ",
 StyleBox["equivalentQ", "Code"],
 " function that we built above using the Wolfram Language\[CloseCurlyQuote]s \
built-in symbols. Specifically, our function should take two propositions and \
determine whether or not they are equivalent. This will require quite a bit \
of work. The main hurdles for such a function are (1) having ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " determine what propositional variables are used in the input propositions \
and (2) without ",
 StyleBox["a priori",
  FontSlant->"Italic"],
 " knowledge of the number of propositional variables, having ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " test every possible assignment of truth values. Note that we could avoid \
both of these hurdles by insisting that the propositional variables be \
limited to a certain small set of symbols, perhaps p, q, r, and s. Then, we \
could implement the function using a static nested ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " loop."
}], "Text",ExpressionUUID->"ae744a75-0ca9-406b-82fb-be168384997c"],

Cell["\<\
However, the two hurdles mentioned are not insurmountable, will provide a \
much more elegant and flexible procedure, and will also give us the \
opportunity to see examples of some important programming constructs.\
\>", "Text",ExpressionUUID->"77db9ccb-e553-4176-afd8-44c2321ca0cf"],

Cell[CellGroupData[{

Cell["Extracting Variables", "Subsubsection",ExpressionUUID->"b1936b15-ba6e-42e5-94dd-f63af6deaf7f"],

Cell[TextData[{
 "The first hurdle is to get ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to determine the variables used in a logical expression. Consider the \
following example."
}], "Text",ExpressionUUID->"1fa5b640-903c-41f6-9937-3c6d0f0cfdf0"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableEx", "=", 
  RowBox[{
   RowBox[{"(", 
    RowBox[{
     RowBox[{"(", 
      RowBox[{"p", "&&", "q"}], ")"}], "||", 
     RowBox[{"(", 
      RowBox[{"p", "&&", 
       RowBox[{"!", "r"}]}], ")"}]}], ")"}], "&&", 
   RowBox[{"Implies", "[", 
    RowBox[{"s", ",", "r"}], "]"}]}]}]], "Input",
 InitializationCell->True,
 CellLabel->"In[78]:=",ExpressionUUID->"36986fca-5508-4eb7-92b3-c44a18f16eb7"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "&&", "q"}], ")"}], "||", 
    RowBox[{"(", 
     RowBox[{"p", "&&", 
      RowBox[{"!", "r"}]}], ")"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{"s", "\[Implies]", "r"}], ")"}]}]], "Output",
 CellLabel->"Out[78]=",ExpressionUUID->"b7c206db-c05c-472c-bdd3-b44d467658f8"]
}, Open  ]],

Cell["\<\
Our task is to write a function that will, given the above expression, tell \
us that the variables in use are p, q, r, and s.\
\>", "Text",ExpressionUUID->"8373678a-1606-4ea7-b59d-0bbc870b2522"],

Cell[CellGroupData[{

Cell["Replacing the Head", "Subsubsubsection",
 PageBreakWithin->False,
 PageBreakBelow->False,
 GroupPageBreakWithin->
  False,ExpressionUUID->"30da3d80-9a5e-42ad-9ea3-bb22214f28a6"],

Cell[TextData[{
 "Fundamentally, everything in the Wolfram Language is an expression. \
Moreover, every expression is of the form ",
 Cell[BoxData[
  RowBox[{
   StyleBox["head", "CodeVar"], "[", 
   RowBox[{Cell[TextData[Cell[BoxData[
     FormBox[
      SubscriptBox["arg", "1"], TraditionalForm]],ExpressionUUID->
     "280d749e-953f-4005-ac91-6efc973c0a72"]], "CodeVar",ExpressionUUID->
     "30671fbd-6f7a-4f37-8f64-a43851784bc5"], ",", Cell[TextData[Cell[BoxData[
    
     FormBox[
      SubscriptBox["arg", "2"], TraditionalForm]],ExpressionUUID->
     "50924b80-d318-4e80-aef7-704e39e00736"]], "CodeVar",ExpressionUUID->
     "b5d5429e-cb0a-411a-a655-beac5f36c85b"], ",", "..."}], "]"}]], "myCode",
  ExpressionUUID->"02e8a031-d64b-4523-924d-a86e8b31ae07"],
 ", that is, a head followed by arguments in brackets and separated by \
commas. You can see the structure at the heart of any expression by using the \
",
 StyleBox[ButtonBox["FullForm",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/FullForm"], "FunctionLink"],
 " function. Below, we show the full form of three examples. Recall that the \
postfix operator (",
 StyleBox["//", "Code"],
 ") allows us to put the name of the function at the end of the input."
}], "Text",
 PageBreakAbove->False,
 PageBreakWithin->
  False,ExpressionUUID->"162b5e1b-ebf3-452d-b174-77f11a0a01b0"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"x", "+", "y"}], "//", "FullForm"}]], "Input",
 CellLabel->"In[79]:=",ExpressionUUID->"f31a0a93-bd8e-4930-9496-c4dd456c63a8"],

Cell[BoxData[
 TagBox[
  StyleBox[
   RowBox[{"Plus", "[", 
    RowBox[{"x", ",", "y"}], "]"}],
   ShowSpecialCharacters->False,
   ShowStringCharacters->True,
   NumberMarks->True],
  FullForm]], "Output",
 CellLabel->
  "Out[79]//FullForm=",ExpressionUUID->"d9e7da79-43d6-4b9b-8f19-a26792390061"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableEx", "//", "FullForm"}]], "Input",
 CellLabel->"In[80]:=",ExpressionUUID->"87bc78ea-f4f6-4b16-bfa1-3996b2cf57d0"],

Cell[BoxData[
 TagBox[
  StyleBox[
   RowBox[{"And", "[", 
    RowBox[{
     RowBox[{"Or", "[", 
      RowBox[{
       RowBox[{"And", "[", 
        RowBox[{"p", ",", "q"}], "]"}], ",", 
       RowBox[{"And", "[", 
        RowBox[{"p", ",", 
         RowBox[{"Not", "[", "r", "]"}]}], "]"}]}], "]"}], ",", 
     RowBox[{"Implies", "[", 
      RowBox[{"s", ",", "r"}], "]"}]}], "]"}],
   ShowSpecialCharacters->False,
   ShowStringCharacters->True,
   NumberMarks->True],
  FullForm]], "Output",
 CellLabel->
  "Out[80]//FullForm=",ExpressionUUID->"3f54f6b3-8945-4fd3-b1de-a06cdc9ccc3f"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"{", 
   RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}], "//", 
  "FullForm"}]], "Input",
 CellLabel->"In[81]:=",ExpressionUUID->"476a0905-ae78-43d8-abda-587a644bd6d1"],

Cell[BoxData[
 TagBox[
  StyleBox[
   RowBox[{"List", "[", 
    RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "]"}],
   ShowSpecialCharacters->False,
   ShowStringCharacters->True,
   NumberMarks->True],
  FullForm]], "Output",
 CellLabel->
  "Out[81]//FullForm=",ExpressionUUID->"89f9eb61-ea10-4e89-9996-24d9d520e7e0"]
}, Open  ]],

Cell[TextData[{
 "The Wolfram Language provides a function, ",
 StyleBox[ButtonBox["Head",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Head"], "FunctionLink"],
 ", that takes an expression and returns the head of that expression. "
}], "Text",ExpressionUUID->"5084e3b1-266c-45e5-852e-ed3ef938e46e"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", 
  RowBox[{"x", "+", "y"}], "]"}]], "Input",
 CellLabel->"In[82]:=",ExpressionUUID->"c0829565-599e-406e-9209-5f5152bf810d"],

Cell[BoxData["Plus"], "Output",
 CellLabel->"Out[82]=",ExpressionUUID->"ea2f42e5-c8ca-4f81-921e-a52dbfc47292"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", "variableEx", "]"}]], "Input",
 CellLabel->"In[83]:=",ExpressionUUID->"243111fd-f55e-41b6-a8eb-4c0815f5f8a2"],

Cell[BoxData["And"], "Output",
 CellLabel->"Out[83]=",ExpressionUUID->"2fc0a823-5bed-4fa4-9848-1986a7ee530c"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Head", "[", 
  RowBox[{"{", 
   RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}], "]"}]], "Input",
 CellLabel->"In[84]:=",ExpressionUUID->"d08c0833-8bb7-4e0c-ab81-10508b0ddc28"],

Cell[BoxData["List"], "Output",
 CellLabel->"Out[84]=",ExpressionUUID->"6181e56e-a296-4fd8-9794-18d3d5ce1aea"]
}, Open  ]],

Cell[TextData[{
 "You can also access the head of an expression using the ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " (",
 StyleBox["[[\[Ellipsis]]]", "Code"],
 ") operator with index 0."
}], "Text",ExpressionUUID->"4de74996-3a6a-42d2-9bca-261d46be8b88"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{"x", "+", "y"}], ")"}], "[", 
  RowBox[{"[", "0", "]"}], "]"}]], "Input",
 CellLabel->"In[85]:=",ExpressionUUID->"790f6f01-9810-413e-a8c5-cc08c90e3f46"],

Cell[BoxData["Plus"], "Output",
 CellLabel->"Out[85]=",ExpressionUUID->"a690dbb2-7ce7-4600-a34c-72edce1ee464"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableEx", "[", 
  RowBox[{"[", "0", "]"}], "]"}]], "Input",
 CellLabel->"In[86]:=",ExpressionUUID->"e33f4938-51d6-4b53-9447-018d732435f6"],

Cell[BoxData["And"], "Output",
 CellLabel->"Out[86]=",ExpressionUUID->"278af99d-060e-4c95-85db-468e775e09f2"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"{", 
   RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}], "[", 
  RowBox[{"[", "0", "]"}], "]"}]], "Input",
 CellLabel->"In[87]:=",ExpressionUUID->"0a8a7368-8304-4a37-b1b5-5015f55c5bd0"],

Cell[BoxData["List"], "Output",
 CellLabel->"Out[87]=",ExpressionUUID->"87522410-c25f-4a48-af93-029c8138eb40"]
}, Open  ]],

Cell[TextData[{
 "Remember that our goal here is to transform a logical expression, such as \
",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"p", "\[And]", "q"}], ")"}], "\[Or]", 
      RowBox[{"(", 
       RowBox[{"p", "\[And]", 
        RowBox[{"\[Not]", "r"}]}], ")"}]}], ")"}], "\[And]", 
    RowBox[{"(", 
     RowBox[{"s", "\[Rule]", "r"}], ")"}]}], TraditionalForm]],
  ExpressionUUID->"a52f7af1-29f0-4627-a337-ebd16f9c5c21"],
 " into a list ",
 Cell[BoxData[
  FormBox[
   RowBox[{"{", 
    RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}], TraditionalForm]],
  ExpressionUUID->"c64cc4f1-db03-4d20-94cf-82a1e267fae3"],
 ". Since the main difference, in terms of the internal representation of the \
two objects, is their heads, it is natural to ask if we can change the head. \
In particular, in our example ",
 StyleBox["variableEx", "Code"],
 ", the head is ",
 StyleBox["And", "Code"],
 ". If we can replace the ",
 StyleBox["And", "Code"],
 " head with a ",
 StyleBox["List", "Code"],
 " head, we would have a list comprised of the two parts of the expression, \
as illustrated below."
}], "Text",ExpressionUUID->"51d675da-4059-468f-8aff-cdfe70e4a0e6"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"List", "[", 
  RowBox[{
   RowBox[{"Or", "[", 
    RowBox[{
     RowBox[{"And", "[", 
      RowBox[{"p", ",", "q"}], "]"}], ",", 
     RowBox[{"And", "[", 
      RowBox[{"p", ",", 
       RowBox[{"Not", "[", "r", "]"}]}], "]"}]}], "]"}], ",", 
   RowBox[{"Implies", "[", 
    RowBox[{"s", ",", "r"}], "]"}]}], "]"}]], "Input",
 CellLabel->"In[88]:=",ExpressionUUID->"b4ef6750-f8c7-4ae2-a821-f74f29705f15"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "&&", "q"}], ")"}], "||", 
    RowBox[{"(", 
     RowBox[{"p", "&&", 
      RowBox[{"!", "r"}]}], ")"}]}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->"Out[88]=",ExpressionUUID->"ee4ce7d4-3848-4804-b6dd-829bb53d8fc0"]
}, Open  ]],

Cell[TextData[{
 "Our strategy, broadly, will be to replace all of the heads in the logical \
expression with ",
 StyleBox["List", "Code"],
 " heads. There are two approaches to replacing the head of an expression. \
One is to use the fact that the head lies at index 0 to replace the heads by \
assigning the 0 indexed element to ",
 StyleBox["List", "Code"],
 " using the syntax ",
 Cell[BoxData[
  RowBox[{
   RowBox[{"x", "[", 
    RowBox[{"[", "0", "]"}], "]"}], "=", "List"}]], "myCode",ExpressionUUID->
  "b842e319-cf02-4a75-ad30-cf63733f1645"],
 ", as illustrated below."
}], "Text",ExpressionUUID->"d5f6e002-6ea0-49c2-b390-4635a60b0bf7"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"sumExample", "=", 
  RowBox[{"x", "+", "y"}]}]], "Input",
 CellLabel->"In[89]:=",ExpressionUUID->"f0efb962-503f-4ab6-aa5f-50092fcf4d56"],

Cell[BoxData[
 RowBox[{"x", "+", "y"}]], "Output",
 CellLabel->"Out[89]=",ExpressionUUID->"faa03dad-2a11-4d08-92e0-5a0a69dee5c3"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"sumExample", "[", 
   RowBox[{"[", "0", "]"}], "]"}], "=", "List"}]], "Input",
 CellLabel->"In[90]:=",ExpressionUUID->"043b67aa-0468-4755-a320-89e9b8b7adc6"],

Cell[BoxData["List"], "Output",
 CellLabel->"Out[90]=",ExpressionUUID->"29f860da-3646-45a9-a65a-1005c77aea85"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData["sumExample"], "Input",
 CellLabel->"In[91]:=",ExpressionUUID->"be2e94b5-1d11-4406-9c3a-0d41f5797abe"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"x", ",", "y"}], "}"}]], "Output",
 CellLabel->"Out[91]=",ExpressionUUID->"654b2382-1568-4004-8b32-e326a9a7aa3a"]
}, Open  ]],

Cell[TextData[{
 "The second approach is to use the ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " (",
 StyleBox["@@", "Code"],
 ") operator. An expression formed from the desired head, followed by two at \
symbols and the original expression will output the expression with the new \
head. Unlike the previous approach, if the expression is stored as a symbol, \
the stored expression is not changed, unless you explicitly reassign the \
output to the symbol. We illustrate by transforming ",
 StyleBox["sumExample", "Code"],
 " from a list into a product."
}], "Text",ExpressionUUID->"2b7eacd1-f376-455f-a5aa-579185b515f4"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"sumExample", "=", 
  RowBox[{"Times", "@@", "sumExample"}]}]], "Input",
 CellLabel->"In[92]:=",ExpressionUUID->"10434b51-75d7-4023-86fc-c977ba003bef"],

Cell[BoxData[
 RowBox[{"x", " ", "y"}]], "Output",
 CellLabel->"Out[92]=",ExpressionUUID->"1bfd3d82-c611-432e-b953-7cb4e4e2f245"]
}, Open  ]],

Cell[TextData[{
 "Note that the ",
 StyleBox[ButtonBox["Head",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Head"], "FunctionLink"],
 " command gives us a way to test what kind of expression we have. In \
particular, we can differentiate between variables, which have head ",
 StyleBox["Symbol", "Code"],
 ", and other expressions. To compare heads, you must use the ",
 StyleBox[ButtonBox["SameQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SameQ"], "FunctionLink"],
 " relation (",
 StyleBox["===", "Code"],
 ") rather than ",
 StyleBox[ButtonBox["Equal",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Equal"], "FunctionLink"],
 " (",
 StyleBox["==", "Code"],
 "), which only applies to raw data (such as numerical values and strings). "
}], "Text",ExpressionUUID->"4762d2f6-9e93-4059-9634-19ba4776e456"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"If", "[", 
  RowBox[{
   RowBox[{
    RowBox[{"Head", "[", 
     RowBox[{"x", "+", "y"}], "]"}], "===", 
    RowBox[{"Head", "[", 
     RowBox[{"x", "-", "y"}], "]"}]}], ",", "\[IndentingNewLine]", 
   RowBox[{"Print", "[", "\"\<+ equals -\>\"", "]"}], ",", 
   "\[IndentingNewLine]", 
   RowBox[{"Print", "[", "\"\<different\>\"", "]"}]}], "]"}]], "Input",
 CellLabel->"In[93]:=",ExpressionUUID->"0984d7ae-be49-404e-832b-adfaadfb1477"],

Cell[BoxData["\<\"+ equals -\"\>"], "Print",
 CellLabel->
  "During evaluation of \
In[93]:=",ExpressionUUID->"3c736ea3-dbe0-40ce-9b69-58d2e72b17ed"]
}, Open  ]],

Cell[TextData[{
 "The above shows that the heads of ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", "+", "y"}], TraditionalForm]],ExpressionUUID->
  "3b2f5ff5-f289-4916-ac10-0b2855d32533"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", "-", "y"}], TraditionalForm]],ExpressionUUID->
  "cee013e1-f329-422e-86c5-67a18820387d"],
 " are in fact the same. Both expressions have head ",
 StyleBox["Plus", "Code"],
 ". (We could also do this with the ",
 StyleBox["[[0]]", "Code"],
 " syntax, but the ",
 StyleBox[ButtonBox["Head",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Head"], "FunctionLink"],
 " function is clearer.)"
}], "Text",ExpressionUUID->"4fb50560-1958-453b-b78e-b1531a4d97c1"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Illustrating with an Example", "Subsubsubsection",ExpressionUUID->"38ce88a6-fd28-426e-bbbc-6c0dd75c44a1"],

Cell[TextData[{
 "We can now remove operators to obtain simpler expressions, and we have a \
way to test whether an expression is a variable or not. The general idea is \
that we keep replacing the heads of the subexpressions until we are down to \
nothing but names. The strategy we will use is a fairly typical one. We \
illustrate the approach step by step with the ",
 StyleBox["variableEx", "Code"],
 " example first, and then we will build a function."
}], "Text",ExpressionUUID->"8a868461-fad6-4e28-af14-74eb0ed0a6d1"],

Cell[TextData[{
 "First, we define a new symbol, ",
 StyleBox["variableExList", "Code"],
 ", to be the result of applying (",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 ", ",
 StyleBox["@@", "Code"],
 ") the ",
 StyleBox[ButtonBox["List",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/List"], "FunctionLink"],
 " head to the ",
 StyleBox["variableEx", "Code"],
 " expression. Note that this does not change the expression stored in ",
 StyleBox["variableEx", "Code"],
 ". We wish to preserve ",
 StyleBox["variableEx", "Code"],
 ", which is why we take this approach. Moving forward, we will use the ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " (",
 StyleBox["[[\[Ellipsis]]]", "Code"],
 ") approach."
}], "Text",ExpressionUUID->"fcbdc472-be82-4ba8-9366-175ccd535d18"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExList", "=", 
  RowBox[{"List", "@@", "variableEx"}]}]], "Input",
 CellLabel->"In[94]:=",ExpressionUUID->"125a2f22-c891-4cc2-9b6e-98f026541344"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{
    RowBox[{"(", 
     RowBox[{"p", "&&", "q"}], ")"}], "||", 
    RowBox[{"(", 
     RowBox[{"p", "&&", 
      RowBox[{"!", "r"}]}], ")"}]}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->"Out[94]=",ExpressionUUID->"6d3ba035-bcc6-4535-a959-baded61b85c9"]
}, Open  ]],

Cell["\<\
Observe that the topmost conjunction has been removed and we now have a list \
of the two subexpressions.\
\>", "Text",ExpressionUUID->"284b452a-6c5d-40e2-8305-83338074e5ab"],

Cell[TextData[{
 "Now, we need to do the same thing to the elements of this list. Remember \
that the ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " function (",
 StyleBox["[[\[Ellipsis]]]", "Code"],
 ") is used to obtain and to modify elements of a list, so we can obtain the \
first element in the list as follows."
}], "Text",ExpressionUUID->"49687ff4-16ce-4caa-ab9b-f6221e40ddc7"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExList", "[", 
  RowBox[{"[", "1", "]"}], "]"}]], "Input",
 CellLabel->"In[95]:=",ExpressionUUID->"2b6dd508-8d3e-4324-98f9-63cbea95e734"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{"p", "&&", "q"}], ")"}], "||", 
  RowBox[{"(", 
   RowBox[{"p", "&&", 
    RowBox[{"!", "r"}]}], ")"}]}]], "Output",
 CellLabel->"Out[95]=",ExpressionUUID->"367a9ea3-86c2-445d-8194-2ffd5cd703a8"]
}, Open  ]],

Cell[TextData[{
 "We can turn this into a list by assigning the 0-indexed element of ",
 StyleBox["variableExList[[1]]", "Code"],
 " to ",
 StyleBox[ButtonBox["List",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/List"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"c23a3063-d1a5-4d86-b05e-8fce48ace813"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{
   RowBox[{"variableExList", "[", 
    RowBox[{"[", "1", "]"}], "]"}], "[", 
   RowBox[{"[", "0", "]"}], "]"}], "=", "List"}]], "Input",
 CellLabel->"In[96]:=",ExpressionUUID->"bc14d31f-7a9c-42fd-88c4-90810cd523f2"],

Cell[BoxData["List"], "Output",
 CellLabel->"Out[96]=",ExpressionUUID->"c9cdfb34-b7a2-4a44-b538-8540692206e4"]
}, Open  ]],

Cell[TextData[{
 "Inspecting ",
 StyleBox["variableExList", "Code"],
 ", we see that this has replaced what was the first element with the new \
result."
}], "Text",ExpressionUUID->"6b4984b0-da75-4cb4-9bfb-b6e754bbb93c"],

Cell[CellGroupData[{

Cell[BoxData[
 StyleBox["variableExList", "Code"]], "Input",
 CellLabel->"In[97]:=",ExpressionUUID->"015cc428-ae70-406a-a141-50749b780272"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"p", "&&", "q"}], ",", 
     RowBox[{"p", "&&", 
      RowBox[{"!", "r"}]}]}], "}"}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->"Out[97]=",ExpressionUUID->"c85368d9-17cc-4d99-8d37-ad206f3b5c03"]
}, Open  ]],

Cell[TextData[{
 "You can see that we have already made quite a bit of progress, but now we \
have lists nested together. We can eliminate this nesting with the ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " function. We assign the result of applying the function to ",
 StyleBox["variableExList", "Code"],
 " back to ",
 StyleBox["variableExList", "Code"],
 ", so the result is kept."
}], "Text",ExpressionUUID->"6f2deef3-ad11-4324-8a90-5dfa281dbb98"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExList", "=", 
  RowBox[{"Flatten", "[", "variableExList", "]"}]}]], "Input",
 CellLabel->"In[98]:=",ExpressionUUID->"3e513f25-7710-4764-a7bb-65bcf4724904"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"p", "&&", "q"}], ",", 
   RowBox[{"p", "&&", 
    RowBox[{"!", "r"}]}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->"Out[98]=",ExpressionUUID->"3f41d7ce-fb79-4a3d-b0e5-0ccfff32aee2"]
}, Open  ]],

Cell[TextData[{
 "The first element of ",
 StyleBox["variableExList", "Code"],
 " is still a logical expression, so we repeat. This time, we will use ",
 StyleBox["[[1,0]]", "Code"],
 ", which is shorthand for ",
 StyleBox["[[1]][[0]]", "Code"],
 ". We also combine the assignment and the inspection of ",
 StyleBox["variableExList", "Code"],
 " into one input."
}], "Text",ExpressionUUID->"487ca5b3-d9d5-49ce-b928-fe099743040b"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"variableExList", "[", 
    RowBox[{"[", 
     RowBox[{"1", ",", "0"}], "]"}], "]"}], "=", "List"}], 
  ";"}], "\[IndentingNewLine]", "variableExList"}], "Input",
 CellLabel->"In[99]:=",ExpressionUUID->"f7e02cb1-333b-45bb-b646-a202b75e815d"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"p", ",", "q"}], "}"}], ",", 
   RowBox[{"p", "&&", 
    RowBox[{"!", "r"}]}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->
  "Out[100]=",ExpressionUUID->"8e05dc57-5b56-4287-a42a-43acc2b286eb"]
}, Open  ]],

Cell[TextData[{
 "Again, we use ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " since this has created a nested list structure."
}], "Text",ExpressionUUID->"c1c4c12a-95fa-463d-a8ad-8d22f9e4f3e8"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExList", "=", 
  RowBox[{"Flatten", "[", "variableExList", "]"}]}]], "Input",
 CellLabel->
  "In[101]:=",ExpressionUUID->"4510c7c9-57ae-4765-af81-a6b5bbcf0074"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", 
   RowBox[{"p", "&&", 
    RowBox[{"!", "r"}]}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->
  "Out[101]=",ExpressionUUID->"2abb8368-7e5e-4586-9f1e-7039fdea84ba"]
}, Open  ]],

Cell[TextData[{
 "The first two elements of ",
 StyleBox["variableExList", "Code"],
 " are now symbols. Thus, we skip to the third element. Again, we change the \
head of the third element to the ",
 StyleBox["List", "Code"],
 " head."
}], "Text",ExpressionUUID->"06677933-8a48-452d-9f54-0b9dfd7d89d0"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"variableExList", "[", 
    RowBox[{"[", 
     RowBox[{"3", ",", "0"}], "]"}], "]"}], "=", "List"}], 
  ";"}], "\[IndentingNewLine]", "variableExList"}], "Input",
 CellLabel->
  "In[102]:=",ExpressionUUID->"58fcd2ad-1e2f-40a7-8a03-5a67a4f33fe7"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", 
   RowBox[{"{", 
    RowBox[{"p", ",", 
     RowBox[{"!", "r"}]}], "}"}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->
  "Out[103]=",ExpressionUUID->"d692da43-c573-4fed-ba43-a30591849bde"]
}, Open  ]],

Cell["And again, flatten the resulting list.", "Text",ExpressionUUID->"7327b388-9b80-44ab-b1d7-a9f6873464c5"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExList", " ", "=", " ", 
  RowBox[{"Flatten", "[", "variableExList", "]"}]}]], "Input",
 CellLabel->
  "In[104]:=",ExpressionUUID->"72e64f45-85e2-4829-b69d-2675991f72bc"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", "p", ",", 
   RowBox[{"!", "r"}], ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->
  "Out[104]=",ExpressionUUID->"2c0aca83-d45c-46ab-8032-ffb43929b90e"]
}, Open  ]],

Cell[TextData[{
 "Now that the third element is a symbol, we do the same thing with the \
fourth element of ",
 StyleBox["variableExList", "Code"],
 ". We also include the ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " step in the same input."
}], "Text",ExpressionUUID->"d9ad8700-8cfc-480a-a05a-86d5ebad6825"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"variableExList", "[", 
    RowBox[{"[", 
     RowBox[{"4", ",", "0"}], "]"}], "]"}], "=", "List"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"variableExList", "=", 
  RowBox[{"Flatten", "[", "variableExList", "]"}]}]}], "Input",
 CellLabel->
  "In[105]:=",ExpressionUUID->"c85b8a82-fb18-45ca-b4d3-4d1d87f5a863"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", "p", ",", "r", ",", 
   RowBox[{"s", "\[Implies]", "r"}]}], "}"}]], "Output",
 CellLabel->
  "Out[106]=",ExpressionUUID->"d8499665-17ee-4b90-bd5b-08c60ce6a967"]
}, Open  ]],

Cell["And we repeat the process once more.", "Text",ExpressionUUID->"1932f69e-4992-4b95-94e2-daad75455c24"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"variableExList", "[", 
    RowBox[{"[", 
     RowBox[{"5", ",", "0"}], "]"}], "]"}], "=", "List"}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"variableExList", "=", 
  RowBox[{"Flatten", "[", "variableExList", "]"}]}]}], "Input",
 CellLabel->
  "In[107]:=",ExpressionUUID->"8011c0cc-2c21-4621-bd7c-ee94b581045a"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", "p", ",", "r", ",", "s", ",", "r"}], 
  "}"}]], "Output",
 CellLabel->
  "Out[108]=",ExpressionUUID->"058b45a9-2806-4358-b77b-6a43e486df33"]
}, Open  ]],

Cell[TextData[{
 "Now that every element in the list is a variable, we remove the duplicate \
elements with ",
 StyleBox[ButtonBox["DeleteDuplicates",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/DeleteDuplicates"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"c2cc256b-6617-42b4-bd5c-2fd759cbcf8d"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExList", "=", 
  RowBox[{"DeleteDuplicates", "[", "variableExList", "]"}]}]], "Input",
 CellLabel->
  "In[109]:=",ExpressionUUID->"7f5b3f4c-25e7-4561-8366-485d9d4d2226"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}]], "Output",
 CellLabel->
  "Out[109]=",ExpressionUUID->"c8091f4a-5f4e-4825-8f81-9f45e172d6aa"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["The Function", "Subsubsubsection",ExpressionUUID->"7d78b511-90fd-4761-8f10-3141e2fe0e2b"],

Cell["\<\
The explicit example above gives us the outline of our procedure:\
\>", "Text",ExpressionUUID->"b106c9cd-a53e-44d2-957e-437c85490082"],

Cell[CellGroupData[{

Cell[TextData[{
 "Initialize a list, ",
 StyleBox["varList", "Code"],
 ", to the list with the given proposition as the sole element. We did not do \
this in the example, but doing so means that we will always be working with a \
list, rather than having the first step be different. "
}], "Item1Numbered",ExpressionUUID->"f5a3b4e4-1aa9-4627-ba3c-e191ea21732f"],

Cell[TextData[{
 "We also initialize an index variable, ",
 StyleBox["i", "Code"],
 ", to 1. This will keep track of where we are in the list, taking the place \
of the explicit value 5, for example, in the third to last line of code above."
}], "Item1Numbered",ExpressionUUID->"1e395f72-7e47-4ff3-b659-c3d297a9c3b4"],

Cell[TextData[{
 "Use ",
 StyleBox[ButtonBox["Head",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Head"], "FunctionLink"],
 " to test whether the element in position ",
 StyleBox["i", "Code"],
 " in the list is a ",
 StyleBox["Symbol", "Code"],
 ". "
}], "Item1Numbered",ExpressionUUID->"208ee43a-2fa1-411e-ae6a-ada4025afbc7"],

Cell[CellGroupData[{

Cell[TextData[{
 "If it is a symbol, then it is the name of a variable, and we move on to the \
next position in the list by increasing ",
 StyleBox["i", "Code"],
 " by 1. "
}], "Item2",ExpressionUUID->"34363c08-2a94-46fa-8a58-c3d891d87fd4"],

Cell[TextData[{
 "If ",
 StyleBox["varList[[i]]", "Code"],
 " is not a symbol, then it must be an expression. Replace its head with ",
 StyleBox["List", "Code"],
 " and flatten ",
 StyleBox["varList", "Code"],
 ", using the same syntax as above."
}], "Item2",ExpressionUUID->"c00062e0-b79e-4ce1-bc05-20c57a0186bf"]
}, Open  ]],

Cell[TextData[{
 "Repeat step 3 until the end of the list. This repetition is controlled by a \
",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop that continues as long as ",
 StyleBox["i", "Code"],
 " is not greater than the number of elements in the list, determined by ",
 StyleBox[ButtonBox["Length",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Length"], "FunctionLink"],
 ". Once the loop is complete, remove duplicate entries."
}], "Item1Numbered",ExpressionUUID->"973691e3-f2c6-44b5-bf5b-0b89afcb170d"]
}, Open  ]],

Cell["Here is the implementation.", "Text",ExpressionUUID->"f4bd4754-3f0b-4699-bf4b-24cacf7de99c"],

Cell[BoxData[
 RowBox[{
  RowBox[{"getVars", "[", "p_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"L", "=", 
       RowBox[{"{", "p", "}"}]}], ",", 
      RowBox[{"i", "=", "1"}]}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"While", "[", 
      RowBox[{
       RowBox[{"i", "<=", 
        RowBox[{"Length", "[", "L", "]"}]}], ",", "\[IndentingNewLine]", 
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{
          RowBox[{"Head", "[", 
           RowBox[{"L", "[", 
            RowBox[{"[", "i", "]"}], "]"}], "]"}], "===", "Symbol"}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{
           RowBox[{"L", "[", 
            RowBox[{"[", 
             RowBox[{"i", ",", "0"}], "]"}], "]"}], "=", "List"}], ";", 
          "\[IndentingNewLine]", 
          RowBox[{"L", "=", 
           RowBox[{"Flatten", "[", "L", "]"}]}]}]}], "\[IndentingNewLine]", 
        "]"}]}], "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
     RowBox[{"DeleteDuplicates", "[", "L", "]"}]}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[110]:=",ExpressionUUID->"2ea470f6-13ae-4643-8025-c38bce85f7f3"],

Cell[TextData[{
 "The use of ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " requires explanation. The purpose of ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " is to encapsulate the variables used within a function so that they do not \
change the values of variables used outside of the function. For example, if \
you set ",
 StyleBox["L", "Code"],
 " equal to some value before executing ",
 StyleBox["getVars", "Code"],
 ", it will still have that value afterward. Likewise, ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " prevents values set outside the function from impacting the behavior of \
the function. In the jargon of programming languages, ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " ensures that the specified variables are treated as local to the module, \
or that they have a local scope, as distinguished from global."
}], "Text",ExpressionUUID->"c825b27d-a50f-4278-9b26-620ac28632ca"],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " function takes two arguments. The first is the list of variables to be \
held local. Within the list of variables, either you can provide just the \
name of the variable or, if you wish, you can assign the initial value of the \
variable, as was done in ",
 StyleBox["getVars", "Code"],
 ". The expression ",
 Cell[BoxData[
  RowBox[{"{", "L", "=", 
   RowBox[{"{", "p", "}"}], ",", "i", "=", "1", "}"}]], "myCode",
  ExpressionUUID->"cc876817-0789-46e2-af2f-69f7555b5950"],
 " as the first argument to ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " means that the symbols ",
 StyleBox["L", "Code"],
 " and ",
 StyleBox["i", "Code"],
 " are local and that they are initially assigned values ",
 StyleBox["{p}", "Code"],
 " and ",
 StyleBox["1", "Code"],
 ", respectively. "
}], "Text",ExpressionUUID->"a86eb70f-d205-41d2-bf70-ce9688d8bd73"],

Cell[TextData[{
 "The second argument to ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " is the body of the function definition. Note that semicolons are used to \
separate functions when there is more than one within the body. For example, \
in the third to last line of ",
 StyleBox["getVars", "Code"],
 ", the semicolon separates the conclusion of the ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop from the application of ",
 StyleBox["DeleteDuplicates", "Code"],
 "."
}], "Text",ExpressionUUID->"5e50ba9a-14e9-4aae-8149-f162c99fac62"],

Cell[TextData[{
 "Finally, observe that the function ",
 StyleBox["getVars", "Code"],
 " works as expected."
}], "Text",ExpressionUUID->"4e65ece0-d83e-492f-a8b1-3cff74095e50"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"getVars", "[", "variableEx", "]"}]], "Input",
 CellLabel->
  "In[111]:=",ExpressionUUID->"44115001-d8c0-4356-96ac-246fdff861ee"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}]], "Output",
 CellLabel->
  "Out[111]=",ExpressionUUID->"158bdcdc-bd71-46ca-a01e-d24e57071254"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"getVars", "[", 
  RowBox[{"Implies", "[", 
   RowBox[{
    RowBox[{"!", "w"}], ",", 
    RowBox[{"Equivalent", "[", 
     RowBox[{
      RowBox[{"Q", "||", "q"}], ",", 
      RowBox[{"P", "&&", "p"}]}], "]"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[112]:=",ExpressionUUID->"e054a56d-18a2-4b67-8591-505562370abc"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"w", ",", "P", ",", "p", ",", "Q", ",", "q"}], "}"}]], "Output",
 CellLabel->
  "Out[112]=",ExpressionUUID->"9571ea5a-9868-4c6d-ad12-a970519d4f37"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Truth Value Assignments", "Subsubsection",ExpressionUUID->"9e1a4a2b-5703-4a5a-95a2-55bd11435859"],

Cell["\<\
The second hurdle that we mentioned at the beginning of this section is that \
we do not know the number of propositional variables in advance. If we knew \
there would always be two variables, we would use two nested for loops. \
However, since we want our procedure to work with any number of variables, we \
need a different approach.\
\>", "Text",ExpressionUUID->"ce5a3476-de32-4c37-b7e9-e39af87044bd"],

Cell[TextData[{
 "Since our ",
 StyleBox["getVars", "Code"],
 " function produces a list of variables, it is natural to model an \
assignment of truth values to variables as a list of truth values. For \
example,"
}], "Text",ExpressionUUID->"badef55c-a252-49e0-ac4e-df48a55749b9"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableExVars", "=", 
  RowBox[{"getVars", "[", "variableEx", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[113]:=",ExpressionUUID->"35ad0a21-68d9-4445-b0d4-de5b161936f6"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"p", ",", "q", ",", "r", ",", "s"}], "}"}]], "Output",
 CellLabel->
  "Out[113]=",ExpressionUUID->"d87b241a-400c-4104-bfbe-5c81713574cc"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"truthValEx", "=", 
  RowBox[{"{", 
   RowBox[{"True", ",", "True", ",", "False", ",", "True"}], "}"}]}]], "Input",\

 InitializationCell->True,
 CellLabel->
  "In[114]:=",ExpressionUUID->"f79840f8-0775-43c4-b738-d1a2102089aa"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "True", ",", "False", ",", "True"}], "}"}]], "Output",
 CellLabel->
  "Out[114]=",ExpressionUUID->"8a54bac5-271e-41b8-86c2-41b72d1eb943"]
}, Open  ]],

Cell[TextData[{
 "We consider the ",
 StyleBox["truthValEx", "Code"],
 " (for truth values example) to indicate that we assign the first variable \
of ",
 StyleBox["variableExVars", "Code"],
 " to the value true, the second variable to true, the third variable to \
false, and the fourth variable to true."
}], "Text",ExpressionUUID->"5101f1ec-b298-4cca-bb14-cff27eb708f5"],

Cell[CellGroupData[{

Cell["Evaluating an Expression ", "Subsubsubsection",ExpressionUUID->"fc55c09b-367a-4462-ab67-694918c9c2b7"],

Cell[TextData[{
 "Recall the use of the ",
 StyleBox[ButtonBox["ReplaceAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ReplaceAll"], "FunctionLink"],
 " operator (",
 StyleBox["/.", "Code"],
 ") to evaluate an expression. In particular, this operator requires that the \
second operand is a list of rules of the form ",
 Cell[BoxData[
  FormBox[
   RowBox[{"s", "\[Rule]", "v"}], TraditionalForm]],ExpressionUUID->
  "18189cb6-fa3f-42a6-9f59-ae5cd4206451"],
 " with ",
 Cell[BoxData[
  FormBox["s", TraditionalForm]],ExpressionUUID->
  "c8cf63f8-384e-4899-b4f9-a6ed5f960bae"],
 " a symbol and ",
 Cell[BoxData[
  FormBox["v", TraditionalForm]],ExpressionUUID->
  "4bc46d70-0341-4bb1-be77-3e21f0621178"],
 " a value. For example, the following evaluates ",
 StyleBox["variableEx", "Code"],
 " at the values ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "=", "true"}], TraditionalForm]],ExpressionUUID->
  "d8113218-f523-4820-9b99-597bdd704c68"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{"q", "=", "true"}], TraditionalForm]],ExpressionUUID->
  "3eb45849-da26-475d-b76a-eb12f8f75eef"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{"r", "=", "false"}], TraditionalForm]],ExpressionUUID->
  "e98e322e-c77a-4865-bf76-06a7b6485fdc"],
 ", and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"s", "=", "true"}], TraditionalForm]],ExpressionUUID->
  "9685c505-48c4-47c9-b63d-4a2eb96644e3"],
 "."
}], "Text",ExpressionUUID->"7b17f846-ffaf-41b4-a9d7-5f3e3477c7dd"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableEx", "/.", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"p", "\[Rule]", "True"}], ",", 
    RowBox[{"q", "\[Rule]", "True"}], ",", 
    RowBox[{"r", "\[Rule]", "False"}], ",", 
    RowBox[{"s", "\[Rule]", "True"}]}], "}"}]}]], "Input",
 CellLabel->
  "In[115]:=",ExpressionUUID->"23455d46-0565-47f1-bad9-46eaa0d0df21"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[115]=",ExpressionUUID->"66bda1d2-0b9b-4a7c-b4da-b03a1f2b367b"]
}, Open  ]],

Cell[TextData[{
 "In order to perform that evaluation programmatically, using the result of \
",
 StyleBox["getVars", "Code"],
 " and a list representing an assignment of truth values, we need to turn the \
pair of lists into a list of rules. We will demonstrate how to do this with \
the ",
 StyleBox["variableExVars", "Code"],
 " and ",
 StyleBox["truthValEx", "Code"],
 " lists defined above."
}], "Text",ExpressionUUID->"083dfe74-dae1-4335-8607-100ebc94b5f2"],

Cell[TextData[{
 "We introduced the ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " function at the end of Section 1.1 of this manual. Recall that the basic \
purpose of ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " is to take a function of ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "93dbd6c9-91c0-4132-a05e-2cedb2dd9dd4"],
 " variables together with a list of ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "c86debb6-b8d8-407d-9324-c97e8197bbf1"],
 " lists (with the sublists having the same size) and apply the function to \
corresponding elements of the lists. For example, we can use ",
 StyleBox[ButtonBox["MapThread",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MapThread"], "FunctionLink"],
 " to add corresponding elements of two lists using the ",
 StyleBox[ButtonBox["Plus",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Plus"], "FunctionLink"],
 " function. (Note that this is generally unnecessary since addition \
automatically threads",
 StyleBox[",",
  FontSlant->"Italic"],
 " but it serves as an example.)"
}], "Text",ExpressionUUID->"bb942c0e-4e1f-4f63-984f-089565066b12"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"MapThread", "[", 
  RowBox[{"Plus", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"{", 
      RowBox[{"1", ",", "2", ",", "3"}], "}"}], ",", 
     RowBox[{"{", 
      RowBox[{"a", ",", "b", ",", "c"}], "}"}]}], "}"}]}], "]"}]], "Input",
 CellLabel->
  "In[116]:=",ExpressionUUID->"c3dafc4e-c25d-456b-9efd-27b7cccbc99b"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"1", "+", "a"}], ",", 
   RowBox[{"2", "+", "b"}], ",", 
   RowBox[{"3", "+", "c"}]}], "}"}]], "Output",
 CellLabel->
  "Out[116]=",ExpressionUUID->"1130a896-68bb-4070-be0b-54724a4dfba8"]
}, Open  ]],

Cell[TextData[{
 "In our context, the two lists are the lists of variables, ",
 StyleBox["variableExVars", "Code"],
 ", and the truth value assignment, ",
 StyleBox["truthValEx", "Code"],
 ". ",
 "The function that forms a rule is ",
 StyleBox[ButtonBox["Rule",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Rule"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"e2709b16-e66b-4a09-b27d-6bb25b3341b5"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"MapThread", "[", 
  RowBox[{"Rule", ",", 
   RowBox[{"{", 
    RowBox[{"variableExVars", ",", "truthValEx"}], "}"}]}], "]"}]], "Input",
 CellLabel->
  "In[117]:=",ExpressionUUID->"e1ad949b-aa01-4bb1-9e8d-37f270e300a2"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"p", "\[Rule]", "True"}], ",", 
   RowBox[{"q", "\[Rule]", "True"}], ",", 
   RowBox[{"r", "\[Rule]", "False"}], ",", 
   RowBox[{"s", "\[Rule]", "True"}]}], "}"}]], "Output",
 CellLabel->
  "Out[117]=",ExpressionUUID->"a51bc274-d022-430e-b420-82e12d537658"]
}, Open  ]],

Cell["We can thus evaluate the expression with the following.", "Text",ExpressionUUID->"94767f99-ab6b-4b2f-a033-40aa31cadc58"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"variableEx", "/.", 
  RowBox[{"MapThread", "[", 
   RowBox[{"Rule", ",", 
    RowBox[{"{", 
     RowBox[{"variableExVars", ",", "truthValEx"}], "}"}]}], "]"}]}]], "Input",\

 CellLabel->
  "In[118]:=",ExpressionUUID->"a50ec113-2d30-41f8-a8c6-17149fb2c7c6"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[118]=",ExpressionUUID->"6750ae62-b5c3-4eee-9a24-ced7bac8cc33"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Finding All Possible Truth Assignments", "Subsubsubsection",ExpressionUUID->"679898b5-6a97-49c3-bddd-a59099117499"],

Cell["\<\
Now that we know that we can effectively use lists of truth values to \
represent truth value assignments, we need a way to produce all such lists. \
We will use a strategy similar to binary counting. Start with the list all of \
whose elements are the symbol false. Get the next list by changing the first \
element to true. For the next assignment, change the first element back to \
false and the second element to true. Then, change the first element to true. \
Then, change the first true to false, the second true to false, and the third \
element becomes true. Continue in this pattern: given a list of truth values, \
obtain the next list by changing the left-most false to true and changing all \
trues up until that first false into false. (It is left to the reader to \
verify that this produces all possible truth value assignments.)\
\>", "Text",ExpressionUUID->"928fd145-cf55-46f2-ae21-c89e6e14ba7b"],

Cell[TextData[{
 "We implement this idea in the ",
 StyleBox["nextTA", "Code"],
 " function (for next truth assignment). The ",
 StyleBox["nextTA", "Code"],
 " function will accept a list of truth values as input and return the \
\[OpenCurlyDoubleQuote]next\[CloseCurlyDoubleQuote] list. The main work of \
this procedure is done inside of a ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " loop. The loop considers each position in the list of truth values in \
turn. If the value in the current position is true, then it is changed to \
false. On the other hand, if the value is false, then it is changed to true \
and the function is terminated by returning the list of truth values. If the ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " loop ends without having returned a new list, then the input to the \
procedure was the list all of whose elements were the symbol true, which is \
the last possible truth assignment, and the function returns ",
 StyleBox[ButtonBox["Null",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Null"], "FunctionLink"],
 " to indicate that there is no next truth assignment."
}], "Text",ExpressionUUID->"0fc627f3-e4cf-46ac-a091-5b8f0ae1be78"],

Cell[BoxData[
 RowBox[{
  RowBox[{"nextTA", "[", "A_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"i", ",", 
      RowBox[{"newTA", "=", "A"}]}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"For", "[", 
       RowBox[{
        RowBox[{"i", "=", "1"}], ",", 
        RowBox[{"i", "<=", 
         RowBox[{"Length", "[", "A", "]"}]}], ",", 
        RowBox[{"i", "++"}], ",", "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{"newTA", "[", 
           RowBox[{"[", "i", "]"}], "]"}], ",", "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"newTA", "[", 
            RowBox[{"[", "i", "]"}], "]"}], "=", "False"}], ",", 
          "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{
            RowBox[{"newTA", "[", 
             RowBox[{"[", "i", "]"}], "]"}], "=", "True"}], ";", 
           RowBox[{"Throw", "[", "newTA", "]"}]}]}], "\[IndentingNewLine]", 
         "]"}]}], "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"Throw", "[", "Null", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[119]:=",ExpressionUUID->"0fbb5a2d-dc4c-43fc-8b5a-684ed39e3e86"],

Cell[TextData[{
 "Once again, we use a ",
 StyleBox[ButtonBox["Module",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Module"], "FunctionLink"],
 " structure. This ensures that ",
 StyleBox["i", "Code"],
 ", the loop variable, and ",
 StyleBox["newTA", "Code"],
 ", the truth assignment that is being constructed, are private to the \
function. Note that ",
 StyleBox["newTA", "Code"],
 " is initialized to be a copy of ",
 StyleBox["A", "Code"],
 ", the input list.",
 " ",
 "We will describe ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 " momentarily."
}], "Text",ExpressionUUID->"b783806f-62b1-4283-b522-86eb5fe73f80"],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " function is the Wolfram Language\[CloseCurlyQuote]s implementation of a \
for loop. The first argument contains the initialization command, in this \
case setting the loop variable ",
 StyleBox["i", "Code"],
 " equal to 1. The second argument defines the test that specifies the \
termination conditions of the loop. In ",
 StyleBox["nextTA", "Code"],
 ", the loop is to run through all of the entries in the list representing \
the truth assignment, so the test is that the value of the index ",
 StyleBox["i", "Code"],
 " has not exceeded the number of entries in the list, determined by the ",
 StyleBox[ButtonBox["Length",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Length"], "FunctionLink"],
 " function. The third argument to ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " is the increment specification. In this case, we used the ",
 StyleBox[ButtonBox["Increment",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Increment"], "FunctionLink"],
 " (",
 StyleBox["++", "Code"],
 ")",
 StyleBox[" ", "Code"],
 "operator, which increases the value of ",
 StyleBox["i", "Code"],
 " by 1. It has the same effect as ",
 Cell[BoxData[
  RowBox[{"i", "=", "i", "+", "1"}]], "myCode",ExpressionUUID->
  "f1804f5f-ba70-4eee-a897-12771c60dba2"],
 ". "
}], "Text",ExpressionUUID->"ae9f0b87-79a3-4e76-9025-6bae648620e2"],

Cell[TextData[{
 "The final argument to ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " is the body of the loop. The basic strategy is to work our way through the \
\[OpenCurlyDoubleQuote]old\[CloseCurlyDoubleQuote] truth value assignment \
turning true into false until we hit a false. That first false is changed to \
true and we stop. The body of our for loop is dominated by an ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " statement. The first argument of the ",
 StyleBox[ButtonBox["If",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/If"], "FunctionLink"],
 " statement accesses the value in the current position of ",
 StyleBox["newTA", "Code"],
 ". In case that value is true, according to our strategy, we change it to \
false and move on to the next element in the list. If the current value is \
false, we change it to true. "
}], "Text",ExpressionUUID->"f95fa800-7040-4f64-8002-38861780310b"],

Cell[TextData[{
 "Once a false has been changed to true, we want to stop the evaluation of \
the function and have the current value of ",
 StyleBox["newTA", "Code"],
 " returned as the output of the function. This is the purpose of ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 ". The ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 " function is a way for you to tell ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", \[OpenCurlyDoubleQuote]This (the argument) is the result of this section \
of code.\[CloseCurlyDoubleQuote] ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 " defines the scope of the ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 ", that is, the argument of the ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 " is the block of code to which ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 " refers. In other words, when ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " encounters a ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 ", it evaluates its argument and considers that result to be the result of \
the entire ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 " block. In this case, when the loop encounters a false entry in ",
 StyleBox["newTA", "Code"],
 ", it changes that entry to true and then executes the ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 ", which has the effect of ending any further evaluation and declaring the \
result to be the current value of ",
 StyleBox["newTA", "Code"],
 ".",
 " ",
 "Should all of the entries be true initially, then the ",
 Cell[BoxData[
  RowBox[{"Throw", "[", "newTA", "]"}]], "myCode",ExpressionUUID->
  "20cd24ca-ed41-411b-80e1-5246941a92b1"],
 " will never be encountered and the loop will be allowed to complete. Once \
the loop is complete, the ",
 Cell[BoxData[
  RowBox[{"Throw", "[", "Null", "]"}]], "myCode",ExpressionUUID->
  "14365038-8291-40a5-a197-5e4c25f4d844"],
 " statement will be encountered, causing the ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 ", and thus the module, to return ",
 StyleBox[ButtonBox["Null",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Null"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"9b0900d9-d64a-44c5-bf86-79b7178a81e0"],

Cell[TextData[{
 "You may be wondering why we did not use a ",
 StyleBox[ButtonBox["Return",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Return"], "FunctionLink"],
 " statement in the above. While the Wolfram Language does have a ",
 StyleBox[ButtonBox["Return",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Return"], "FunctionLink"],
 " function, the Wolfram Language has a functional style, as opposed to \
procedural. Because of this, the behavior of ",
 StyleBox[ButtonBox["Return",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Return"], "FunctionLink"],
 " can be unexpected. In fact, it is impossible for ",
 StyleBox[ButtonBox["Return",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Return"], "FunctionLink"],
 " to have the same behavior in a functional language such as the Wolfram \
Language as it would in a procedural language like C. More than this, ",
 StyleBox[ButtonBox["Return",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Return"], "FunctionLink"],
 " in the Wolfram Language is a bit of a square peg in a round hole situation\
\[LongDash]it does not fit with the conceptual framework of a functional \
language."
}], "Text",ExpressionUUID->"5f137c2f-e206-435f-83f4-aa0cf08bd103"],

Cell[TextData[{
 "We can confirm, in the case of three variables, that ",
 StyleBox["nextTA", "Code"],
 " does in fact produce all of the possible truth value assignments using the \
following simple ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop. Note that the ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " function executes the second argument so long as the first argument is \
true. Also note the use of ",
 StyleBox["=!=", "Code"],
 " in the test. This is the ",
 StyleBox[ButtonBox["UnsameQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/UnsameQ"], "FunctionLink"],
 " (",
 StyleBox["=!=", "Code"],
 ") relation, which is the negation of ",
 StyleBox[ButtonBox["SameQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SameQ"], "FunctionLink"],
 " (",
 StyleBox["===", "Code"],
 "), which was discussed earlier."
}], "Text",ExpressionUUID->"f6fe86db-584d-4c8e-b4ef-b1493c61d64a"],

Cell[CellGroupData[{

Cell[BoxData[{
 RowBox[{
  RowBox[{"nextTAdemo", "=", 
   RowBox[{"{", 
    RowBox[{"False", ",", "False", ",", "False"}], "}"}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{"While", "[", 
  RowBox[{
   RowBox[{"nextTAdemo", "=!=", "Null"}], ",", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"Print", "[", "nextTAdemo", "]"}], ";", "\[IndentingNewLine]", 
    RowBox[{"nextTAdemo", "=", 
     RowBox[{"nextTA", "[", "nextTAdemo", "]"}]}]}]}], "\[IndentingNewLine]", 
  "]"}]}], "Input",
 CellLabel->
  "In[120]:=",ExpressionUUID->"93572eda-4778-4835-8971-171851e0a0ab"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "False", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"227b85b6-d0c4-4b58-8b37-0e649b58aed0"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "False", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"9e20801f-b026-4df6-9bbb-3871bf614df7"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "True", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"8064f83c-c4c5-469d-a57c-39d483862a56"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "True", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"d389b949-2a0d-4a34-b37f-8de268d89633"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "False", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"9d030824-ec5a-45cd-81df-f3b8937d8621"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "False", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"bdde56ea-a378-4b37-b064-7688a9b92071"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "True", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"e776aeab-0322-4c55-8b0d-e1fa6a70e9a2"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "True", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[120]:=",ExpressionUUID->"687da84f-8636-4627-bf71-3cc8d8d542ea"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Logical Equivalence Implementation", "Subsubsection",ExpressionUUID->"161f7fa9-700b-450d-943a-2f6a224bea2c"],

Cell[TextData[{
 "We now have the necessary pieces in place to write the promised ",
 StyleBox["myEquivalentQ", "Code"],
 " function",
 ". ",
 "This function accepts two propositions as arguments and returns true if \
they are equivalent and false otherwise."
}], "Text",ExpressionUUID->"ffb71287-8a08-4147-bece-d6ef27785827"],

Cell["The function proceeds as follows:", "Text",ExpressionUUID->"1e62e130-31af-4947-a8fb-5e28260ddd54"],

Cell[CellGroupData[{

Cell[TextData[{
 "First, we create the biconditional, which we name ",
 StyleBox["bicond", "Input",
  IgnoreSpellCheck->True],
 ", that asserts the equivalence of the two propositions. We use the ",
 StyleBox["getVars", "Code"],
 " function to determine the list of variables used in the propositions and \
we initialize the truth assignment variable ",
 StyleBox["TA", "Code"],
 " to the appropriately sized list of all false values using the ",
 StyleBox[ButtonBox["ConstantArray",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ConstantArray"], "FunctionLink"],
 " function applied to the value ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 " and the desired length of the list."
}], "Item1Numbered",ExpressionUUID->"2aa43262-b75a-447a-915e-ee43e55be074"],

Cell[TextData[{
 "Then, we begin a ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop. As long as ",
 StyleBox["TA", "Code"],
 " is not ",
 StyleBox[ButtonBox["Null",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Null"], "FunctionLink"],
 ", we evaluate the biconditional ",
 StyleBox["bicond", "Input",
  IgnoreSpellCheck->True],
 " on the truth assignment. If this truth value is false, we know that the \
biconditional is not a tautology and thus the propositions are not equivalent \
and we immediately throw ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 ". Otherwise, we use ",
 StyleBox["nextTA", "Code"],
 " to update ",
 StyleBox["TA", "Code"],
 " to the next truth assignment."
}], "Item1Numbered",ExpressionUUID->"68da14e6-0fff-469d-bdca-a07e6df07db0"],

Cell[TextData[{
 "If the ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop terminates, that indicates that all possible truth assignments have \
been applied to the biconditional and that each one evaluated true, otherwise \
the procedure would have returned ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 " and terminated. Thus, the biconditional is a tautology and ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 " is returned."
}], "Item1Numbered",ExpressionUUID->"e7120b9b-d409-44e2-8f20-a29c697b49a9"]
}, Open  ]],

Cell[BoxData[
 RowBox[{
  RowBox[{"myEquivalentQ", "[", 
   RowBox[{"p_", ",", "q_"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"bicond", ",", "vars", ",", "numVars", ",", "TA", ",", "val"}], 
     "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"bicond", "=", 
      RowBox[{"Equivalent", "[", 
       RowBox[{"p", ",", "q"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"vars", "=", 
      RowBox[{"getVars", "[", "bicond", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"numVars", "=", 
      RowBox[{"Length", "[", "vars", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"TA", "=", 
      RowBox[{"ConstantArray", "[", 
       RowBox[{"False", ",", "numVars"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Catch", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"While", "[", 
        RowBox[{
         RowBox[{"TA", "=!=", "Null"}], ",", "\[IndentingNewLine]", 
         RowBox[{
          RowBox[{"val", "=", 
           RowBox[{"bicond", "/.", 
            RowBox[{"MapThread", "[", 
             RowBox[{"Rule", ",", 
              RowBox[{"{", 
               RowBox[{"vars", ",", "TA"}], "}"}]}], "]"}]}]}], ";", 
          "\[IndentingNewLine]", 
          RowBox[{"If", "[", 
           RowBox[{
            RowBox[{"!", "val"}], ",", 
            RowBox[{"Throw", "[", "False", "]"}]}], "]"}], ";", 
          "\[IndentingNewLine]", 
          RowBox[{"TA", "=", 
           RowBox[{"nextTA", "[", "TA", "]"}]}]}]}], "\[IndentingNewLine]", 
        "]"}], ";", "\[IndentingNewLine]", 
       RowBox[{"Throw", "[", "True", "]"}]}], "\[IndentingNewLine]", 
      "]"}]}]}], "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[122]:=",ExpressionUUID->"8e85afbb-95ad-4d00-a6c4-f2baea508919"],

Cell[TextData[{
 "We can use our function to computationally verify that ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"\[Not]", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{"p", "\[Or]", 
        RowBox[{"(", 
         RowBox[{
          RowBox[{"\[Not]", "p"}], "\[And]", "q"}], ")"}]}], ")"}], 
      "\[Congruent]", 
      RowBox[{"\[Not]", "p"}]}]}], "\[And]", 
    RowBox[{"\[Not]", "q"}]}], TraditionalForm]],ExpressionUUID->
  "5d461626-faa9-4d8b-9654-18613ea54d93"],
 ". ",
 "This was shown in Example 7 of Section 1.3 of the text via equivalences."
}], "Text",ExpressionUUID->"590c705a-ad4f-47da-8438-a62801eb5ab8"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"myEquivalentQ", "[", 
  RowBox[{
   RowBox[{"!", 
    RowBox[{"(", 
     RowBox[{"p", "||", 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"!", "p"}], "&&", "q"}], ")"}]}], ")"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "&&", 
    RowBox[{"!", "q"}]}]}], "]"}]], "Input",
 CellLabel->
  "In[123]:=",ExpressionUUID->"3e1257a4-36c8-44e7-9683-be0addd70a28"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[123]=",ExpressionUUID->"86a7e7a7-b4e5-4658-9d24-947631796a13"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell[TextData[{
 "The ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "a3f4bd42-acac-43db-8b1f-b59c6b09a3c8"],
 "-Queens Problem"
}], "Subsection",
 CellTags->"Section3c",ExpressionUUID->"53c75699-a838-4dd1-ba94-9aed834605a6"],

Cell[TextData[{
 "The textbook describes the ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "a2192fad-04b0-4f45-a689-b69d5b65c579"],
 "-Queens problem and shows how propositions can be formed to solve it via \
propositional satisfiability. With the Wolfram Language\[CloseCurlyQuote]s ",
 StyleBox[ButtonBox["SatisfiableQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiableQ"], "FunctionLink"],
 " function, the main challenge is building the propositions. This will give \
us an opportunity to see how we can write functions that, instead of \
computing a value, actually create objects that can be used in other \
functions. In particular, we will define functions ",
 StyleBox["nQueens1", "Code"],
 " through ",
 StyleBox["nQueens5", "Code"],
 " whose outputs are the propositions ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["Q", "1"], TraditionalForm]],ExpressionUUID->
  "8f0ed4b8-18b8-44be-ae3a-b2cf930e1656"],
 " through ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["Q", "5"], TraditionalForm]],ExpressionUUID->
  "f3e87c8c-b53f-4f91-9977-8f1623a648d6"],
 ", as defined in the main text."
}], "Text",ExpressionUUID->"089511e4-4183-4d25-ae0a-ed8a2eb60f18"],

Cell[TextData[{
 "First, we will need to form the basic propositions, those the main text \
refers to as ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "(", 
    RowBox[{"i", ",", "j"}], ")"}], TraditionalForm]],ExpressionUUID->
  "1417492c-a285-4adb-852b-b5a279a8cb8f"],
 ". It might be surprising, but the Wolfram Language will allow us to use \
expressions such as ",
 StyleBox["p[2,3]", "Code"],
 " as propositional variables. However, we need to be careful when using the \
built-in satisfiability functions to include the second argument, the list of \
propositional variables, so that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " understands we mean them to be propositional variables. "
}], "Text",ExpressionUUID->"6349eb35-5181-40f2-bd6a-57a5be2a984d"],

Cell[TextData[{
 "We can use ",
 StyleBox[ButtonBox["Table",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Table"], "FunctionLink"],
 " to create the list of all the needed propositions."
}], "Text",ExpressionUUID->"5f43e0ae-e3f1-44c0-ba1a-e3def6f7d1d0"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Table", "[", 
  RowBox[{
   RowBox[{"p", "[", 
    RowBox[{"i", ",", "j"}], "]"}], ",", 
   RowBox[{"{", 
    RowBox[{"i", ",", "1", ",", "4"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"j", ",", "1", ",", "4"}], "}"}]}], "]"}]], "Input",
 CellLabel->
  "In[124]:=",ExpressionUUID->"a1a24401-7c63-418a-87c0-7e2479e27034"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"p", "[", 
      RowBox[{"1", ",", "1"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"1", ",", "2"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"1", ",", "3"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"1", ",", "4"}], "]"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"p", "[", 
      RowBox[{"2", ",", "1"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"2", ",", "2"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"2", ",", "3"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"2", ",", "4"}], "]"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"p", "[", 
      RowBox[{"3", ",", "1"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"3", ",", "2"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"3", ",", "3"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"3", ",", "4"}], "]"}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"p", "[", 
      RowBox[{"4", ",", "1"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"4", ",", "2"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"4", ",", "3"}], "]"}], ",", 
     RowBox[{"p", "[", 
      RowBox[{"4", ",", "4"}], "]"}]}], "}"}]}], "}"}]], "Output",
 CellLabel->
  "Out[124]=",ExpressionUUID->"1f2f8385-f12f-4907-8493-aa4a743adf2c"]
}, Open  ]],

Cell[TextData[{
 "Since that produces a nested list, we will apply ",
 StyleBox[ButtonBox["Flatten",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Flatten"], "FunctionLink"],
 " to obtain the list of propositional variables. "
}], "Text",ExpressionUUID->"c0590f50-f258-48e8-8d26-6e92c4d54dfb"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Flatten", "[", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"i", ",", "j"}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", "1", ",", "4"}], "}"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "4"}], "}"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[125]:=",ExpressionUUID->"c94bea44-7abe-4352-ae72-1511f6c96846"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"p", "[", 
    RowBox[{"1", ",", "1"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"1", ",", "2"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"1", ",", "3"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"1", ",", "4"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"2", ",", "1"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"2", ",", "2"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"2", ",", "3"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"2", ",", "4"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"3", ",", "1"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"3", ",", "2"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"3", ",", "3"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"3", ",", "4"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"4", ",", "1"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"4", ",", "2"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"4", ",", "3"}], "]"}], ",", 
   RowBox[{"p", "[", 
    RowBox[{"4", ",", "4"}], "]"}]}], "}"}]], "Output",
 CellLabel->
  "Out[125]=",ExpressionUUID->"46aee8d0-3216-4b01-bf89-1a7a25a8122e"]
}, Open  ]],

Cell[TextData[{
 "Now we will form the proposition ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["Q", "1"], "=", 
    RowBox[{
     UnderoverscriptBox["\[And]", 
      RowBox[{"i", "=", "1"}], "n"], 
     RowBox[{
      UnderoverscriptBox["\[Or]", 
       RowBox[{"j", "=", "1"}], "n"], 
      RowBox[{"p", "(", 
       RowBox[{"i", ",", "j"}], ")"}]}]}]}], TraditionalForm]],
  ExpressionUUID->"65ad9496-aa71-4513-aa45-777cf6cef1fa"],
 ". Initially, consider just the inner disjunction, ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    UnderoverscriptBox["\[Or]", 
     RowBox[{"j", "=", "1"}], "n"], 
    RowBox[{"p", "(", 
     RowBox[{"i", ",", "j"}], ")"}]}], TraditionalForm]],ExpressionUUID->
  "0987aba6-6a64-47aa-be9a-9c36bd3d7078"],
 ". We can produce this disjunction by using ",
 StyleBox[ButtonBox["Table",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Table"], "FunctionLink"],
 " to create a list of the propositions and then transforming the list into a \
disjunction using the ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " (",
 StyleBox["@@", "Code"],
 ") operator. Recall that ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " replaces the head of an expression and thus can change one kind of \
expression into another. For example, for ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "=", "7"}], TraditionalForm]],ExpressionUUID->
  "b995f31b-9a5e-42e1-bf1f-a5f2e13dd224"],
 ", the inner disjunction is formed as shown below."
}], "Text",ExpressionUUID->"bea6d659-1289-4363-9cea-8630c8b2dadf"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Or", "@@", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"i", ",", "j"}], "]"}], ",", 
    RowBox[{"{", 
     RowBox[{"j", ",", "1", ",", "7"}], "}"}]}], "]"}]}]], "Input",
 CellLabel->
  "In[126]:=",ExpressionUUID->"39d0ede0-3a1f-4f84-9ad1-f349fd9d2aee"],

Cell[BoxData[
 RowBox[{
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "1"}], "]"}], "||", 
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "2"}], "]"}], "||", 
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "3"}], "]"}], "||", 
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "4"}], "]"}], "||", 
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "5"}], "]"}], "||", 
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "6"}], "]"}], "||", 
  RowBox[{"p", "[", 
   RowBox[{"i", ",", "7"}], "]"}]}]], "Output",
 CellLabel->
  "Out[126]=",ExpressionUUID->"e60fc088-4425-4d56-ab7e-5990f41193fa"]
}, Open  ]],

Cell[TextData[{
 "To complete ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["Q", "1"], TraditionalForm]],ExpressionUUID->
  "fa0195ea-1686-4443-a210-c33143e432bd"],
 ", we simply make that the first argument of ",
 StyleBox[ButtonBox["Table",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Table"], "FunctionLink"],
 " and apply ",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"b509f69b-52b9-4260-a583-d3d082adf72f"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"And", "@@", 
  RowBox[{"Table", "[", "\[IndentingNewLine]", 
   RowBox[{
    RowBox[{"Or", "@@", 
     RowBox[{"Table", "[", 
      RowBox[{
       RowBox[{"p", "[", 
        RowBox[{"i", ",", "j"}], "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"j", ",", "1", ",", "7"}], "}"}]}], "]"}]}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{"{", 
     RowBox[{"i", ",", "1", ",", "7"}], "}"}]}], "]"}]}]], "Input",
 CellLabel->
  "In[127]:=",ExpressionUUID->"fefe3f2e-a4d3-4606-b3f7-d0831c42d79c"],

Cell[BoxData[
 RowBox[{
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"1", ",", "7"}], "]"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"2", ",", "7"}], "]"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"3", ",", "7"}], "]"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"4", ",", "7"}], "]"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"5", ",", "7"}], "]"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"6", ",", "7"}], "]"}]}], ")"}], "&&", 
  RowBox[{"(", 
   RowBox[{
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "1"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "2"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "3"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "4"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "5"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "6"}], "]"}], "||", 
    RowBox[{"p", "[", 
     RowBox[{"7", ",", "7"}], "]"}]}], ")"}]}]], "Output",
 CellLabel->
  "Out[127]=",ExpressionUUID->"df292302-00b9-499e-8baf-09e13e16417b"]
}, Open  ]],

Cell["\<\
We generalize this process into a function by replacing the specific value 7 \
with a variable.\
\>", "Text",ExpressionUUID->"0c428db2-4613-4aca-895a-3b0360cfe609"],

Cell[BoxData[
 RowBox[{
  RowBox[{"nQueens1", "[", "n_", "]"}], ":=", 
  RowBox[{"And", "@@", 
   RowBox[{"Table", "[", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Or", "@@", 
      RowBox[{"Table", "[", 
       RowBox[{
        RowBox[{"p", "[", 
         RowBox[{"i", ",", "j"}], "]"}], ",", 
        RowBox[{"{", 
         RowBox[{"j", ",", "1", ",", "n"}], "}"}]}], "]"}]}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", "n"}], "}"}]}], "]"}]}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[128]:=",ExpressionUUID->"13b35d7b-2450-4a70-947e-31f1b19ad99f"],

Cell[TextData[{
 "Other than needing the ",
 StyleBox[ButtonBox["Min",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Min"], "FunctionLink"],
 " function for ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["Q", "4"], TraditionalForm]],ExpressionUUID->
  "186a2c07-c698-46ab-8591-7d50f9f8435b"],
 " and ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["Q", "5"], TraditionalForm]],ExpressionUUID->
  "6f87632d-5689-4417-b290-0eb494ffe63c"],
 ", the other propositions can be formed similarly. The definitions of the \
propositions are displayed below, followed by the definitions of the \
functions."
}], "Text",ExpressionUUID->"ad0bee34-d159-42f9-8963-f8b3421b9fe4"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["Q", "2"], "=", 
   RowBox[{
    UnderoverscriptBox["\[And]", 
     RowBox[{"i", "=", "1"}], "n"], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"j", "=", "1"}], 
     RowBox[{"n", "-", "1"}]], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"k", "=", 
      RowBox[{"j", "+", "1"}]}], "n"], 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{"i", ",", "j"}], ")"}]}], "\[Or]", 
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{"i", ",", "k"}], ")"}]}]}], ")"}]}]}], 
  TraditionalForm]], "Equation",ExpressionUUID->"9566868b-5d57-4b3e-b748-\
8c87e82467f6"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["Q", "3"], "=", 
   RowBox[{
    UnderoverscriptBox["\[And]", 
     RowBox[{"j", "=", "1"}], "n"], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"i", "=", "1"}], 
     RowBox[{"n", "-", "1"}]], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"k", "=", 
      RowBox[{"i", "+", "1"}]}], "n"], 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{"i", ",", "j"}], ")"}]}], "\[Or]", 
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{"k", ",", "j"}], ")"}]}]}], ")"}]}]}], 
  TraditionalForm]], "Equation",ExpressionUUID->"9df1633e-cdf9-4211-b173-\
e65e72eb35f1"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["Q", "4"], "=", 
   RowBox[{
    UnderoverscriptBox["\[And]", 
     RowBox[{"i", "=", "2"}], "n"], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"j", "=", "1"}], 
     RowBox[{"n", "-", "1"}]], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"k", "=", "1"}], 
     RowBox[{"min", "(", 
      RowBox[{
       RowBox[{"i", "-", "1"}], ",", 
       RowBox[{"n", "-", "j"}]}], ")"}]], 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{"i", ",", "j"}], ")"}]}], "\[Or]", 
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{
         RowBox[{"i", "-", "k"}], ",", 
         RowBox[{"k", "+", "j"}]}], ")"}]}]}], ")"}]}]}], 
  TraditionalForm]], "Equation",ExpressionUUID->"ce646161-14ef-499e-8772-\
7ee7507bf7ca"],

Cell[BoxData[
 FormBox[
  RowBox[{
   SubscriptBox["Q", "5"], "=", 
   RowBox[{
    UnderoverscriptBox["\[And]", 
     RowBox[{"i", "=", "1"}], 
     RowBox[{"n", "-", "1"}]], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"j", "=", "1"}], 
     RowBox[{"n", "-", "1"}]], 
    UnderoverscriptBox["\[And]", 
     RowBox[{"k", "=", "1"}], 
     RowBox[{"min", "(", 
      RowBox[{
       RowBox[{"n", "-", "i"}], ",", 
       RowBox[{"n", "-", "j"}]}], ")"}]], 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{"i", ",", "j"}], ")"}]}], "\[Or]", 
      RowBox[{"\[Not]", 
       RowBox[{"p", "(", 
        RowBox[{
         RowBox[{"i", "+", "k"}], ",", 
         RowBox[{"j", "+", "k"}]}], ")"}]}]}], ")"}]}]}], 
  TraditionalForm]], "Equation",ExpressionUUID->"2853657b-6d84-492c-90e7-\
b59b33bc0e0e"],

Cell[BoxData[{
 RowBox[{
  RowBox[{
   RowBox[{"nQueens2", "[", "n_", "]"}], ":=", 
   RowBox[{"And", "@@", 
    RowBox[{"Table", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"And", "@@", 
       RowBox[{"Table", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"And", "@@", 
          RowBox[{"Table", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"!", 
              RowBox[{"p", "[", 
               RowBox[{"i", ",", "j"}], "]"}]}], "||", 
             RowBox[{"!", 
              RowBox[{"p", "[", 
               RowBox[{"i", ",", "k"}], "]"}]}]}], ",", 
            RowBox[{"{", 
             RowBox[{"k", ",", 
              RowBox[{"j", "+", "1"}], ",", "n"}], "}"}]}], "]"}]}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"{", 
          RowBox[{"j", ",", "1", ",", 
           RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}], ",", 
      "\[IndentingNewLine]", 
      RowBox[{"{", 
       RowBox[{"i", ",", "1", ",", "n"}], "}"}]}], "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"nQueens3", "[", "n_", "]"}], ":=", 
   RowBox[{"And", "@@", 
    RowBox[{"Table", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"And", "@@", 
       RowBox[{"Table", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"And", "@@", 
          RowBox[{"Table", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"!", 
              RowBox[{"p", "[", 
               RowBox[{"i", ",", "j"}], "]"}]}], "||", 
             RowBox[{"!", 
              RowBox[{"p", "[", 
               RowBox[{"k", ",", "j"}], "]"}]}]}], ",", 
            RowBox[{"{", 
             RowBox[{"k", ",", 
              RowBox[{"i", "+", "1"}], ",", "n"}], "}"}]}], "]"}]}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"{", 
          RowBox[{"i", ",", "1", ",", 
           RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}], ",", 
      "\[IndentingNewLine]", 
      RowBox[{"{", 
       RowBox[{"j", ",", "1", ",", "n"}], "}"}]}], "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{
   RowBox[{"nQueens4", "[", "n_", "]"}], ":=", 
   RowBox[{"And", "@@", 
    RowBox[{"Table", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"And", "@@", 
       RowBox[{"Table", "[", "\[IndentingNewLine]", 
        RowBox[{
         RowBox[{"And", "@@", 
          RowBox[{"Table", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"!", 
              RowBox[{"p", "[", 
               RowBox[{"i", ",", "j"}], "]"}]}], "||", 
             RowBox[{"!", 
              RowBox[{"p", "[", 
               RowBox[{
                RowBox[{"i", "-", "k"}], ",", 
                RowBox[{"k", "+", "j"}]}], "]"}]}]}], ",", 
            RowBox[{"{", 
             RowBox[{"k", ",", "1", ",", 
              RowBox[{"Min", "[", 
               RowBox[{
                RowBox[{"i", "-", "1"}], ",", 
                RowBox[{"n", "-", "j"}]}], "]"}]}], "}"}]}], "]"}]}], ",", 
         "\[IndentingNewLine]", 
         RowBox[{"{", 
          RowBox[{"j", ",", "1", ",", 
           RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}], ",", 
      "\[IndentingNewLine]", 
      RowBox[{"{", 
       RowBox[{"i", ",", "2", ",", "n"}], "}"}]}], "]"}]}]}], 
  ";"}], "\[IndentingNewLine]", 
 RowBox[{
  RowBox[{"nQueens5", "[", "n_", "]"}], ":=", " ", 
  RowBox[{"And", "@@", 
   RowBox[{"Table", "[", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"And", "@@", 
      RowBox[{"Table", "[", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"And", "@@", 
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{
            RowBox[{"!", 
             RowBox[{"p", "[", 
              RowBox[{"i", ",", "j"}], "]"}]}], "||", 
            RowBox[{"!", 
             RowBox[{"p", "[", 
              RowBox[{
               RowBox[{"i", "+", "k"}], ",", 
               RowBox[{"j", "+", "k"}]}], "]"}]}]}], ",", 
           RowBox[{"{", 
            RowBox[{"k", ",", "1", ",", 
             RowBox[{"Min", "[", 
              RowBox[{
               RowBox[{"n", "-", "i"}], ",", 
               RowBox[{"n", "-", "j"}]}], "]"}]}], "}"}]}], "]"}]}], ",", 
        "\[IndentingNewLine]", 
        RowBox[{"{", 
         RowBox[{"j", ",", "1", ",", 
          RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}], ",", 
     "\[IndentingNewLine]", 
     RowBox[{"{", 
      RowBox[{"i", ",", "1", ",", 
       RowBox[{"n", "-", "1"}]}], "}"}]}], "]"}]}]}]}], "Input",
 InitializationCell->True,
 CellLabel->
  "In[129]:=",ExpressionUUID->"121fac05-c88f-4de2-9bee-58da1667db8e"],

Cell[TextData[{
 "Finally, we define a function that combines the propositions and produces a \
solution. Since ",
 StyleBox[ButtonBox["SatisfiabilityInstances",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiabilityInstances"], "FunctionLink"],
 " produces solutions as flat lists, we will use ",
 StyleBox[ButtonBox["Partition",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Partition"], "FunctionLink"],
 " to transform the output into a list of lists, with the inner lists \
representing the rows of the board. In its simplest form, ",
 StyleBox[ButtonBox["Partition",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Partition"], "FunctionLink"],
 " takes two arguments: a list and the desired length of the sublist. For \
example, the list of integers from 1 through 12 is broken into four sublists \
of length 3 below."
}], "Text",ExpressionUUID->"3f20d0fa-6cdf-414f-9473-888f98f09aff"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Partition", "[", 
  RowBox[{
   RowBox[{"Range", "[", "12", "]"}], ",", "3"}], "]"}]], "Input",
 CellLabel->
  "In[133]:=",ExpressionUUID->"91f6f630-56c0-4b1f-80ab-36a09d449a93"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"1", ",", "2", ",", "3"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"4", ",", "5", ",", "6"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"7", ",", "8", ",", "9"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"10", ",", "11", ",", "12"}], "}"}]}], "}"}]], "Output",
 CellLabel->
  "Out[133]=",ExpressionUUID->"9c816004-d8fc-4d85-a06c-391a212a0c45"]
}, Open  ]],

Cell[TextData[{
 "Additionally, the ",
 StyleBox[ButtonBox["Grid",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Grid"], "FunctionLink"],
 " function can be used to display a list of lists as an array."
}], "Text",ExpressionUUID->"1892006b-bd60-4fe1-b464-19e04701a0dc"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{
  RowBox[{"Partition", "[", 
   RowBox[{
    RowBox[{"Range", "[", "12", "]"}], ",", "3"}], "]"}], "//", 
  "Grid"}]], "Input",
 CellLabel->
  "In[134]:=",ExpressionUUID->"24718d7c-b820-43c2-a982-0aa293491ffd"],

Cell[BoxData[
 TagBox[GridBox[{
    {"1", "2", "3"},
    {"4", "5", "6"},
    {"7", "8", "9"},
    {"10", "11", "12"}
   },
   AutoDelete->False,
   GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{Automatic}}}],
  "Grid"]], "Output",
 CellLabel->
  "Out[134]=",ExpressionUUID->"804080e6-df66-47c8-b4c1-333c1382e76c"]
}, Open  ]],

Cell[TextData[{
 "Here, then, is the function ",
 StyleBox["nQueens", "Code"],
 " which produces a solution to the ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "ec328753-4aeb-4223-91c8-ff84b881a59c"],
 "-Queens problem. Recall that the output of the function ",
 StyleBox[ButtonBox["SatisfiabilityInstances",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiabilityInstances"], "FunctionLink"],
 " is a list of solutions. Thus, we need to apply ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " (",
 StyleBox["[[\[Ellipsis]]]", "Code"],
 ") to access the first solution."
}], "Text",ExpressionUUID->"491aa4a8-4c96-4def-b8d9-44e13aef428b"],

Cell[BoxData[
 RowBox[{
  RowBox[{"nQueens", "[", "n_", "]"}], ":=", 
  RowBox[{"Grid", "[", 
   RowBox[{"Partition", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"SatisfiabilityInstances", "[", 
       RowBox[{
        RowBox[{
         RowBox[{"nQueens1", "[", "n", "]"}], "&&", 
         RowBox[{"nQueens2", "[", "n", "]"}], "&&", 
         RowBox[{"nQueens3", "[", "n", "]"}], "&&", 
         RowBox[{"nQueens4", "[", "n", "]"}], "&&", 
         RowBox[{"nQueens5", "[", "n", "]"}]}], ",", 
        RowBox[{"Flatten", "@", 
         RowBox[{"Table", "[", 
          RowBox[{
           RowBox[{"p", "[", 
            RowBox[{"i", ",", "j"}], "]"}], ",", 
           RowBox[{"{", 
            RowBox[{"i", ",", "1", ",", "n"}], "}"}], ",", 
           RowBox[{"{", 
            RowBox[{"j", ",", "1", ",", "n"}], "}"}]}], "]"}]}]}], "]"}], "[", 
      RowBox[{"[", "1", "]"}], "]"}], ",", "n"}], "]"}], "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[135]:=",ExpressionUUID->"4c311128-1f68-42e2-83f7-423da98c22f2"],

Cell[TextData[{
 "Applying this function to ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "=", "8"}], TraditionalForm]],ExpressionUUID->
  "53ba4e0b-c646-401b-8b88-da1419176ddf"],
 " produces a solution to the 8-Queens problem different from the one shown \
in the main text."
}], "Text",ExpressionUUID->"1b6cde39-6ee4-4254-bfe7-91d47596fc1e"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"nQueens", "[", "8", "]"}]], "Input",
 CellLabel->
  "In[136]:=",ExpressionUUID->"442e29ca-df46-4ea8-a893-fef67e6a102f"],

Cell[BoxData[
 TagBox[GridBox[{
    {"False", "False", "True", "False", "False", "False", "False", "False"},
    {"False", "False", "False", "False", "True", "False", "False", "False"},
    {"False", "True", "False", "False", "False", "False", "False", "False"},
    {"False", "False", "False", "False", "False", "False", "False", "True"},
    {"False", "False", "False", "False", "False", "True", "False", "False"},
    {"False", "False", "False", "True", "False", "False", "False", "False"},
    {"False", "False", "False", "False", "False", "False", "True", "False"},
    {"True", "False", "False", "False", "False", "False", "False", "False"}
   },
   AutoDelete->False,
   GridBoxItemSize->{"Columns" -> {{Automatic}}, "Rows" -> {{Automatic}}}],
  "Grid"]], "Output",
 CellLabel->
  "Out[136]=",ExpressionUUID->"0df03c5f-e0f7-4b9f-9c3f-0d0894678032"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.4 Predicates and Quantifiers", "Section",
 CellTags->"Section4",ExpressionUUID->"7ac4187e-7018-405a-a934-849880f911c8"],

Cell[TextData[{
 "In this section, we will see how ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used to explore propositional functions and quantification. We can \
think about a propositional function ",
 Cell[BoxData[
  FormBox["P", TraditionalForm]],ExpressionUUID->
  "0251e03a-5743-4c78-b419-0860d73e5c8d"],
 " as a function that takes as input a member of the domain and that outputs \
a truth value."
}], "Text",ExpressionUUID->"fb515fb4-4e9b-490d-ad8c-7bb7989064d9"],

Cell[TextData[{
 "For example, let ",
 Cell[BoxData[
  FormBox[
   RowBox[{"P", "(", "x", ")"}], TraditionalForm]],ExpressionUUID->
  "6a68fbc6-c219-4414-9e34-538580e64f29"],
 " denote the statement \[OpenCurlyDoubleQuote]",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", ">", "0"}], TraditionalForm]],ExpressionUUID->
  "7d962019-1a58-4f7f-b8ce-1f840754e3d2"],
 ".\[CloseCurlyDoubleQuote] We can create a function in the Wolfram Language, \
say ",
 StyleBox["gt0", "Code"],
 " (for greater than 0), that takes ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]],ExpressionUUID->
  "c860a825-6c32-41e4-9453-54de0f7a4bfe"],
 " as input and returns true or false as appropriate. All we have to do is to \
assign the inequality as the body of the function."
}], "Text",ExpressionUUID->"66681dec-7ab8-48ef-a7e3-b7980ebedeaf"],

Cell[BoxData[
 RowBox[{
  RowBox[{"gt0", "[", "x_", "]"}], ":=", 
  RowBox[{"x", ">", "0"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[137]:=",ExpressionUUID->"259a7f79-e340-44b3-aa00-47add05c7af1"],

Cell["\<\
Evaluating the propositional function at different values demonstrates that \
the result is a truth value.\
\>", "Text",ExpressionUUID->"afc2a70c-bd58-45f9-8194-3866cd378523"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"gt0", "[", "5", "]"}]], "Input",
 CellLabel->
  "In[138]:=",ExpressionUUID->"16928c9c-9c17-4385-a76e-c5ab6c6ba14e"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[138]=",ExpressionUUID->"073b5552-c3d0-4c80-b10b-f21a2e87d63a"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"gt0", "[", 
  RowBox[{"-", "3"}], "]"}]], "Input",
 CellLabel->
  "In[139]:=",ExpressionUUID->"81277a35-5c49-4523-9238-8584b1079d5a"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[139]=",ExpressionUUID->"1e1197b4-d1f3-49a2-b940-ef9366134a20"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Representation of Quantifiers", "Subsection",
 PageBreakWithin->False,
 CellTags->"Section4a",ExpressionUUID->"86ae9358-2b36-46f6-ae75-fdd8851cce21"],

Cell[TextData[{
 "The Wolfram Language represents quantification using the functions ",
 StyleBox[ButtonBox["ForAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ForAll"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["Exists",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Exists"], "FunctionLink"],
 ". These functions have the same syntax. In their most basic form, they take \
two arguments. The first argument is the variable being bound by the \
quantifier, and the second is the expression being quantified. For example, \
to represent the statement ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[ForAll]", "x"], 
    RowBox[{"P", "(", "x", ")"}]}], TraditionalForm]],ExpressionUUID->
  "2446b1f3-0456-4003-9cfd-61690891af07"],
 ", you would enter the following."
}], "Text",
 PageBreakAbove->False,
 PageBreakWithin->
  False,ExpressionUUID->"51b611d2-d9c9-4952-bace-54263f121c80"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ForAll", "[", 
  RowBox[{"x", ",", 
   RowBox[{"P", "[", "x", "]"}]}], "]"}]], "Input",
 CellLabel->
  "In[140]:=",ExpressionUUID->"a672e207-a1dc-4018-bbe0-dc4a6ba64267"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[ForAll]", "x"], 
  RowBox[{"P", "[", "x", "]"}]}]], "Output",
 CellLabel->
  "Out[140]=",ExpressionUUID->"87abafd8-9258-4d53-bd64-6517c7f54b93"]
}, Open  ]],

Cell[TextData[{
 "Likewise, we can represent the assertion that there exists an ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]],ExpressionUUID->
  "acd8cfd5-bc8c-4434-8de5-43bc2ecb6cb4"],
 " for which the opposite is negative as follows."
}], "Text",ExpressionUUID->"14c615b0-2616-4bd9-a437-66a81e7561b1"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Exists", "[", 
  RowBox[{"x", ",", 
   RowBox[{
    RowBox[{"-", "x"}], "<", "0"}]}], "]"}]], "Input",
 CellLabel->
  "In[141]:=",ExpressionUUID->"3fbb54c3-a59b-4674-ba44-39b8e837bc88"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[Exists]", "x"], 
  RowBox[{
   RowBox[{"-", "x"}], "<", "0"}]}]], "Output",
 CellLabel->
  "Out[141]=",ExpressionUUID->"b4058d61-bbfc-4b0f-9f51-ab2395c2720c"]
}, Open  ]],

Cell[TextData[{
 "The ",
 StyleBox[ButtonBox["ForAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ForAll"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["Exists",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Exists"], "FunctionLink"],
 " commands also allow you to express conditions on the bound variable by use \
of an optional second argument. For example, to symbolically express the \
assertion \[OpenCurlyDoubleQuote]For all ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", ">", "0"}], TraditionalForm]],ExpressionUUID->
  "8eee1425-5ea9-4d20-b464-b25713ac1781"],
 ", ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"-", "x"}], "<", "0"}], TraditionalForm]],ExpressionUUID->
  "81f2f609-0dec-4193-8524-b89db99a1815"],
 ",\[CloseCurlyDoubleQuote] you include the condition ",
 Cell[BoxData[
  FormBox[
   RowBox[{"x", ">", "0"}], TraditionalForm]],ExpressionUUID->
  "30794b35-d427-4fcc-91ef-df0732727be9"],
 " as the second argument and the expression ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"-", "x"}], "<", "0"}], TraditionalForm]],ExpressionUUID->
  "01125519-8e40-4683-aa37-c3a1cdccb555"],
 " as the third argument."
}], "Text",ExpressionUUID->"b8c7d35f-9d26-4d45-8923-0e876cdebde7"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ForAll", "[", 
  RowBox[{"x", ",", 
   RowBox[{"x", ">", "0"}], ",", 
   RowBox[{
    RowBox[{"-", "x"}], "<", "0"}]}], "]"}]], "Input",
 CellLabel->
  "In[142]:=",ExpressionUUID->"2bc09a72-5b22-413c-873c-98fc5d47d67a"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[ForAll]", 
   RowBox[{"x", ",", 
    RowBox[{"x", ">", "0"}]}]], 
  RowBox[{
   RowBox[{"-", "x"}], "<", "0"}]}]], "Output",
 CellLabel->
  "Out[142]=",ExpressionUUID->"ac25050d-b7f3-457a-887d-2dabacbee653"]
}, Open  ]],

Cell[TextData[{
 "You can, in particular, use the condition to specify the domain, or \
universe of discourse, by asserting that the variable belongs to one of the \
Wolfram Language\[CloseCurlyQuote]s recognized domains using the ",
 StyleBox[ButtonBox["Element",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Element"], "FunctionLink"],
 " function. To assert, for example, that ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]],ExpressionUUID->
  "ee7574fb-05a2-48d8-86ee-4a6d91eddd48"],
 " is a real number, use the ",
 StyleBox[ButtonBox["Element",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Element"], "FunctionLink"],
 " function with first argument ",
 StyleBox["x", "Code"],
 " and second argument ",
 StyleBox[ButtonBox["Reals",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reals"], "FunctionLink"],
 ", the Wolfram Language symbol for the domain of real numbers."
}], "Text",ExpressionUUID->"7ec7bc49-9aa6-47ee-9aad-e1f774e1e38e"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Exists", "[", 
  RowBox[{"x", ",", 
   RowBox[{"Element", "[", 
    RowBox[{"x", ",", "Reals"}], "]"}], ",", 
   RowBox[{
    RowBox[{"x", "^", "2"}], "<", "0"}]}], "]"}]], "Input",
 CellLabel->
  "In[143]:=",ExpressionUUID->"4c2e7f24-78a6-46fe-a078-11d498eddd01"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[Exists]", 
   RowBox[{"x", ",", 
    RowBox[{"x", "\[Element]", 
     TemplateBox[{},
      "Reals"]}]}]], 
  RowBox[{
   SuperscriptBox["x", "2"], "<", "0"}]}]], "Output",
 CellLabel->
  "Out[143]=",ExpressionUUID->"c975001c-9951-45ba-bf72-4d24565ea1fb"]
}, Open  ]],

Cell[TextData[{
 "The Wolfram Language has seven defined domains that you can use: ",
 StyleBox[ButtonBox["Reals",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reals"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["Integers",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Integers"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["Complexes",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Complexes"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["Algebraics",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Algebraics"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["Primes",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Primes"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["Rationals",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Rationals"], "FunctionLink"],
 ", and ",
 StyleBox[ButtonBox["Booleans",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Booleans"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"282b2b93-1967-4848-89d0-5820524025e0"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Truth Values of Quantified Statements", "Subsection",
 CellTags->"Section4b",ExpressionUUID->"64525962-1926-46a2-9954-94bc18205665"],

Cell[TextData[{
 "In addition to symbolically representing quantified statements, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can determine whether they are true or false. The ",
 StyleBox[ButtonBox["Resolve",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Resolve"], "FunctionLink"],
 " function, applied to an expression involving quantifiers, will eliminate \
the quantifiers",
 ". ",
 "For expressions like the ones given above, this result will be the truth \
value of the statement."
}], "Text",ExpressionUUID->"5de76538-fba7-40a6-8be4-358ad4fc77bc"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"Exists", "[", 
   RowBox[{"x", ",", 
    RowBox[{
     RowBox[{"-", "x"}], "<", "0"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[144]:=",ExpressionUUID->"2f4a9328-cdee-4bbf-a3a2-e29656b36d20"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[144]=",ExpressionUUID->"0b730876-2f31-4997-ada1-9e69742324bd"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"ForAll", "[", 
   RowBox[{"x", ",", 
    RowBox[{"x", ">", "0"}], ",", 
    RowBox[{
     RowBox[{"-", "x"}], "<", "0"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[145]:=",ExpressionUUID->"e6f630bb-9a65-4e5a-b543-b60a98907f62"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[145]=",ExpressionUUID->"2ef8fc0c-da37-4df5-a3fb-b531a1e82c82"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"Exists", "[", 
   RowBox[{"x", ",", 
    RowBox[{"Element", "[", 
     RowBox[{"x", ",", "Reals"}], "]"}], ",", 
    RowBox[{
     RowBox[{"x", "^", "2"}], "<", "0"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[146]:=",ExpressionUUID->"001cca99-3401-4c81-89bb-648c2ee633e1"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[146]=",ExpressionUUID->"78a88562-b7f4-43ba-9430-8e3cdad7e196"]
}, Open  ]],

Cell[TextData[{
 "The syntax of the last example can be simplified by using a second argument \
to ",
 StyleBox[ButtonBox["Resolve",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Resolve"], "FunctionLink"],
 ". ",
 "Rather than using the ",
 StyleBox[ButtonBox["Element",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Element"], "FunctionLink"],
 " function within the existential statement, we can obtain the same effect \
by putting the domain ",
 StyleBox[ButtonBox["Reals",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reals"], "FunctionLink"],
 " as a second argument to ",
 StyleBox[ButtonBox["Resolve",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Resolve"], "FunctionLink"],
 "."
}], "Text",ExpressionUUID->"9d01af5a-0d6a-42e5-8ec4-5967b3be3992"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{
   RowBox[{"Exists", "[", 
    RowBox[{"x", ",", 
     RowBox[{
      RowBox[{"x", "^", "2"}], "<", "0"}]}], "]"}], ",", "Reals"}], 
  "]"}]], "Input",
 CellLabel->
  "In[147]:=",ExpressionUUID->"c159063e-43cf-47da-a734-abbf1a7309a3"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[147]=",ExpressionUUID->"204f488c-a8ba-4a6c-beb4-f9310637a049"]
}, Open  ]],

Cell["\<\
Note that we obtain a different result by changing the domain.\
\>", "Text",ExpressionUUID->"1a94f2e9-3a01-466d-aa29-12f89b68ad86"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{
   RowBox[{"Exists", "[", 
    RowBox[{"x", ",", 
     RowBox[{
      RowBox[{"x", "^", "2"}], "<", "0"}]}], "]"}], ",", "Complexes"}], 
  "]"}]], "Input",
 CellLabel->
  "In[148]:=",ExpressionUUID->"68e229c7-a331-4932-8735-d496c12bf297"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[148]=",ExpressionUUID->"b1b77307-cccf-457d-add5-21f60f1cd7c4"]
}, Open  ]],

Cell[TextData[{
 "For existential quantification, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can go beyond just finding the truth value and actually give you witnesses \
for the existence of objects with the desired property. This is done using \
the ",
 StyleBox[ButtonBox["FindInstance",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/FindInstance"], "FunctionLink"],
 " function. For example, the statement ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{
     SubscriptBox["\[Exists]", "x"], 
     SuperscriptBox["x", "3"]}], "=", "8"}], TraditionalForm]],
  ExpressionUUID->"306bd455-5dad-40d5-94e7-4efbfdbc09a7"],
 " is true. (Note that to enter an equation, we must use the ",
 StyleBox[ButtonBox["Equal",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Equal"], "FunctionLink"],
 " (",
 StyleBox["==", "Code"],
 ") relation so as to avoid confusion with assignment.)"
}], "Text",ExpressionUUID->"0a29036b-133f-4220-88af-efe2d5c6c29c"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"Exists", "[", 
   RowBox[{"x", ",", 
    RowBox[{
     RowBox[{"x", "^", "3"}], "\[Equal]", "8"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[149]:=",ExpressionUUID->"6ef81ea4-8830-4025-a388-67eb3a9db41f"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[149]=",ExpressionUUID->"ef97b549-cf0f-49d9-991d-4bbd1a52784c"]
}, Open  ]],

Cell[TextData[{
 "We can find a witness for this by applying ",
 StyleBox[ButtonBox["FindInstance",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/FindInstance"], "FunctionLink"],
 " with the expression ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["x", "3"], "=", "8"}], TraditionalForm]],ExpressionUUID->
  "766d5e3f-f111-4bd6-b2fe-f56c54ec76dc"],
 " as the first argument and the variable as the second variable",
 ". "
}], "Text",ExpressionUUID->"4251d830-2e08-4793-84ff-c61a26dba6b1"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"FindInstance", "[", 
  RowBox[{
   RowBox[{
    RowBox[{"x", "^", "3"}], "\[Equal]", "8"}], ",", "x"}], "]"}]], "Input",
 CellLabel->
  "In[150]:=",ExpressionUUID->"d8ec0d51-bb2d-4821-bbd4-548386240dc1"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"{", 
   RowBox[{"x", "\[Rule]", "2"}], "}"}], "}"}]], "Output",
 CellLabel->
  "Out[150]=",ExpressionUUID->"be7336c3-8144-4f21-9bdd-3af42c3d51ea"]
}, Open  ]],

Cell[TextData[{
 StyleBox[ButtonBox["FindInstance",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/FindInstance"], "FunctionLink"],
 " accepts two optional arguments",
 ". ",
 "You can ask for more than one witness just by giving the number of \
instances you would like to find as an argument."
}], "Text",ExpressionUUID->"5ae01562-6f36-4754-bfbf-76390ee2a503"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"FindInstance", "[", 
  RowBox[{
   RowBox[{
    RowBox[{"x", "^", "3"}], "\[Equal]", "8"}], ",", "x", ",", "3"}], 
  "]"}]], "Input",
 CellLabel->
  "In[151]:=",ExpressionUUID->"8a4daccc-ab9d-4bd6-ba76-068fa380d212"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", "\[Rule]", "2"}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"x", "\[Rule]", 
     RowBox[{
      RowBox[{"-", "1"}], "-", 
      RowBox[{"\[ImaginaryI]", " ", 
       SqrtBox["3"]}]}]}], "}"}], ",", 
   RowBox[{"{", 
    RowBox[{"x", "\[Rule]", 
     RowBox[{
      RowBox[{"-", "1"}], "+", 
      RowBox[{"\[ImaginaryI]", " ", 
       SqrtBox["3"]}]}]}], "}"}]}], "}"}]], "Output",
 CellLabel->
  "Out[151]=",ExpressionUUID->"8ba2d043-29d2-47eb-bf4e-32242813f243"]
}, Open  ]],

Cell[TextData[{
 "You can also restrict the results to a particular domain by giving the \
domain as an argument. Note that when giving both a domain and a specific \
number of results, the domain should be the third argument and the number the \
fourth argument",
 ". ",
 "Below, we have asked for more instances than exist, so ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " just returns the one witness."
}], "Text",ExpressionUUID->"8446cfe2-3d02-4da8-bc7e-fdfdb702b4a2"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"FindInstance", "[", 
  RowBox[{
   RowBox[{
    RowBox[{"x", "^", "3"}], "\[Equal]", "8"}], ",", "x", ",", "Integers", 
   ",", "3"}], "]"}]], "Input",
 CellLabel->
  "In[152]:=",ExpressionUUID->"640e90ee-ced2-4099-a756-9a04c183b67d"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"{", 
   RowBox[{"x", "\[Rule]", "2"}], "}"}], "}"}]], "Output",
 CellLabel->
  "Out[152]=",ExpressionUUID->"94f876e5-31c4-48d2-8e14-4ca61f7a0f66"]
}, Open  ]],

Cell[TextData[{
 "If a statement has one or more free variables, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used to find conditions on those variables in order to make a \
statement true. For example, consider the statement ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{
     SubscriptBox["\[ForAll]", "x"], 
     RowBox[{"x", "\[CenterDot]", "y"}]}], "=", "0"}], TraditionalForm]],
  ExpressionUUID->"efa6849e-a5be-4977-9ef3-d303814e3153"],
 ". In this statement, ",
 Cell[BoxData[
  FormBox["x", TraditionalForm]],ExpressionUUID->
  "19a24adc-dab5-44e9-b2fe-ab597ed7fe1e"],
 " is bound and ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]],ExpressionUUID->
  "b33d5b81-544c-4a73-84d8-646a23ff416a"],
 " is free. The ",
 StyleBox[ButtonBox["Reduce",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reduce"], "FunctionLink"],
 " function can be used to solve for free variables. Apply it with the \
statement as the first argument and the free variable (or list of variables) \
as the second argument."
}], "Text",ExpressionUUID->"7a85d388-2186-43ec-9bcf-7c7375fa32da"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Reduce", "[", 
  RowBox[{
   RowBox[{"ForAll", "[", 
    RowBox[{"x", ",", 
     RowBox[{
      RowBox[{"x", "*", "y"}], "\[Equal]", "0"}]}], "]"}], ",", "y"}], 
  "]"}]], "Input",
 CellLabel->
  "In[153]:=",ExpressionUUID->"6474f60d-5e31-43f2-877d-5798c3b9e23b"],

Cell[BoxData[
 RowBox[{"y", "\[Equal]", "0"}]], "Output",
 CellLabel->
  "Out[153]=",ExpressionUUID->"fb8c1ad2-ffc3-4eec-9ec9-20ee2f8bb10a"]
}, Open  ]],

Cell[TextData[{
 "The result, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"y", "=", "0"}], TraditionalForm]],ExpressionUUID->
  "2b6b1450-266b-4dfa-96b1-45c24c2ff67a"],
 ", means that if the free variable ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]],ExpressionUUID->
  "3d51f188-95cf-40df-9275-3427bd5ef0e1"],
 " is replaced by the value 0, then the statement will be true."
}], "Text",ExpressionUUID->"f7a3c70c-36ef-402b-ab02-e0508216c4b4"],

Cell[TextData[{
 StyleBox[ButtonBox["Reduce",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Reduce"], "FunctionLink"],
 " accepts a domain as an optional third argument."
}], "Text",ExpressionUUID->"489b0158-549f-45f6-8b2e-3dadd3b1a25c"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Reduce", "[", 
  RowBox[{
   RowBox[{"Exists", "[", 
    RowBox[{"x", ",", 
     RowBox[{
      RowBox[{"x", "^", "2"}], "\[Equal]", "y"}]}], "]"}], ",", "y", ",", 
   "Reals"}], "]"}]], "Input",
 CellLabel->
  "In[154]:=",ExpressionUUID->"6eadd3e4-9309-4856-8f12-7961297be089"],

Cell[BoxData[
 RowBox[{"y", "\[GreaterEqual]", "0"}]], "Output",
 CellLabel->
  "Out[154]=",ExpressionUUID->"34b3fb7f-ef73-4d42-96b7-b3ccad09f337"]
}, Open  ]],

Cell[TextData[{
 "This result means that, restricting all variables to the real numbers, if \
",
 Cell[BoxData[
  FormBox["y", TraditionalForm]],ExpressionUUID->
  "f1570594-8160-4c60-aabc-d4282229daee"],
 " is replaced by any nonnegative real number, the existential statement ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{
     SubscriptBox["\[Exists]", "x"], 
     SuperscriptBox["x", "2"]}], "=", "y"}], TraditionalForm]],
  ExpressionUUID->"70e1285a-f835-46bb-8ffc-ed0c9bfda537"],
 " will be true. Note that if the domain restriction is removed, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " defaults to complex numbers and so there would be no restriction on ",
 Cell[BoxData[
  FormBox["y", TraditionalForm]],ExpressionUUID->
  "98b7bd6a-485e-4a16-b886-22e761ca26bc"],
 "."
}], "Text",ExpressionUUID->"43f05aad-22c7-4308-bb11-b9d76341b7fb"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Reduce", "[", 
  RowBox[{
   RowBox[{"Exists", "[", 
    RowBox[{"x", ",", 
     RowBox[{
      RowBox[{"x", "^", "2"}], "\[Equal]", "y"}]}], "]"}], ",", "y"}], 
  "]"}]], "Input",
 CellLabel->
  "In[155]:=",ExpressionUUID->"f43b30b6-2f4c-452c-8936-c31d1caece33"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[155]=",ExpressionUUID->"67771b68-2c10-407a-bf3d-d261b5c00f46"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.5 Nested Quantifiers", "Section",
 CellTags->"Section5",ExpressionUUID->"4a07aace-d433-46de-b92c-4cb22ecf3437"],

Cell["\<\
The Wolfram Language can be used to represent statements with nested \
quantifiers with the same functions described in the previous section.\
\>", "Text",ExpressionUUID->"0b61273c-bb7c-4c10-acd4-b49739288700"],

Cell[TextData[{
 "For statements in which all the quantifiers are of the same kind, you only \
need to use a single ",
 StyleBox[ButtonBox["Exists",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Exists"], "FunctionLink"],
 " or ",
 StyleBox[ButtonBox["ForAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ForAll"], "FunctionLink"],
 " function with the list of variables surrounded by braces as the first \
argument",
 ". ",
 "For example, to represent the statement ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{
     SubscriptBox["\[ForAll]", "x"], 
     RowBox[{
      SubscriptBox["\[ForAll]", "y"], 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"x", "\[CenterDot]", "y"}], "=", "0"}], ")"}]}]}], "\[Rule]", 
    
    RowBox[{"(", 
     RowBox[{"x", "=", 
      RowBox[{
       RowBox[{"0", "\[Or]", "y"}], "=", "0"}]}], ")"}]}], TraditionalForm]],
  ExpressionUUID->"c8b77ac1-0fb0-43c6-9b35-f6e68ec1d7c6"],
 ", we only need one ",
 StyleBox[ButtonBox["ForAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ForAll"], "FunctionLink"],
 " function with ",
 StyleBox["{x,y}", "Code"],
 " as the first argument."
}], "Text",ExpressionUUID->"8b99d014-b907-47d5-ab92-8e52d201b907"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ForAll", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{"x", ",", "y"}], "}"}], ",", 
   RowBox[{"Implies", "[", 
    RowBox[{
     RowBox[{
      RowBox[{"x", "*", "y"}], "\[Equal]", "0"}], ",", 
     RowBox[{
      RowBox[{"x", "\[Equal]", "0"}], "||", 
      RowBox[{"y", "\[Equal]", "0"}]}]}], "]"}]}], "]"}]], "Input",
 CellLabel->
  "In[156]:=",ExpressionUUID->"0f86b7f9-19d0-4e3d-be53-a718f1007574"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[ForAll]", 
   RowBox[{"{", 
    RowBox[{"x", ",", "y"}], "}"}]], 
  RowBox[{"(", 
   RowBox[{
    RowBox[{
     RowBox[{"x", " ", "y"}], "\[Equal]", "0"}], "\[Implies]", 
    RowBox[{
     RowBox[{"x", "\[Equal]", "0"}], "||", 
     RowBox[{"y", "\[Equal]", "0"}]}]}], ")"}]}]], "Output",
 CellLabel->
  "Out[156]=",ExpressionUUID->"4652fbed-fd9a-4624-8985-9d1fad2b2480"]
}, Open  ]],

Cell[TextData[{
 "Using the ",
 StyleBox[ButtonBox["Resolve",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Resolve"], "FunctionLink"],
 " command, we see that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " recognizes this as true."
}], "Text",ExpressionUUID->"84929a53-abf8-4e40-9a3c-a90774f6b94a"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"ForAll", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"x", ",", "y"}], "}"}], ",", 
    RowBox[{"Implies", "[", 
     RowBox[{
      RowBox[{
       RowBox[{"x", "*", "y"}], "\[Equal]", "0"}], ",", 
      RowBox[{
       RowBox[{"x", "\[Equal]", "0"}], "||", 
       RowBox[{"y", "\[Equal]", "0"}]}]}], "]"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[157]:=",ExpressionUUID->"84b0be10-8795-444f-ad28-125dce348c04"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[157]=",ExpressionUUID->"7529b4b7-7d2a-4170-a816-f3c57b238561"]
}, Open  ]],

Cell[TextData[{
 "Note that since we did not specify a domain, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " uses the default domain based on the context. In this case, it uses the \
complex numbers as its domain, since the content of the statement is about \
equations",
 ". ",
 "In general, the default domain is the largest domain that makes sense in \
the context."
}], "Text",ExpressionUUID->"72e246b3-d2b9-4d77-9691-2af223f49e62"],

Cell[TextData[{
 "For statements that involve more than one type of quantifier, we must nest \
the ",
 StyleBox[ButtonBox["Exists",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Exists"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["ForAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ForAll"], "FunctionLink"],
 " functions",
 ". ",
 "For example, to represent ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{
     SubscriptBox["\[ForAll]", 
      RowBox[{"x", "\[NotEqual]", "0"}]], 
     RowBox[{
      SubscriptBox["\[Exists]", "y"], 
      RowBox[{"x", "\[CenterDot]", "y"}]}]}], "=", "1"}], TraditionalForm]],
  ExpressionUUID->"4598ab8b-1a4f-49d3-b498-8308cdeac0de"],
 ", we enter the following."
}], "Text",ExpressionUUID->"43b95d99-1523-4b05-adbc-e4a3613fd0af"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"ForAll", "[", 
  RowBox[{"x", ",", 
   RowBox[{"x", "\[NotEqual]", "0"}], ",", 
   RowBox[{"Exists", "[", 
    RowBox[{"y", ",", 
     RowBox[{
      RowBox[{"x", "*", "y"}], "\[Equal]", "1"}]}], "]"}]}], "]"}]], "Input",
 CellLabel->
  "In[158]:=",ExpressionUUID->"1a1043b3-828d-43c9-9fdf-34f0f8545e28"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[ForAll]", 
   RowBox[{"x", ",", 
    RowBox[{"x", "\[NotEqual]", "0"}]}]], 
  RowBox[{
   SubscriptBox["\[Exists]", "y"], 
   RowBox[{
    RowBox[{"x", " ", "y"}], "\[Equal]", "1"}]}]}]], "Output",
 CellLabel->
  "Out[158]=",ExpressionUUID->"1d3cf1e8-c19e-4f89-b2c3-822a3d4d90d6"]
}, Open  ]],

Cell[TextData[{
 "Again, ",
 StyleBox[ButtonBox["Resolve",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Resolve"], "FunctionLink"],
 " recognizes the truth of this statement."
}], "Text",ExpressionUUID->"06c1a8de-020e-4524-8933-eebff973714d"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"ForAll", "[", 
   RowBox[{"x", ",", 
    RowBox[{"x", "\[NotEqual]", "0"}], ",", 
    RowBox[{"Exists", "[", 
     RowBox[{"y", ",", 
      RowBox[{
       RowBox[{"x", "*", "y"}], "\[Equal]", "1"}]}], "]"}]}], "]"}], 
  "]"}]], "Input",
 CellLabel->
  "In[159]:=",ExpressionUUID->"a35148aa-2642-48f0-a414-25c61903c077"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[159]=",ExpressionUUID->"98b371f1-ef7d-480c-a2bb-8978ab09c438"]
}, Open  ]],

Cell["\<\
However, limiting the domain to the integers makes the statement false.\
\>", "Text",ExpressionUUID->"0664b181-e07f-4b85-807c-c0e93453b30b"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{
   RowBox[{"ForAll", "[", 
    RowBox[{"x", ",", 
     RowBox[{"x", "\[NotEqual]", "0"}], ",", 
     RowBox[{"Exists", "[", 
      RowBox[{"y", ",", 
       RowBox[{
        RowBox[{"x", "*", "y"}], "\[Equal]", "1"}]}], "]"}]}], "]"}], ",", 
   "Integers"}], "]"}]], "Input",
 CellLabel->
  "In[160]:=",ExpressionUUID->"4877038d-69de-46dd-b81e-43bc1fa60c3d"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[160]=",ExpressionUUID->"47249de4-dbdc-4eea-84d3-8e7b4d21540c"]
}, Open  ]],

Cell["\<\
In addition, observe that reversing the order of the quantifiers changes the \
meaning of the statement.\
\>", "Text",ExpressionUUID->"9eaa143b-a604-4050-8cae-e4cd2b5943df"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Exists", "[", 
  RowBox[{"y", ",", 
   RowBox[{"ForAll", "[", 
    RowBox[{"x", ",", 
     RowBox[{"x", "\[NotEqual]", "0"}], ",", 
     RowBox[{
      RowBox[{"x", "*", "y"}], "\[Equal]", "1"}]}], "]"}]}], "]"}]], "Input",
 CellLabel->
  "In[161]:=",ExpressionUUID->"baaf4ddd-98cf-4b76-9761-965917df9eb0"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[Exists]", "y"], 
  RowBox[{
   SubscriptBox["\[ForAll]", 
    RowBox[{"x", ",", 
     RowBox[{"x", "\[NotEqual]", "0"}]}]], 
   RowBox[{
    RowBox[{"y", " ", "x"}], "\[Equal]", "1"}]}]}]], "Output",
 CellLabel->
  "Out[161]=",ExpressionUUID->"bb512481-28d8-4ad7-92ce-8f276f419e0b"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Resolve", "[", 
  RowBox[{"Exists", "[", 
   RowBox[{"y", ",", 
    RowBox[{"ForAll", "[", 
     RowBox[{"x", ",", 
      RowBox[{"x", "\[NotEqual]", "0"}], ",", 
      RowBox[{
       RowBox[{"x", "*", "y"}], "\[Equal]", "1"}]}], "]"}]}], "]"}], 
  "]"}]], "Input",
 CellLabel->
  "In[162]:=",ExpressionUUID->"dc93abf4-bb11-4d8d-8b7f-856977a538f8"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[162]=",ExpressionUUID->"4677bd0a-9d4c-470a-b24d-3fa7c3c288b2"]
}, Open  ]],

Cell[TextData[{
 "Finally, ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " will automatically apply DeMorgan\[CloseCurlyQuote]s laws for quantifiers \
to a statement that you enter."
}], "Text",ExpressionUUID->"adf88b03-e3cd-45d8-b7a8-b0faeee4b0ed"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"!", 
  RowBox[{"ForAll", "[", 
   RowBox[{"x", ",", 
    RowBox[{"Exists", "[", 
     RowBox[{"y", ",", 
      RowBox[{"ForAll", "[", 
       RowBox[{"z", ",", 
        RowBox[{"P", "[", 
         RowBox[{"x", ",", "y", ",", "z"}], "]"}]}], "]"}]}], "]"}]}], 
   "]"}]}]], "Input",
 CellLabel->
  "In[163]:=",ExpressionUUID->"eb7e8640-6cc1-4194-8ddb-7c4eea24cfbb"],

Cell[BoxData[
 RowBox[{
  SubscriptBox["\[Exists]", "x"], 
  RowBox[{
   SubscriptBox["\[ForAll]", "y"], 
   RowBox[{
    SubscriptBox["\[Exists]", "z"], 
    RowBox[{"!", 
     RowBox[{"P", "[", 
      RowBox[{"x", ",", "y", ",", "z"}], "]"}]}]}]}]}]], "Output",
 CellLabel->
  "Out[163]=",ExpressionUUID->"51129930-71c8-4207-8048-d4fd39646ede"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.6 Rules of Inference", "Section",
 CellTags->"Section6",ExpressionUUID->"e06179c6-6f6b-4807-bdb1-99f50d6e5b2b"],

Cell[TextData[{
 "In this section, we will see how ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used to verify the validity of arguments in propositional logic. In \
particular, we will write a function that, given a list of premises and a \
possible conclusion, will determine whether or not the conclusion necessarily \
follows from the premises. Recall from the text that an argument is defined \
to be a sequence of propositions, the last of which is called the conclusion \
and all others are premises. Also recall that an argument ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["p", "1"], ",", 
    SubscriptBox["p", "2"], ",", "\[Ellipsis]", ",", 
    SubscriptBox["p", "n"], ",", "q"}], TraditionalForm]],ExpressionUUID->
  "930e831d-3922-413c-86f5-80305e510638"],
 " is said to be valid when ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"(", 
     RowBox[{
      SubscriptBox["p", "1"], "\[And]", 
      SubscriptBox["p", "2"], "\[And]", "\[CenterEllipsis]", "\[And]", 
      SubscriptBox["p", "n"]}], ")"}], "\[Rule]", "q"}], TraditionalForm]],
  ExpressionUUID->"8c868c01-9124-44a4-9283-4a1442506e7e"],
 " is a tautology."
}], "Text",ExpressionUUID->"f3ba0ae7-1647-4ed1-8d5a-29591b5472e1"],

Cell[TextData[{
 "We can use the ",
 StyleBox[ButtonBox["TautologyQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TautologyQ"], "FunctionLink"],
 " function described in Section 1.3 of this manual to test whether a \
proposition is a tautology. For example, we can confirm ",
 StyleBox["modus tollens",
  FontSlant->"Italic"],
 ". ",
 "(See Table 1 in Section 1.6 of the text for the tautologies associated to \
the rules of inference.)"
}], "Text",ExpressionUUID->"244cf37f-f649-4164-99a7-92cc147eebf8"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"TautologyQ", "[", 
  RowBox[{"Implies", "[", 
   RowBox[{
    RowBox[{"(", 
     RowBox[{
      RowBox[{"!", "q"}], "&&", 
      RowBox[{"Implies", "[", 
       RowBox[{"p", ",", "q"}], "]"}]}], ")"}], ",", 
    RowBox[{"!", "p"}]}], "]"}], "]"}]], "Input",
 CellLabel->
  "In[164]:=",ExpressionUUID->"490814b9-376c-45f3-a657-8e7fe95f2e6e"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[164]=",ExpressionUUID->"6332d034-48b1-467a-93ed-4b3d12df5a4b"]
}, Open  ]],

Cell[TextData[{
 "To determine whether an argument is valid, we need to (1) form the \
conjunction of the premises, (2) form the conditional statement that the \
premises imply the conclusion, and (3) test the resulting proposition with ",
 StyleBox[ButtonBox["TautologyQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/TautologyQ"], "FunctionLink"],
 ". The ",
 StyleBox["validQ", "Code"],
 " function below will accept as input an argument, that is, a list of \
propositions, and return true if the argument is valid."
}], "Text",ExpressionUUID->"b50a04f5-0196-40e0-bc28-7cb203ccf830"],

Cell[BoxData[
 RowBox[{
  RowBox[{"validQ", "[", "A_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"premiseList", ",", "premises"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"premiseList", "=", 
      RowBox[{"A", "[", 
       RowBox[{"[", 
        RowBox[{"1", ";;", 
         RowBox[{"-", "2"}]}], "]"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"premises", "=", 
      RowBox[{"Apply", "[", 
       RowBox[{"And", ",", "premiseList"}], "]"}]}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"TautologyQ", "[", 
      RowBox[{"Implies", "[", 
       RowBox[{"premises", ",", 
        RowBox[{"A", "[", 
         RowBox[{"[", 
          RowBox[{"-", "1"}], "]"}], "]"}]}], "]"}], "]"}]}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[165]:=",ExpressionUUID->"c00ae3f1-d4fd-4f09-9d72-952c8f8d9f90"],

Cell[TextData[{
 "Two comments on the code above are needed. First, the double semicolons \
used in the definition of ",
 StyleBox["premiseList", "Code"],
 " is the ",
 StyleBox[ButtonBox["Span",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Span"], "FunctionLink"],
 " (",
 StyleBox[";;", "Code"],
 ") operator. When used to refer to a ",
 StyleBox[ButtonBox["Part",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Part"], "FunctionLink"],
 " (",
 StyleBox["[[\[Ellipsis]]]", "Code"],
 ") of a list, ",
 Cell[BoxData[
  RowBox[{
   StyleBox["i", "CodeVar"], ";;", 
   StyleBox["j", "CodeVar"]}]], "myCode",ExpressionUUID->
  "08703536-92e6-4481-9288-9949271b5526"],
 " indicates the range from index ",
 StyleBox["i", "CodeVar"],
 " to index ",
 StyleBox["j", "CodeVar"],
 ". In this case, ",
 Cell[BoxData[
  RowBox[{"-", "2"}]], "myCode",ExpressionUUID->
  "aa92ca19-196b-404a-8462-ff3b29ae97bf"],
 " indicates the next to last entry of the list. Therefore, ",
 Cell[BoxData[
  RowBox[{
   RowBox[{"A", "[", "["}], "1", ";;", 
   RowBox[{"-", "2"}], 
   RowBox[{"]", "]"}]}]], "myCode",ExpressionUUID->
  "219b1ed7-0740-4ac0-b574-a27af78a7046"],
 " refers to all of ",
 StyleBox["A", "Code"],
 " except the last entry and is thus the premises of the argument ",
 StyleBox["A", "Code"],
 ". Second, the ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " operator is used to apply the function ",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 " to the arguments contained in the list ",
 StyleBox["premiseList", "Code"],
 ". This is necessary because, while ",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 " can accept any number of arguments and form the logical conjunction, it \
will not do anything with a single list like ",
 StyleBox["premiseList", "Code"],
 ". When ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " is given a function and a list, the result is the same as if the elements \
of the list were given as the arguments to the function. Fundamentally, ",
 StyleBox[ButtonBox["Apply",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Apply"], "FunctionLink"],
 " is replacing the head of the list, ",
 StyleBox["List", "Code"],
 ", by the name of the function."
}], "Text",ExpressionUUID->"18282196-0f65-43e9-8736-b6579d98e4ae"],

Cell["\<\
We can use this function to verify that the argument described in Exercise 12 \
of Section 1.6 of the text is in fact valid.\
\>", "Text",ExpressionUUID->"279e3b66-ff76-4b8f-b1ac-9642aa97b7be"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"validQ", "[", 
  RowBox[{"{", 
   RowBox[{
    RowBox[{"Implies", "[", 
     RowBox[{
      RowBox[{"p", "&&", "t"}], ",", 
      RowBox[{"r", "||", "s"}]}], "]"}], ",", 
    RowBox[{"Implies", "[", 
     RowBox[{"q", ",", 
      RowBox[{"u", "&&", "t"}]}], "]"}], ",", 
    RowBox[{"Implies", "[", 
     RowBox[{"u", ",", "p"}], "]"}], ",", 
    RowBox[{"!", "s"}], ",", 
    RowBox[{"Implies", "[", 
     RowBox[{"q", ",", "r"}], "]"}]}], "}"}], "]"}]], "Input",
 CellLabel->
  "In[166]:=",ExpressionUUID->"ce18db38-6a82-46c1-b5dd-bec1b7e96a67"],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[166]=",ExpressionUUID->"dae47ddb-c27d-448c-a004-6fd055ca6cb9"]
}, Open  ]],

Cell[TextData[{
 "Note that Exercise 12, which this example was based on, asks you to verify \
the validity of the argument using rules of inference. It is important to \
note that our function did not do that. It essentially used truth tables to \
check validity. It would be considerably more difficult to program ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " to check validity with rules of inference than it was to do so with truth \
tables. On the other hand, for a human, it is typically much easier to use \
rules of inference than a truth table. Especially with practice, you will \
develop an intuition about logical arguments that cannot be easily created in \
a computer."
}], "Text",ExpressionUUID->"0b75df42-e462-49ec-a0b6-c7a22093ac1d"],

Cell[CellGroupData[{

Cell["Finding Conclusions (Optional)", "Subsection",
 CellTags->"Section6a",ExpressionUUID->"419e1445-3d3c-4d63-afcd-5c63a0f11b57"],

Cell[TextData[{
 "In the remainder of this section, we consider a slightly different \
question: given a list of premises, what conclusions can you draw using valid \
arguments? We will approach this problem in a straightforward (and naive) \
way: generate possible conclusions and use ",
 StyleBox["validQ", "Code"],
 " to determine which are valid conclusions."
}], "Text",ExpressionUUID->"12053fd6-8be0-476f-8b8b-f5a119ae24f8"],

Cell[CellGroupData[{

Cell["Making Compound Propositions", "Subsubsection",ExpressionUUID->"b8e3d83c-2944-4a3b-a295-8471e60e8e6d"],

Cell[TextData[{
 "To generate possible conclusions, we will use the following function, ",
 StyleBox["allCompound", "Code"],
 ". This function takes a list of propositions and produces all possible \
propositions formed from one logical connective (selected from ",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 ", ",
 StyleBox[ButtonBox["Or",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Or"], "FunctionLink"],
 ", and ",
 StyleBox[ButtonBox["Implies",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Implies"], "FunctionLink"],
 ") and two of the given propositions along with the negations of the \
propositions. To avoid including some trivialities, we will exclude those \
propositions that are tautologies or contradictions."
}], "Text",ExpressionUUID->"b72dbf63-eebf-4ac8-b7e4-5af65134be13"],

Cell[TextData[{
 "The function is provided below. Note the use of ",
 StyleBox[ButtonBox["AppendTo",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/AppendTo"], "FunctionLink"],
 ", which accepts a list and an element to be added to the list as arguments. \
It has the result of adding the given element to the list and updating the \
list without the need of an explicit assignment. In addition, note that at \
the end of the function, we apply ",
 StyleBox[ButtonBox["DeleteDuplicates",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/DeleteDuplicates"], "FunctionLink"],
 " so as to remove repeated elements from the list. Pay attention to the uses \
of ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 ", which allow us to loop over all the elements (or combinations of \
elements) of lists."
}], "Text",ExpressionUUID->"d036b96c-7179-4e75-92dc-0d519eff32de"],

Cell["\<\
The bulk of the function is taken up by adding the conjunction, disjunction, \
and implication of the chosen pair to the result list, provided that they do \
not form tautologies or contradictions.\
\>", "Text",ExpressionUUID->"9fca836f-2b53-4e06-bc9c-bd7ddd658e0e"],

Cell[BoxData[
 RowBox[{
  RowBox[{"allCompound", "[", "vars_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"p", ",", "q", ",", 
      RowBox[{"tempList", "=", "vars"}], ",", "propList"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{"AppendTo", "[", 
        RowBox[{"tempList", ",", 
         RowBox[{"!", "p"}]}], "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"p", ",", "vars"}], "}"}]}], "]"}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"propList", "=", "tempList"}], ";", "\[IndentingNewLine]", 
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"!", 
            RowBox[{"TautologyQ", "[", 
             RowBox[{"p", "&&", "q"}], "]"}]}], "&&", 
           RowBox[{"!", 
            RowBox[{"TautologyQ", "[", 
             RowBox[{"!", 
              RowBox[{"(", 
               RowBox[{"p", "&&", "q"}], ")"}]}], "]"}]}]}], ",", 
          RowBox[{"AppendTo", "[", 
           RowBox[{"propList", ",", 
            RowBox[{"p", "&&", "q"}]}], "]"}]}], "]"}], ";", 
        "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"!", 
            RowBox[{"TautologyQ", "[", 
             RowBox[{"p", "||", "q"}], "]"}]}], "&&", 
           RowBox[{"!", 
            RowBox[{"TautologyQ", "[", 
             RowBox[{"!", 
              RowBox[{"(", 
               RowBox[{"p", "||", "q"}], ")"}]}], "]"}]}]}], ",", 
          RowBox[{"AppendTo", "[", 
           RowBox[{"propList", ",", 
            RowBox[{"p", "||", "q"}]}], "]"}]}], "]"}], ";", 
        "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"!", 
            RowBox[{"TautologyQ", "[", 
             RowBox[{"Implies", "[", 
              RowBox[{"p", ",", "q"}], "]"}], "]"}]}], "&&", 
           RowBox[{"!", 
            RowBox[{"TautologyQ", "[", 
             RowBox[{"!", 
              RowBox[{"Implies", "[", 
               RowBox[{"p", ",", "q"}], "]"}]}], "]"}]}]}], ",", 
          RowBox[{"AppendTo", "[", 
           RowBox[{"propList", ",", 
            RowBox[{"Implies", "[", 
             RowBox[{"p", ",", "q"}], "]"}]}], "]"}]}], "]"}]}], 
       "\[IndentingNewLine]", ",", 
       RowBox[{"{", 
        RowBox[{"p", ",", "tempList"}], "}"}], ",", 
       RowBox[{"{", 
        RowBox[{"q", ",", "tempList"}], "}"}]}], "]"}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"DeleteDuplicates", "[", "propList", "]"}]}]}], "]"}]}]], "Input",\

 InitializationCell->True,
 CellLabel->
  "In[167]:=",ExpressionUUID->"ccb5ca0d-b983-4743-b5e1-bd07225e3cd7"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Finding Valid Conclusions", "Subsubsection",ExpressionUUID->"fdf4c3ea-a9b8-406b-a35a-a039d4e5517c"],

Cell[TextData[{
 "Now we write a function to explore possible conclusions given a set of \
premises. This function will take two arguments. The first will be a list of \
premises. The second will be a positive integer indicating the number of \
times that ",
 StyleBox["allCompound", "Code"],
 " should, recursively, be used to generate possibilities. You will generally \
not want to use any number other than 1 for this second value as the time \
requirement can be quite substantial."
}], "Text",ExpressionUUID->"aab27610-665a-4251-9661-08952c4e2943"],

Cell[TextData[{
 "The operation of this function is fairly straightforward. First, it \
determines the variables used in the provided premises by applying the ",
 StyleBox["getVars", "Code"],
 " function we wrote above. Second, beginning with the list of variables, it \
recursively applies ",
 StyleBox["allCompound", "Code"],
 " a number of times equal to the level, which is the second argument to the \
function. Finally, for each of the possible conclusions generated by the ",
 StyleBox["allCompound", "Code"],
 " function, it uses ",
 StyleBox["validQ", "Code"],
 " to see if it is a valid conclusion from the premises, and adds those that \
are to the output."
}], "Text",ExpressionUUID->"0a3c79f7-6223-45ef-b6e8-fabc3b3952ca"],

Cell[BoxData[
 RowBox[{
  RowBox[{"findConsequences", "[", 
   RowBox[{"premises_", ",", "level_"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"vars", ",", "P", ",", "possibleC", ",", 
      RowBox[{"conclusions", "=", 
       RowBox[{"{", "}"}]}], ",", "c", ",", "i"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"vars", "=", 
      RowBox[{"getVars", "[", "premises", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"possibleC", "=", "vars"}], ";", "\[IndentingNewLine]", 
     RowBox[{"For", "[", 
      RowBox[{
       RowBox[{"i", "=", "1"}], ",", 
       RowBox[{"i", "\[LessEqual]", "level"}], ",", 
       RowBox[{"i", "++"}], ",", 
       RowBox[{"possibleC", "=", 
        RowBox[{"allCompound", "[", "possibleC", "]"}]}]}], "]"}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"Do", "[", "\[IndentingNewLine]", 
      RowBox[{
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"validQ", "[", 
          RowBox[{"Append", "[", 
           RowBox[{"premises", ",", "c"}], "]"}], "]"}], ",", 
         RowBox[{"AppendTo", "[", 
          RowBox[{"conclusions", ",", "c"}], "]"}]}], "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"c", ",", "possibleC"}], "}"}]}], "\[IndentingNewLine]", 
      "]"}], ";", "\[IndentingNewLine]", "conclusions"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[168]:=",ExpressionUUID->"3e70121a-f82a-4fe4-80b4-b147340ed8dd"],

Cell[TextData[{
 "Here is the result of applying ",
 StyleBox["findConsequences", "Code"],
 " to the premises of Exercise 12 with only one iteration of ",
 StyleBox["allCompound", "Code"],
 ". ",
 "(With two iterations, the function takes quite some time to complete and \
produces thousands of valid conclusions.)"
}], "Text",ExpressionUUID->"c371730f-f4a7-49da-887d-45b5ba0595de"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"findConsequences", "[", 
  RowBox[{
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Implies", "[", 
      RowBox[{
       RowBox[{"p", "&&", "t"}], ",", 
       RowBox[{"r", "||", "s"}]}], "]"}], ",", 
     RowBox[{"Implies", "[", 
      RowBox[{"q", ",", 
       RowBox[{"u", "&&", "t"}]}], "]"}], ",", 
     RowBox[{"Implies", "[", 
      RowBox[{"u", ",", "p"}], "]"}], ",", 
     RowBox[{"!", "s"}]}], "}"}], ",", "1"}], "]"}]], "Input",
 CellLabel->
  "In[169]:=",ExpressionUUID->"ccaa5bab-bc19-4466-95c8-02f60e78b9d0"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"!", "s"}], ",", 
   RowBox[{"p", "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"p", "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"p", "||", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{"p", "||", 
    RowBox[{"!", "u"}]}], ",", 
   RowBox[{"t", "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"t", "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"t", "||", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{"r", "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"r", "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"r", "||", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{"s", "\[Implies]", "p"}], ",", 
   RowBox[{"s", "\[Implies]", "t"}], ",", 
   RowBox[{"s", "\[Implies]", "r"}], ",", 
   RowBox[{"s", "\[Implies]", "q"}], ",", 
   RowBox[{"s", "\[Implies]", "u"}], ",", 
   RowBox[{"s", "\[Implies]", 
    RowBox[{"!", "p"}]}], ",", 
   RowBox[{"s", "\[Implies]", 
    RowBox[{"!", "t"}]}], ",", 
   RowBox[{"s", "\[Implies]", 
    RowBox[{"!", "r"}]}], ",", 
   RowBox[{"s", "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"s", "\[Implies]", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{"s", "\[Implies]", 
    RowBox[{"!", "u"}]}], ",", 
   RowBox[{"q", "\[Implies]", "p"}], ",", 
   RowBox[{"q", "\[Implies]", "t"}], ",", 
   RowBox[{"q", "\[Implies]", "r"}], ",", 
   RowBox[{"q", "\[Implies]", "u"}], ",", 
   RowBox[{"q", "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"q", "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"u", "\[Implies]", "p"}], ",", 
   RowBox[{"u", "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"u", "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{"u", "||", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "\[Implies]", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{
    RowBox[{"!", "p"}], "\[Implies]", 
    RowBox[{"!", "u"}]}], ",", 
   RowBox[{
    RowBox[{"!", "t"}], "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "t"}], "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "t"}], "\[Implies]", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{
    RowBox[{"!", "r"}], "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "r"}], "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "r"}], "\[Implies]", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", "p"}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", "t"}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", "r"}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", "q"}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", "u"}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", 
    RowBox[{"!", "p"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", 
    RowBox[{"!", "t"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", 
    RowBox[{"!", "r"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "&&", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", 
    RowBox[{"!", "q"}]}], ",", 
   RowBox[{
    RowBox[{"!", "s"}], "||", 
    RowBox[{"!", "u"}]}], ",", 
   RowBox[{
    RowBox[{"!", "q"}], "||", "p"}], ",", 
   RowBox[{
    RowBox[{"!", "q"}], "||", "t"}], ",", 
   RowBox[{
    RowBox[{"!", "q"}], "||", "r"}], ",", 
   RowBox[{
    RowBox[{"!", "q"}], "||", "u"}], ",", 
   RowBox[{
    RowBox[{"!", "q"}], "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "q"}], "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "u"}], "||", "p"}], ",", 
   RowBox[{
    RowBox[{"!", "u"}], "||", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "u"}], "\[Implies]", 
    RowBox[{"!", "s"}]}], ",", 
   RowBox[{
    RowBox[{"!", "u"}], "\[Implies]", 
    RowBox[{"!", "q"}]}]}], "}"}]], "Output",
 CellLabel->
  "Out[169]=",ExpressionUUID->"332eb686-9dbb-4565-8dd7-937e1d3d7e57"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"Length", "[", "%", "]"}]], "Input",
 CellLabel->
  "In[170]:=",ExpressionUUID->"23a1e5dc-980b-4927-bc48-b3a3527b1cb6"],

Cell[BoxData["64"], "Output",
 CellLabel->
  "Out[170]=",ExpressionUUID->"31eadad1-c9d9-43c4-862d-0d01b4023a2c"]
}, Open  ]],

Cell["\<\
Observe that some of the conclusions are merely restating premises. However, \
even after eliminating those, there are still 60 valid conclusions involving \
at most two of the propositional variables. Most of those conclusions are \
going to be fairly uninteresting in any particular context. This illustrates \
a fundamental difficulty with computer-assisted proof. Neither checking the \
validity of conclusions nor generating valid conclusions from a list of \
premises are particularly difficult. The difficulty is in creating heuristics \
and other mechanisms to help direct the computer to useful results.\
\>", "Text",ExpressionUUID->"7937960c-5973-4f21-8d7e-c24f475fe275"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.7 Introduction to Proofs", "Section",
 CellTags->"Section7",ExpressionUUID->"3a9a9222-9952-41f3-bb49-0db02ae48c98"],

Cell[TextData[{
 "In this section, we will see how ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can be used to find counterexamples. This is the proof technique most \
suitable to ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "\[CloseCurlyQuote]s computational abilities."
}], "Text",ExpressionUUID->"21bd053e-ce3a-434c-a459-dd4b0ffd6a17"],

Cell["\<\
Example 15 of Section 1.7 of the textbook considers the statement \
\[OpenCurlyDoubleQuote]Every positive integer is the sum of the squares of \
two integers.\[CloseCurlyDoubleQuote] This is demonstrated to be false with 3 \
as a counterexample. Here, we will consider the related statement that \
\[OpenCurlyDoubleQuote]Every positive integer is the sum of the squares of \
three integers.\[CloseCurlyDoubleQuote] This statement is also false.\
\>", "Text",ExpressionUUID->"a3c2462e-625d-4be2-bd60-d2be885753ee"],

Cell[CellGroupData[{

Cell["Finding a Counterexample", "Subsection",
 CellTags->"Section7a",ExpressionUUID->"32432fd3-2627-40b3-9d93-d341eaa4b9a5"],

Cell["\<\
To find a counterexample, we will create a function that, given an integer, \
looks for three integers with the property that the sum of their squares is \
equal to the given integer. If the function finds three such integers, it \
will return a list containing them. On the other hand, if it cannot find \
three such integers, it will return false. Here is the function:\
\>", "Text",ExpressionUUID->"347bbfbc-6416-472d-a0a8-84f12b5d7d1f"],

Cell[BoxData[
 RowBox[{
  RowBox[{"find3squares", "[", "n_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"a", ",", "b", ",", "c", ",", 
      RowBox[{"max", "=", 
       RowBox[{"Floor", "[", 
        RowBox[{"Sqrt", "[", "n", "]"}], "]"}]}]}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{
      RowBox[{"For", "[", 
       RowBox[{
        RowBox[{"a", "=", "0"}], ",", 
        RowBox[{"a", "\[LessEqual]", "max"}], ",", 
        RowBox[{"a", "++"}], ",", "\[IndentingNewLine]", 
        RowBox[{"For", "[", 
         RowBox[{
          RowBox[{"b", "=", "0"}], ",", 
          RowBox[{"b", "\[LessEqual]", "max"}], ",", 
          RowBox[{"b", "++"}], ",", "\[IndentingNewLine]", 
          RowBox[{"For", "[", 
           RowBox[{
            RowBox[{"c", "=", "0"}], ",", 
            RowBox[{"c", "\[LessEqual]", "max"}], ",", 
            RowBox[{"c", "++"}], ",", "\[IndentingNewLine]", 
            RowBox[{"If", "[", 
             RowBox[{
              RowBox[{"n", "\[Equal]", 
               RowBox[{
                RowBox[{"a", "^", "2"}], "+", 
                RowBox[{"b", "^", "2"}], "+", 
                RowBox[{"c", "^", "2"}]}]}], ",", 
              RowBox[{"Throw", "[", 
               RowBox[{"{", 
                RowBox[{"a", ",", "b", ",", "c"}], "}"}], "]"}]}], "]"}]}], 
           "\[IndentingNewLine]", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
       "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
      RowBox[{"Throw", "[", "False", "]"}]}], "\[IndentingNewLine]", "]"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[171]:=",ExpressionUUID->"8fc457a5-2be1-4c6b-91be-9d46b043bbc2"],

Cell[TextData[{
 "The ",
 StyleBox["find3squares", "Code"],
 " function is straightforward. We use three ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " loops to check all possible values of ",
 StyleBox["a", "Code"],
 ", ",
 StyleBox["b", "Code"],
 ", and ",
 StyleBox["c", "Code"],
 ". Each loop can range from 0 to the floor of ",
 Cell[BoxData[
  FormBox[
   SqrtBox["n"], TraditionalForm]],ExpressionUUID->
  "f8188188-603c-4223-95ec-edf909c17790"],
 " (the floor of a number is the largest integer that is less than or equal \
to the number). Note that these bounds are sufficient to guarantee that if ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "24725c93-4145-4ece-8bc9-fec00afe5514"],
 " can be written as the sum of the squares of three integers, then this \
procedure will find them. We observe that 3, the counterexample from Example \
15, can be written as the sum of three squares."
}], "Text",ExpressionUUID->"49e148c7-9b2f-45c1-93a5-1376ee500842"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"find3squares", "[", "3", "]"}]], "Input",
 CellLabel->
  "In[172]:=",ExpressionUUID->"e735fa90-d6a8-4e80-8689-00cdcf138305"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"1", ",", "1", ",", "1"}], "}"}]], "Output",
 CellLabel->
  "Out[172]=",ExpressionUUID->"081934df-b589-4d68-a07c-32b742cb3e3f"]
}, Open  ]],

Cell[TextData[{
 "To find a counterexample to the claim that ",
 "\[OpenCurlyDoubleQuote]Every positive integer is the sum of the squares of \
three integers,\[CloseCurlyDoubleQuote] we write a function that, starting \
with 1, tests numbers using ",
 StyleBox["find3squares", "Code"],
 " until a value is found that causes it to return false."
}], "Text",ExpressionUUID->"4a17aa5a-8baa-4018-b85d-16e22a005a19"],

Cell[BoxData[
 RowBox[{"find3counter", ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"n", "=", "1"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"While", "[", 
      RowBox[{
       RowBox[{
        RowBox[{"find3squares", "[", "n", "]"}], "=!=", "False"}], ",", 
       RowBox[{"n", "++"}]}], "]"}], ";", "\[IndentingNewLine]", "n"}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[173]:=",ExpressionUUID->"1c87f228-b4df-426b-9c82-a7c8ea44d40a"],

Cell["\<\
First, note that this \[OpenCurlyDoubleQuote]function\[CloseCurlyDoubleQuote] \
does not take an argument, so we will not use brackets when we execute it.\
\>", "Text",ExpressionUUID->"d5a8d1b1-b56e-4000-b656-40a66a48db39"],

Cell[TextData[{
 "Moreover, note that the ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop is controlled by the return value of ",
 StyleBox["find3squares", "Code"],
 ". This is a fairly common approach when you are looking for an input value \
that will cause another function to return a desired result. As before, when \
comparing nonnumerical objects, we use ",
 StyleBox[ButtonBox["UnsameQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/UnsameQ"], "FunctionLink"],
 " (",
 StyleBox["=!=", "Code"],
 ")."
}], "Text",ExpressionUUID->"2051935b-2ae4-4803-b5c2-7d2e178f21b9"],

Cell["\<\
To find the counterexample, all we need to do is to call the function.\
\>", "Text",ExpressionUUID->"57e48b89-ec4e-4c53-bcee-b90fb1c9d9fa"],

Cell[CellGroupData[{

Cell[BoxData["find3counter"], "Input",
 CellLabel->
  "In[174]:=",ExpressionUUID->"e7e0e15b-8165-456b-b14e-8f0dcf384dea"],

Cell[BoxData["7"], "Output",
 CellLabel->
  "Out[174]=",ExpressionUUID->"5bfdf293-f8de-42a5-81b5-c27c0731e66a"]
}, Open  ]],

Cell["\<\
This indicates that 7 is an integer that is not the sum of the squares of \
three integers.\
\>", "Text",ExpressionUUID->"4379f5b3-c0cd-4891-a57b-8e6d161b2a5e"],

Cell[TextData[{
 "Let us take a step back and review what we did. Our goal was to disprove \
the statement ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["\[ForAll]", "n"], 
    RowBox[{"P", "(", "n", ")"}]}], TraditionalForm]],ExpressionUUID->
  "33be842f-6a24-4457-b323-e4bf02feb175"],
 ", where ",
 Cell[BoxData[
  FormBox[
   RowBox[{"P", "(", "n", ")"}], TraditionalForm]],ExpressionUUID->
  "3045166d-67e5-476b-a291-8f9793773691"],
 " is the statement that \[OpenCurlyDoubleQuote]",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "3ead95a0-31ff-4299-8d66-3f588b24c1e0"],
 " can be written as the sum of the squares of three integers.\
\[CloseCurlyDoubleQuote] We first wrote ",
 StyleBox["find3squares", "Code"],
 ", which is a function whose goal is to find three integers whose squares \
sum to its argument. Observe that if ",
 StyleBox["find3squares", "Code"],
 " returns three values for a given ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "05ef64d4-d100-47fa-8973-a311e8f7db11"],
 ", then we know ",
 Cell[BoxData[
  FormBox[
   RowBox[{"P", "(", "n", ")"}], TraditionalForm]],ExpressionUUID->
  "e92d70fb-db36-4fab-a57d-3d1f1b95e069"],
 " is true for that ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "bf1b0719-78c2-4e78-b1b6-75485a59f719"],
 ". Only after we wrote the ",
 StyleBox["find3squares", "Code"],
 " function did we write ",
 StyleBox["find3counter", "Code"],
 ", whose task was to find a counterexample to the universal statement in \
question. This is a common strategy when using a computer to find a \
counterexample\[LongDash]write a program that seeks to verify the ",
 Cell[BoxData[
  FormBox[
   RowBox[{"P", "(", "n", ")"}], TraditionalForm]],ExpressionUUID->
  "89c3e288-fcd0-449e-a213-ae69147fdfac"],
 " statement for input ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "c2f31426-d11b-4419-bb71-8c9da22aa253"],
 " and then look to find a value of ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "4c73cb2e-d3f7-492d-b153-bfcdb0e8a5e6"],
 " that causes the program to fail."
}], "Text",ExpressionUUID->"d12ddd17-5e87-4c6e-81f3-fe32414281f4"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Proof", "Subsection",
 CellTags->"Section7b",ExpressionUUID->"5b91512a-700d-41ea-bb4f-278a5b7bb292"],

Cell["\<\
We have not yet actually disproved the statement that \
\[OpenCurlyDoubleQuote]Every positive integer is the sum of the squares of \
three integers.\[CloseCurlyDoubleQuote] The functions we wrote found a \
candidate for a counterexample, but we do not yet know for sure that it is in \
fact a counterexample (after all, our program could be flawed). To prove the \
statement is false, we must prove that 7 is in fact a counterexample. We can \
approach this in one of two ways. The first approach is to follow the \
solution to Example 17 in Section 1.8 of the text.\
\>", "Text",ExpressionUUID->"ed18ce04-1080-43d0-bb16-4c1e55f17b74"],

Cell[TextData[{
 "The alternative approach is to prove the correctness of our algorithm. \
Specifically, we need to prove the statement: \[OpenCurlyDoubleQuote]The \
positive integer ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "5583ff43-659b-4ffa-bcd9-3f4f784aad3f"],
 " can be written as the sum of the squares of three integers if and only if ",
 Cell["find3squares[n]", "myCode",ExpressionUUID->
  "8564c5ee-ce8b-468c-9cf1-466332cc7b75"],
 " returns a list of three integers.\[CloseCurlyDoubleQuote] We now prove \
this biconditional."
}], "Text",ExpressionUUID->"6a867a18-4acf-48bf-99fb-5c4b574027bc"],

Cell[TextData[{
 "We first prove the statement: if the positive integer ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "7d4281c7-e3c2-48b1-a5b2-dda8294fbc59"],
 " can be written as the sum of the squares of three integers, then ",
 Cell["find3squares[n]", "myCode",ExpressionUUID->
  "d2845003-9ccc-423c-af96-70f318eb27b8"],
 " returns a list of three integers. We use a direct proof. Assume that ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "6590150a-9dde-4736-8d25-10d2c8cd57f4"],
 " can be written as the sum of three squares. Say ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "=", 
    RowBox[{
     SuperscriptBox["a", "2"], "+", 
     SuperscriptBox["b", "2"], "+", 
     SuperscriptBox["c", "2"]}]}], TraditionalForm]],ExpressionUUID->
  "d7c3c07a-60d4-4b39-b287-c0cf3cf57011"],
 " for integers ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "34a601ef-9290-4630-a6ec-ae394c40f5dc"],
 ", ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "2b5e8fc9-bc63-44c0-8428-665875a7fab1"],
 ", and ",
 Cell[BoxData[
  FormBox["c", TraditionalForm]],ExpressionUUID->
  "e83f79b9-f700-40be-8fef-ed792644ef91"],
 ". Note that we may take ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "da364892-3420-472a-986c-dd6049cb62eb"],
 ", ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "66458ce7-1794-42dc-b387-7895d3df0f12"],
 ", and ",
 Cell[BoxData[
  FormBox["c", TraditionalForm]],ExpressionUUID->
  "48b6b32f-57a7-4959-99d1-d8bf982101e3"],
 " to be nonnegative integers, since an integer and its negative have the \
same square. In addition, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "=", 
    RowBox[{
     RowBox[{
      SuperscriptBox["a", "2"], "+", 
      SuperscriptBox["b", "2"], "+", 
      SuperscriptBox["c", "2"]}], "\[GreaterEqual]", 
     SuperscriptBox["a", "2"]}]}], TraditionalForm]],ExpressionUUID->
  "3d175cf4-603c-4826-a7ed-2268bba24aa7"],
 ". Thus, ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "\[GreaterEqual]", 
    SuperscriptBox["a", "2"]}], TraditionalForm]],ExpressionUUID->
  "f1de569e-05c6-43a2-886f-4b2404edb5fc"],
 " and ",
 Cell[BoxData[
  FormBox[
   RowBox[{"a", "\[GreaterEqual]", "0"}], TraditionalForm]],ExpressionUUID->
  "09674036-ead1-4b48-a9b6-86b7189ec796"],
 ", which means that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"a", "\[LessEqual]", 
    SqrtBox["n"]}], TraditionalForm]],ExpressionUUID->
  "2d1c77fe-97fa-4918-8dbf-dc5d6c68d5f0"],
 ". Since ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "67fa0e00-77bd-486a-a87e-e05bc19485a2"],
 " is an integer and is less than or equal to the square root of ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "c5a09de0-d417-4854-ae49-04fe24a0b0a2"],
 ", ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "956fae74-d6ec-4972-83cf-fb89520968fa"],
 " must be less than or equal to the floor of ",
 Cell[BoxData[
  FormBox[
   SqrtBox["n"], TraditionalForm]],ExpressionUUID->
  "989b7fd3-534e-4f5a-905e-0bd8d9c6cd39"],
 " since the floor of a real number is the greatest integer less than or \
equal to the real number. The same argument applies to ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "15ddb9c6-9139-4d94-ba88-c0c090f16c08"],
 " and ",
 Cell[BoxData[
  FormBox["c", TraditionalForm]],ExpressionUUID->
  "cf78b028-5681-4025-995c-e2700140ae09"],
 ". We started with ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "=", 
    RowBox[{
     SuperscriptBox["a", "2"], "+", 
     SuperscriptBox["b", "2"], "+", 
     SuperscriptBox["c", "2"]}]}], TraditionalForm]],ExpressionUUID->
  "6f23fa56-6d7d-4d82-a2fa-da86ac68440a"],
 " and have now shown that ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "7f240830-abf0-4f19-b778-d0d28c262bff"],
 ", ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "baa11886-6aee-4c75-aa91-f1f3ee6da48c"],
 ", and ",
 Cell[BoxData[
  FormBox["c", TraditionalForm]],ExpressionUUID->
  "08ba13b0-b66b-4229-bda8-ea65b471ba21"],
 " can be assumed to be nonnegative integers and must be less than or equal \
to the floor of the square root of ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "e9504fb6-dff7-4e38-b2b0-6e7369e161c6"],
 ". The nested for loops in ",
 StyleBox["find3squares", "Code"],
 " set ",
 StyleBox["a", "Code"],
 ", ",
 StyleBox["b", "Code"],
 ", and ",
 StyleBox["c", "Code"],
 " equal to every possible combination of integers between 0 and ",
 StyleBox["max", "Code"],
 ", which is the floor of the square root of ",
 StyleBox["n", "Code"],
 ". Hence, ",
 StyleBox["a", "Code"],
 ", ",
 StyleBox["b", "Code"],
 ", and ",
 StyleBox["c", "Code"],
 " must, at some point during the execution of ",
 StyleBox["find3squares", "Code"],
 ", be set to ",
 Cell[BoxData[
  FormBox["a", TraditionalForm]],ExpressionUUID->
  "fe7371e6-947a-4b68-9d2f-982b75fa3621"],
 ", ",
 Cell[BoxData[
  FormBox["b", TraditionalForm]],ExpressionUUID->
  "1a547992-aed3-48fd-bdcf-a4dd27b75770"],
 ", and ",
 Cell[BoxData[
  FormBox["c", TraditionalForm]],ExpressionUUID->
  "4c3dae18-1dda-429e-8cea-1f1ca003bfae"],
 ", and thus the condition that ",
 Cell[BoxData[
  RowBox[{"n", "\[Equal]", 
   RowBox[{
    RowBox[{"a", "^", "2"}], "+", 
    RowBox[{"b", "^", "2"}], "+", 
    RowBox[{"c", "^", "2"}]}]}]], "myCode",ExpressionUUID->
  "a8844d8f-de90-400c-aaed-518a15fddf53"],
 " will be satisfied and ",
 Cell[BoxData[
  RowBox[{"{", "a", ",", "b", ",", "c", "}"}]], "myCode",ExpressionUUID->
  "a9cf5ff6-2a43-4361-8c20-fb128b06a78c"],
 " will be returned by the function. We have assumed that ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "1d9057c3-52b8-4602-a2c2-f2a4a9844a62"],
 " can be written as the sum of three squares and concluded that ",
 Cell["find3squares[n]", "myCode",ExpressionUUID->
  "ea28eb1c-091c-4787-8edf-8dfefc4c0542"],
 " must return the list of the integers."
}], "Text",ExpressionUUID->"aaa9ad2c-a178-44c2-8247-7507e30c3fb0"],

Cell[TextData[{
 "The converse is that if ",
 Cell["find3squares[n]", "myCode",ExpressionUUID->
  "909c0c59-763d-41d8-afd7-fb390880f259"],
 " returns a list of three integers, then ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "3c6969d9-09fb-4f5c-9081-768234330a18"],
 " can be written as the sum of the squares of three integers. This is nearly \
obvious, since if ",
 Cell["find3squares[n]", "myCode",ExpressionUUID->
  "25b8a558-d787-4c58-b8d7-2fd9ea296e1f"],
 " returns ",
 Cell[BoxData[
  RowBox[{"{", "a", ",", "b", ",", "c", "}"}]], "myCode",ExpressionUUID->
  "fcdd79bc-d0c2-4267-83a2-656db15f1516"],
 ", it must have been because ",
 Cell[BoxData[
  RowBox[{"n", "\[Equal]", 
   RowBox[{
    RowBox[{"a", "^", "2"}], "+", 
    RowBox[{"b", "^", "2"}], "+", 
    RowBox[{"c", "^", "2"}]}]}]], "myCode",ExpressionUUID->
  "94e4ea36-39ae-479a-9260-0e0b8618b1c0"],
 " was found to be true."
}], "Text",ExpressionUUID->"034c0b5d-31ed-42b0-af1e-9d5b1d95c2cc"],

Cell[TextData[{
 "Therefore, the ",
 StyleBox["find3squares", "Code"],
 " procedure is correct, and since ",
 Cell["find3squares[n]", "myCode",ExpressionUUID->
  "981fb55e-0614-4751-98c4-0dbe884c545e"],
 " returns false, we can conclude that 7 is, in fact, a counterexample to the \
assertion that every positive integer is the sum of the squares of three \
integers."
}], "Text",ExpressionUUID->"500ee821-93ed-40d1-ae7d-19c3135ab35e"],

Cell["\<\
We will typically not be proving the correctness of procedures in this \
manual. The above merely serves to illustrate how you can approach such a \
proof and to reinforce the principle that just because a program produces \
output does not guarantee that the program or the output is correct. For more \
about this topic, refer to Section 5.5 of the main text.\
\>", "Text",ExpressionUUID->"6b0ca991-dc94-487d-81b9-3ce6773ce830"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["1.8 Proof Methods and Strategy", "Section",
 CellTags->"Section8",ExpressionUUID->"5d2577e6-7ebe-4b05-847f-864155adbfb9"],

Cell[TextData[{
 "In this section, we will consider two additional proof techniques that ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 " can assist with: exhaustive proofs and existence proofs."
}], "Text",ExpressionUUID->"8d24c167-b932-401c-b05e-76ec874d945b"],

Cell[CellGroupData[{

Cell["Exhaustive Proof", "Subsection",
 CellTags->"Section8a",ExpressionUUID->"25ef834a-f737-40ac-9540-62433ce5153a"],

Cell[TextData[{
 "In an exhaustive proof, we must check all possibilities. For an exhaustive \
proof to be feasible by hand, there must be a fairly small number of \
possibilities. With computer software such as ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ", though, the number of possibilities can be greatly expanded. Consider \
Example 2 from Section 1.8 of the text. There it was determined by hand that \
the only consecutive positive integers not exceeding 100 that are perfect \
powers are 8 and 9."
}], "Text",ExpressionUUID->"8361d0c9-edbb-47d8-9d88-09452d9e2137"],

Cell[TextData[{
 "We will consider a variation of this problem: prove that the only \
consecutive positive integers not exceeding ",
 Cell[BoxData[
  FormBox["100000000", TraditionalForm]],ExpressionUUID->
  "c0aadaf0-3a17-4d2e-82f7-2377ca067b68"],
 " that are perfect powers are 8 and 9."
}], "Text",ExpressionUUID->"c74367d7-5d14-4c12-a2f8-6b24c998a2d1"],

Cell[TextData[{
 "Our approach will be the same as was used in the text. We will generate all \
the perfect powers not exceeding the maximum value and then we will check to \
see which of the perfect powers occur as a consecutive pair. We will \
implement this strategy with two procedures. The first function, ",
 StyleBox["findPowers", "Code"],
 ", will accept as an argument the maximum value to consider (e.g., 100) and \
will return all of the perfect powers no greater than that maximum. The \
second function, ",
 StyleBox["findConsecutivePowers", "Code"],
 ", will also accept the maximum value as its input. It will use ",
 StyleBox["findPowers", "Code"],
 " to generate the powers and then check them for consecutive pairs."
}], "Text",ExpressionUUID->"45f5b6bb-587d-4381-88f0-ad7acc05848f"],

Cell[TextData[{
 "For the first function, ",
 StyleBox["findPowers", "Code"],
 ", we need to generate all perfect powers up to the given limit. To do this, \
we will use a nested pair of loops for the exponent (",
 StyleBox["p", "Code"],
 ") and the base (",
 StyleBox["b", "Code"],
 "). Each of the loops will be a ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop controlled by a Boolean variable, ",
 StyleBox["continuep", "Input",
  IgnoreSpellCheck->True],
 " and ",
 StyleBox["continueb", "Input",
  IgnoreSpellCheck->True],
 ". In the inner loop, we check to see if ",
 StyleBox["b^p", "Code"],
 " is greater than the limit, ",
 StyleBox["n", "Code"],
 ", given as the input to the function. If it is, then we set ",
 StyleBox["continueb", "Input",
  IgnoreSpellCheck->True],
 " to false, which terminates the inner loop, and if not, we add ",
 StyleBox["b^p", "Code"],
 " to the list of perfect powers, ",
 StyleBox["L", "Code"],
 ", and increment ",
 StyleBox["b", "Code"],
 ". Once the inner ",
 StyleBox["b", "Code"],
 " loop has terminated, we increment the power ",
 StyleBox["p", "Code"],
 ". If ",
 StyleBox["2^p", "Code"],
 " exceeds the limit, then we know that no more exponents need to be checked \
and we terminate the outer loop by setting ",
 StyleBox["continuep", "Input",
  IgnoreSpellCheck->True],
 " to false."
}], "Text",ExpressionUUID->"b2e01b20-95ef-4828-81d9-30ad8131f357"],

Cell[BoxData[
 RowBox[{
  RowBox[{"findPowers", "[", "n_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"L", "=", 
       RowBox[{"{", "}"}]}], ",", "b", ",", 
      RowBox[{"p", "=", "2"}], ",", 
      RowBox[{"continuep", "=", "True"}], ",", "continueb"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"While", "[", 
      RowBox[{"continuep", ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"b", "=", "1"}], ";", "\[IndentingNewLine]", 
        RowBox[{"continueb", "=", "True"}], ";", "\[IndentingNewLine]", 
        RowBox[{"While", "[", 
         RowBox[{"continueb", ",", "\[IndentingNewLine]", 
          RowBox[{"If", "[", 
           RowBox[{
            RowBox[{
             RowBox[{"b", "^", "p"}], ">", "n"}], ",", 
            RowBox[{"continueb", "=", "False"}], ",", 
            RowBox[{
             RowBox[{"AppendTo", "[", 
              RowBox[{"L", ",", 
               RowBox[{"b", "^", "p"}]}], "]"}], ";", 
             RowBox[{"b", "++"}]}]}], "]"}]}], "\[IndentingNewLine]", "]"}], 
        ";", "\[IndentingNewLine]", 
        RowBox[{"p", "++"}], ";", "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{
          RowBox[{
           RowBox[{"2", "^", "p"}], ">", "n"}], ",", 
          RowBox[{"continuep", "=", "False"}]}], "]"}]}]}], 
      "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
     RowBox[{"Union", "[", "L", "]"}]}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[175]:=",ExpressionUUID->"12ccf089-a4ac-45a9-918b-bc9349b34335"],

Cell[TextData[{
 "Note that the ",
 StyleBox[ButtonBox["Union",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Union"], "FunctionLink"],
 " function, applied to a single list, returns the list sorted and with \
duplicates removed",
 ". ",
 "We confirm that the list of powers produced by this algorithm is the same \
as the powers considered in Example 2 from the text."
}], "Text",ExpressionUUID->"5b064910-0274-48f7-9b7b-615134d7b32c"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"findPowers", "[", "100", "]"}]], "Input",
 CellLabel->
  "In[176]:=",ExpressionUUID->"af866d32-98e1-49cd-b6b1-2deaf87b2a82"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "1", ",", "4", ",", "8", ",", "9", ",", "16", ",", "25", ",", "27", ",", 
   "32", ",", "36", ",", "49", ",", "64", ",", "81", ",", "100"}], 
  "}"}]], "Output",
 CellLabel->
  "Out[176]=",ExpressionUUID->"42225575-9a0c-4c31-bd38-a4c98b4acd24"]
}, Open  ]],

Cell[TextData[{
 "The second function, ",
 StyleBox["findConsecutivePowers", "Code"],
 ", begins by calling ",
 StyleBox["findPowers", "Code"],
 " and storing the list of perfect powers as ",
 StyleBox["powers", "Code"],
 ". Then, we use a ",
 StyleBox[ButtonBox["Do",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Do"], "FunctionLink"],
 " loop with second argument ",
 StyleBox["{x,powers}", "Code"],
 ". This sets the variable ",
 StyleBox["x", "Code"],
 " equal to each element of the list ",
 StyleBox["powers", "Code"],
 ". In our procedure, this means that ",
 StyleBox["x", "Code"],
 " is set to each of the perfect powers in turn. In the body of the loop, we \
check to see if the next consecutive integer, ",
 StyleBox["x+1", "Code"],
 ", is also a perfect power using the ",
 StyleBox[ButtonBox["MemberQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MemberQ"], "FunctionLink"],
 " function. The ",
 StyleBox[ButtonBox["MemberQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MemberQ"], "FunctionLink"],
 " function requires two arguments. The first argument is a list to search \
and the second argument specifies what is being sought. When we find \
consecutive perfect powers, we ",
 StyleBox[ButtonBox["Print",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Print"], "FunctionLink"],
 " them. "
}], "Text",ExpressionUUID->"cffa194a-b080-48b7-9794-0911927dfb8a"],

Cell[BoxData[
 RowBox[{
  RowBox[{"findConsecutivePowers", "[", "n_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{"powers", ",", "x"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"powers", "=", 
      RowBox[{"findPowers", "[", "n", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"Do", "[", 
      RowBox[{
       RowBox[{"If", "[", 
        RowBox[{
         RowBox[{"MemberQ", "[", 
          RowBox[{"powers", ",", 
           RowBox[{"x", "+", "1"}]}], "]"}], ",", 
         RowBox[{"Print", "[", 
          RowBox[{"x", ",", "\"\< \>\"", ",", 
           RowBox[{"x", "+", "1"}]}], "]"}]}], "]"}], ",", 
       RowBox[{"{", 
        RowBox[{"x", ",", "powers"}], "}"}]}], "]"}]}]}], 
   "\[IndentingNewLine]", "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[177]:=",ExpressionUUID->"286890b6-8ea6-409a-9be1-b731d7c378ce"],

Cell[TextData[{
 "Subject to the correctness of our procedures, we can demonstrate that the \
only consecutive perfect powers less than ",
 Cell[BoxData[
  FormBox["100000000", TraditionalForm]],ExpressionUUID->
  "fb5239bd-7863-4c2f-aab3-01762b7da06f"],
 " are 8 and 9 by running the function."
}], "Text",ExpressionUUID->"16c77cfc-a202-4eb8-8743-e6c1e0efca81"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"findConsecutivePowers", "[", "100000000", "]"}]], "Input",
 CellLabel->
  "In[178]:=",ExpressionUUID->"179419a0-c55c-40bf-ab72-59ab99f8c512"],

Cell[BoxData[
 InterpretationBox[
  RowBox[{"8", "\[InvisibleSpace]", "\<\" \"\>", "\[InvisibleSpace]", "9"}],
  SequenceForm[8, " ", 9],
  Editable->False]], "Print",
 CellLabel->
  "During evaluation of \
In[178]:=",ExpressionUUID->"68f385bd-05a6-4527-936d-630b95d3f4d5"]
}, Open  ]],

Cell[TextData[{
 "It is worth pointing out that in fact, 8 and 9 are the only consecutive \
perfect powers. That assertion was conjectured by ",
 StyleBox["Eug\[EAcute]ne",
  IgnoreSpellCheck->True],
 " Charles Catalan in 1844 and was finally proven in 2002 by ",
 StyleBox["Preda",
  IgnoreSpellCheck->True],
 " Mih\[ACup]ilescu."
}], "Text",ExpressionUUID->"88bbf723-aaad-4182-8bee-ca51012a3837"]
}, Open  ]],

Cell[CellGroupData[{

Cell["Existence Proofs", "Subsection",
 CellTags->"Section8b",ExpressionUUID->"071f504d-87ac-4c0e-8ded-e5ae18d17d68"],

Cell[TextData[{
 "Proofs of existence can also benefit from ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 ". Consider Example 10 in Section 1.8 of the text. This example asks, \
\[OpenCurlyDoubleQuote]Show that there is a positive integer that can be \
written as the sum of cubes of positive integers in two different ways.\
\[CloseCurlyDoubleQuote] The solution reports that 1729 is such an integer \
and indicates that a computer search was used to find that value. Let us see \
how this can be done."
}], "Text",ExpressionUUID->"c713bc56-8db1-4aef-8752-a75bda46ac03"],

Cell[TextData[{
 "The basic idea will be to generate numbers that can be written as the sum \
of cubes. If we generate a number twice, that will tell us that the number \
can be written as the sum of cubes in two different ways. We will create a \
list ",
 StyleBox["L", "Code"],
 " and every time we generate a new sum of two cubes, we check to see if that \
number is already in ",
 StyleBox["L", "Code"],
 " using the ",
 StyleBox[ButtonBox["MemberQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/MemberQ"], "FunctionLink"],
 " function. If the new value is already in ",
 StyleBox["L", "Code"],
 ", then that is the number we are looking for. Otherwise, we add the new \
number to ",
 StyleBox["L", "Code"],
 " and generate a new sum of two cubes."
}], "Text",ExpressionUUID->"3ca39aa3-931a-4b6c-b965-4e19664d0631"],

Cell[TextData[{
 "We generate the sums of cubes with two nested loops that control integers \
",
 StyleBox["a", "Code"],
 " and ",
 StyleBox["b", "Code"],
 ". The inner loop will be a ",
 StyleBox[ButtonBox["For",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/For"], "FunctionLink"],
 " loop that causes ",
 StyleBox["b", "Code"],
 " to range from ",
 StyleBox["1", "Code"],
 " to the value of ",
 StyleBox["a", "Code"],
 ". Using ",
 StyleBox["a", "Code"],
 " as the maximum value means that ",
 StyleBox["b", "Code"],
 " will always be less than or equal to ",
 StyleBox["a", "Code"],
 " and so the procedure will not falsely report results arising from \
commutativity of addition (e.g., ",
 Cell[BoxData[
  FormBox[
   RowBox[{"9", "=", 
    RowBox[{
     RowBox[{
      SuperscriptBox["2", "3"], "+", 
      SuperscriptBox["1", "3"]}], "=", 
     RowBox[{
      SuperscriptBox["1", "3"], "+", 
      SuperscriptBox["2", "3"]}]}]}], TraditionalForm]],ExpressionUUID->
  "586d4ebb-a75e-481b-847f-52a2b6f1efe0"],
 "). The outer loop will be a ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop with condition (first argument) ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 ". The value of ",
 StyleBox["a", "Code"],
 " will be initialized to 1 and incremented by 1 after the inner ",
 StyleBox["b", "Code"],
 " loop completes. The ",
 StyleBox[ButtonBox["While",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/While"], "FunctionLink"],
 " loop in this case is called an infinite loop because it will never stop on \
its own. When the function finds an integer which can be written as the sum \
of cubes in two different ways, the function will ",
 StyleBox[ButtonBox["Throw",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Throw"], "FunctionLink"],
 " that value. That ends the loop and is sent to the ",
 StyleBox[ButtonBox["Catch",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Catch"], "FunctionLink"],
 ", which encompasses the entire body. The infinite loop means that the value \
of ",
 StyleBox["a", "Code"],
 " will continue getting larger and larger with no upper bound. This is \
useful because we do not know how large the numbers will need to be in order \
to find the example. However, infinite loops should be used with caution, \
especially if you are not certain that the procedure will terminate in a \
reasonable amount of time."
}], "Text",ExpressionUUID->"003218bb-abca-40df-93ef-56772d7f3b14"],

Cell["Here is the function and its result.", "Text",ExpressionUUID->"1e8407e0-4c8d-4d47-a89d-53f0f2dcfebf"],

Cell[BoxData[
 RowBox[{"twoCubes", ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"L", "=", 
       RowBox[{"{", "}"}]}], ",", 
      RowBox[{"a", "=", "1"}], ",", "b", ",", "n"}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{"Catch", "[", "\[IndentingNewLine]", 
     RowBox[{"While", "[", 
      RowBox[{"True", ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"For", "[", 
         RowBox[{
          RowBox[{"b", "=", "1"}], ",", 
          RowBox[{"b", "\[LessEqual]", "a"}], ",", 
          RowBox[{"b", "++"}], ",", "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"n", "=", 
            RowBox[{
             RowBox[{"a", "^", "3"}], "+", 
             RowBox[{"b", "^", "3"}]}]}], ";", "\[IndentingNewLine]", 
           RowBox[{"If", "[", 
            RowBox[{
             RowBox[{"MemberQ", "[", 
              RowBox[{"L", ",", "n"}], "]"}], ",", 
             RowBox[{"Throw", "[", "n", "]"}], ",", 
             RowBox[{"AppendTo", "[", 
              RowBox[{"L", ",", "n"}], "]"}]}], "]"}]}]}], 
         "\[IndentingNewLine]", "]"}], ";", "\[IndentingNewLine]", 
        RowBox[{"a", "++"}]}]}], "\[IndentingNewLine]", "]"}], "]"}]}], 
   "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[179]:=",ExpressionUUID->"266a20da-7396-449c-b4a1-9110f554cd74"],

Cell[CellGroupData[{

Cell[BoxData["twoCubes"], "Input",
 CellLabel->
  "In[180]:=",ExpressionUUID->"91dfe631-a752-4d74-baea-18663e18093b"],

Cell[BoxData["1729"], "Output",
 CellLabel->
  "Out[180]=",ExpressionUUID->"ce76a974-b9aa-457d-b858-9a2c8b337450"]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["\<\
Solutions to Computer Projects and Computations and Explorations\
\>", "Section",
 CellTags->"Solutions",ExpressionUUID->"09a943cc-d17b-479d-aedd-574567ffe38f"],

Cell[CellGroupData[{

Cell["Computer Projects 3", "Subsection",
 CellTags->
  "SolutionsCP3",ExpressionUUID->"026465c8-9bc9-4ddc-8018-06a0a9dd7aab"],

Cell["\<\
Given a compound proposition, determine whether it is satisfiable by checking \
its truth value for all positive assignments of truth values to its \
propositional variables.\
\>", "Problem",ExpressionUUID->"95975f1c-a365-4c44-bfdd-bdfa6403909d"],

Cell[TextData[{
 StyleBox["Solution:",
  FontSlant->"Italic"],
 " Recall that a proposition is satisfiable if there is at least one \
assignment of truth values to variables that results in a true proposition. \
Our approach will be similar to the way we checked for logical equivalence in \
the ",
 StyleBox["myEquivalentQ", "Code"],
 " function in Section 1.3. Note, of course, that the Wolfram Language \
provides a built-in function, ",
 StyleBox[ButtonBox["SatisfiableQ",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/SatisfiableQ"], "FunctionLink"],
 ", that performs this function. The goal of this exercise is to see how such \
a function might be implemented."
}], "Text",ExpressionUUID->"034c5eb9-12a2-49e2-bf77-8ba6936cb8ae"],

Cell[TextData[{
 "We create a function, ",
 StyleBox["mySatisfiableQ", "Code"],
 ", that checks all possible assignments of truth values to the propositional \
variables. The ",
 StyleBox["mySatisfiableQ", "Code"],
 " function accepts one argument, a logical expression. It will print out \
all, if any, truth value assignments that satisfy the proposition. We will \
initialize a ",
 StyleBox["result", "Code"],
 " variable to ",
 StyleBox[ButtonBox["False",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/False"], "FunctionLink"],
 ". When an assignment that satisfies the proposition is found, this variable \
is set to ",
 StyleBox[ButtonBox["True",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/True"], "FunctionLink"],
 " and the assignment is printed. After all possible assignments are \
considered, the function returns the ",
 StyleBox["result", "Code"],
 " variable."
}], "Text",ExpressionUUID->"743b96c4-e30f-40cc-9de8-d0753f49df6b"],

Cell[TextData[{
 "Since this function is otherwise very similar to ",
 StyleBox["myEquivalentQ", "Code"],
 ", we offer no further explanation."
}], "Text",ExpressionUUID->"d597577a-4b53-43c3-a885-4eaf0cead99e"],

Cell[BoxData[
 RowBox[{
  RowBox[{"mySatisfiableQ", "[", "p_", "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"result", "=", "False"}], ",", "vars", ",", "numVars", ",", 
      "TA", ",", "val"}], "}"}], ",", "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"vars", "=", 
      RowBox[{"getVars", "[", "p", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"numVars", "=", 
      RowBox[{"Length", "[", "vars", "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"TA", "=", 
      RowBox[{"ConstantArray", "[", 
       RowBox[{"False", ",", "numVars"}], "]"}]}], ";", "\[IndentingNewLine]", 
     RowBox[{"While", "[", 
      RowBox[{
       RowBox[{"TA", "=!=", "Null"}], ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"val", "=", 
         RowBox[{"p", "/.", 
          RowBox[{"MapThread", "[", 
           RowBox[{"Rule", ",", 
            RowBox[{"{", 
             RowBox[{"vars", ",", "TA"}], "}"}]}], "]"}]}]}], ";", 
        "\[IndentingNewLine]", 
        RowBox[{"If", "[", 
         RowBox[{"val", ",", 
          RowBox[{
           RowBox[{"result", "=", "True"}], ";", 
           RowBox[{"Print", "[", "TA", "]"}]}]}], "]"}], ";", 
        "\[IndentingNewLine]", 
        RowBox[{"TA", "=", 
         RowBox[{"nextTA", "[", "TA", "]"}]}], ";"}]}], "\[IndentingNewLine]",
       "]"}], ";", "\[IndentingNewLine]", "result"}]}], "\[IndentingNewLine]",
    "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[181]:=",ExpressionUUID->"32ced984-af76-4424-b839-8c9a76bb94ac"],

Cell["\<\
We apply this function to the propositions in Example 9 of Section 1.3 of the \
text.\
\>", "Text",ExpressionUUID->"996a2cb6-c964-4918-9fc3-d589c9a33608"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"mySatisfiableQ", "[", 
  RowBox[{
   RowBox[{"(", 
    RowBox[{"p", "||", 
     RowBox[{"!", "q"}]}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{"q", "||", 
     RowBox[{"!", "r"}]}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{"r", "||", 
     RowBox[{"!", "p"}]}], ")"}]}], "]"}]], "Input",
 CellLabel->
  "In[182]:=",ExpressionUUID->"c320feee-2663-4412-a043-eff5b25321c3"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "False", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[182]:=",ExpressionUUID->"2509f8ce-6f44-4f2c-961e-f96255f2b0e2"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "True", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[182]:=",ExpressionUUID->"e568c8a7-92e1-4e41-9928-b561aea44920"]
}, Open  ]],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[182]=",ExpressionUUID->"acc8852b-a67c-404b-a822-e138252f6897"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"mySatisfiableQ", "[", 
  RowBox[{
   RowBox[{"(", 
    RowBox[{"p", "||", "q", "||", "r"}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"!", "p"}], "||", 
     RowBox[{"!", "q"}], "||", 
     RowBox[{"!", "r"}]}], ")"}]}], "]"}]], "Input",
 CellLabel->
  "In[183]:=",ExpressionUUID->"c47b397f-ed0f-48b0-88ac-cac815eccef6"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "False", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[183]:=",ExpressionUUID->"4a988a9a-b964-41b4-9301-2aa0424020a3"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "True", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[183]:=",ExpressionUUID->"94eb0e6f-6a1f-46e9-b5bc-0f1e55a1984c"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "True", ",", "False"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[183]:=",ExpressionUUID->"d25db85c-384e-4edd-8ab1-4a34074cba51"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "False", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[183]:=",ExpressionUUID->"7b1963b9-53ad-4586-867c-a5c6815f0015"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"True", ",", "False", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[183]:=",ExpressionUUID->"12424bea-e87e-49e9-ba93-0823b0013002"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{"False", ",", "True", ",", "True"}], "}"}]], "Print",
 CellLabel->
  "During evaluation of \
In[183]:=",ExpressionUUID->"eb2ad963-ad32-4751-bad9-ee4ec55bd2f6"]
}, Open  ]],

Cell[BoxData["True"], "Output",
 CellLabel->
  "Out[183]=",ExpressionUUID->"0f44145d-e7a9-44f5-8402-c99315522fe6"]
}, Open  ]],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"mySatisfiableQ", "[", 
  RowBox[{
   RowBox[{"(", 
    RowBox[{"p", "||", 
     RowBox[{"!", "q"}]}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{"q", "||", 
     RowBox[{"!", "r"}]}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{"r", "||", 
     RowBox[{"!", "p"}]}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{"p", "||", "q", "||", "r"}], ")"}], "&&", 
   RowBox[{"(", 
    RowBox[{
     RowBox[{"!", "p"}], "||", 
     RowBox[{"!", "q"}], "||", 
     RowBox[{"!", "r"}]}], ")"}]}], "]"}]], "Input",
 CellLabel->
  "In[184]:=",ExpressionUUID->"c1f4eeac-62e8-403d-a6d3-1b44807fad9c"],

Cell[BoxData["False"], "Output",
 CellLabel->
  "Out[184]=",ExpressionUUID->"6aa7d22f-1d5f-4fd6-b684-78d71f15a6a7"]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Computations and Explorations 1", "Subsection",
 CellTags->
  "SolutionsCE1",ExpressionUUID->"fd6cf4a1-4e4c-4114-9cb4-f1ddfa8e875c"],

Cell["\<\
Look for positive integers that are not the sum of the cubes of eight \
positive integers.\
\>", "Problem",ExpressionUUID->"fa71b863-380b-4543-bba1-eea108d07e02"],

Cell[TextData[{
 StyleBox["Solution:",
  FontSlant->"Italic"],
 " We will find integers ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "77914cac-b9a1-4263-a182-2d1e493f58c0"],
 " such that ",
 Cell[BoxData[
  FormBox[
   RowBox[{"n", "\[NotEqual]", 
    RowBox[{
     SubsuperscriptBox["a", "1", "3"], "+", 
     SubsuperscriptBox["a", "2", "3"], "+", "\[CenterEllipsis]", "+", 
     SubsuperscriptBox["a", "8", "3"]}]}], TraditionalForm]],ExpressionUUID->
  "6d003a1d-9013-47dc-ae42-d7b5f4ecee13"],
 " for any integers ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubscriptBox["a", "1"], ",", 
    SubscriptBox["a", "2"], ",", "\[Ellipsis]", ",", 
    SubscriptBox["a", "8"]}], TraditionalForm]],ExpressionUUID->
  "bc883fa0-1b42-4b2d-a129-0bcee597a138"],
 ". ",
 "We can restate the problem as finding a counterexample to the assertion \
that every integer can be written as the sum of eight cubes."
}], "Text",ExpressionUUID->"62d3ccde-03fc-415d-9c31-9e22b65afd6e"],

Cell[TextData[{
 "Our approach will be to generate all of the integers that are equal to the \
sum of eight cubes and then check to see what integers are missing. We will \
set a limit ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "c0714239-0491-4aab-aefb-f3d48b6147ef"],
 ", that is, the maximum integer that we are considering as a possible answer \
to the question. For instance, we might restrict our search to integers less \
than 100. Then, we know that each ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["a", "i"], TraditionalForm]],ExpressionUUID->
  "a7c0b868-5fd8-49f1-8845-0df1b447b7c6"],
 " is at most the cube root of this limit, since ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SubsuperscriptBox["a", "i", "3"], "\[LessEqual]", "n"}], 
   TraditionalForm]],ExpressionUUID->"293e2c17-99b9-4def-9c34-26083eb59b66"],
 "."
}], "Text",ExpressionUUID->"2c91ace3-bfcc-4f69-b63e-be6a09a47ee0"],

Cell["\<\
We will also want to make our approach as efficient as possible in order to \
find as many such integers as we can. We make the following observations.\
\>", "Text",ExpressionUUID->"50fba01e-1e12-4b56-9f36-a075af3a91ef"],

Cell["\<\
Every number that can be expressed as the sum of eight cubes can be expressed \
as the sum of two integers each of which is the sum of four cubes. Those, in \
turn, can be expressed as the sum of two integers which are the sum of two \
cubes each. That is,\
\>", "Text",ExpressionUUID->"70d63c11-2a57-465e-9bbd-6abd18a4d069"],

Cell[BoxData[
 FormBox[
  RowBox[{"n", "=", 
   RowBox[{
    RowBox[{"[", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{
        SubsuperscriptBox["a", "1", "3"], "+", 
        SubsuperscriptBox["a", "2", "3"]}], ")"}], "+", 
      RowBox[{"(", 
       RowBox[{
        SubsuperscriptBox["a", "3", "3"], "+", 
        SubsuperscriptBox["a", "4", "3"]}], ")"}]}], "]"}], "+", 
    RowBox[{"[", 
     RowBox[{
      RowBox[{"(", 
       RowBox[{
        SubsuperscriptBox["a", "5", "3"], "+", 
        SubsuperscriptBox["a", "6", "3"]}], ")"}], "+", 
      RowBox[{"(", 
       RowBox[{
        SubsuperscriptBox["a", "7", "3"], "+", 
        SubsuperscriptBox["a", "8", "3"]}], ")"}]}], "]"}]}]}], 
  TraditionalForm]], "Equation",ExpressionUUID->"154231d9-115e-43a0-8471-\
a3097705bf0e"],

Cell[TextData[{
 "This means that we do not need to write a function to find all possible \
sums of eight cubes. Instead, we will write a function that, given a list of \
numbers, will find all possible sums of two numbers that are both in that \
list. If we apply this function to the cubes of the numbers from 0 through ",
 Cell[BoxData[
  FormBox[
   RadicalBox["n", "3"], TraditionalForm]],ExpressionUUID->
  "88ab3cad-9ea9-4cf9-9646-146be5b5eb52"],
 ", that will produce all numbers that are the sum of two cubes. Applying the \
function again to that result will give all numbers that are the sum of four \
cubes. And applying it once again to that result will produce the numbers (up \
to ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "42158b97-1a1c-44c3-a6ef-b6033961f5a7"],
 ") that are the sum of eight cubes."
}], "Text",ExpressionUUID->"4bc39f49-c52d-4444-8bb8-e68954278f64"],

Cell[TextData[{
 "Additionally, when we find all the possible sums of two integers, we will \
exclude any sum that exceeds our maximum. Recall that we have determined that \
if an integer less than or equal to ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "1398a57e-ffa1-4b84-9e1a-21cbfdbef083"],
 " can be written as the sum of cubes, then it can be written as the sum of \
cubes with each ",
 Cell[BoxData[
  FormBox[
   SubscriptBox["a", "i"], TraditionalForm]],ExpressionUUID->
  "061c2991-8c54-4e3a-87b7-ec299760ab59"],
 " between 0 and ",
 Cell[BoxData[
  FormBox[
   RadicalBox["n", "3"], TraditionalForm]],ExpressionUUID->
  "76d1ade5-60b7-461b-82e0-aa90d0fcbf3c"],
 ". There will be numbers greater than ",
 Cell[BoxData[
  FormBox["n", TraditionalForm]],ExpressionUUID->
  "b1be47b6-545d-4659-8bd9-49fdd405495b"],
 " that are generated as the sum of cubes of integers less than ",
 Cell[BoxData[
  FormBox[
   RadicalBox["n", "3"], TraditionalForm]],ExpressionUUID->
  "7105b849-99e5-4b30-b6f5-a5113437a1bc"],
 "; however, these do not provide us with any information about numbers that \
cannot be generated as the sum of eight cubes. Moreover, excluding them at \
each step of the process decreases the number of sums that need to be \
computed."
}], "Text",ExpressionUUID->"68f04b60-529e-491d-99d6-eb715a638fe5"],

Cell[TextData[{
 "Finally, we may assume that the second number is at least as large as the \
first",
 ". ",
 "Since if we add ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["2", "3"], "+", 
    SuperscriptBox["5", "3"]}], TraditionalForm]],ExpressionUUID->
  "03e3e7a3-eec5-483d-ba33-e23a8e4c1eb7"],
 " to our list of sums, there is no need to also include ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["5", "3"], "+", 
    SuperscriptBox["2", "3"]}], TraditionalForm]],ExpressionUUID->
  "c5aafbd1-3e6d-4184-95ab-64a115944268"],
 "."
}], "Text",ExpressionUUID->"d70facfd-01a9-4bef-9ba8-93c44e1cfd60"],

Cell[TextData[{
 "Here is the function that finds all possible sums of pairs of integers from \
the given list ",
 StyleBox["L", "Code"],
 " up to the specified maximum value ",
 StyleBox["max", "Code"],
 ". Note that we use the ",
 StyleBox[ButtonBox["Union",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Union"], "FunctionLink"],
 " function to remove redundancies and also put the list in increasing \
order."
}], "Text",ExpressionUUID->"4baa9ebd-8d8f-42f1-b8aa-7e6c9519b8d0"],

Cell[BoxData[
 RowBox[{
  RowBox[{"allPairSums", "[", 
   RowBox[{"L_", ",", "max_"}], "]"}], ":=", 
  RowBox[{"Module", "[", 
   RowBox[{
    RowBox[{"{", 
     RowBox[{
      RowBox[{"a", "=", "1"}], ",", "b", ",", "s", ",", 
      RowBox[{"sumList", "=", 
       RowBox[{"{", "}"}]}], ",", 
      RowBox[{"num", "=", 
       RowBox[{"Length", "[", "L", "]"}]}]}], "}"}], ",", 
    "\[IndentingNewLine]", 
    RowBox[{
     RowBox[{"While", "[", 
      RowBox[{
       RowBox[{"a", "\[LessEqual]", "num"}], ",", "\[IndentingNewLine]", 
       RowBox[{
        RowBox[{"b", "=", "a"}], ";", "\[IndentingNewLine]", 
        RowBox[{"While", "[", 
         RowBox[{
          RowBox[{"b", "\[LessEqual]", "num"}], ",", "\[IndentingNewLine]", 
          RowBox[{
           RowBox[{"s", "=", 
            RowBox[{
             RowBox[{"L", "[", 
              RowBox[{"[", "a", "]"}], "]"}], "+", 
             RowBox[{"L", "[", 
              RowBox[{"[", "b", "]"}], "]"}]}]}], ";", "\[IndentingNewLine]", 
           
           RowBox[{"If", "[", 
            RowBox[{
             RowBox[{"s", "\[LessEqual]", "max"}], ",", 
             RowBox[{"AppendTo", "[", 
              RowBox[{"sumList", ",", "s"}], "]"}], ",", 
             RowBox[{"b", "=", "num"}]}], "]"}], ";", "\[IndentingNewLine]", 
           RowBox[{"b", "++"}], ";"}]}], "\[IndentingNewLine]", "]"}], ";", 
        "\[IndentingNewLine]", 
        RowBox[{"a", "++"}], ";"}]}], "\[IndentingNewLine]", "]"}], ";", 
     "\[IndentingNewLine]", 
     RowBox[{"Union", "[", "sumList", "]"}]}]}], "\[IndentingNewLine]", 
   "]"}]}]], "Input",
 InitializationCell->True,
 CellLabel->
  "In[185]:=",ExpressionUUID->"96bff4b1-9f5d-4e0d-9265-ae0daec90558"],

Cell[TextData[{
 "With this function in place, we need to apply it (three times) to a list of \
cubes. We consider cubes up to ",
 Cell[BoxData[
  FormBox[
   SuperscriptBox["7", "3"], TraditionalForm]],ExpressionUUID->
  "adf56fff-33f6-4449-8005-f206a4cdd910"],
 ", including 0. The ",
 StyleBox[ButtonBox["Table",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Table"], "FunctionLink"],
 " function used below forms the list of all values obtained by evaluating \
the first argument after replacing the variable ",
 StyleBox["i", "Code"],
 " by every integer between (inclusive) the two given in the second \
argument."
}], "Text",ExpressionUUID->"07de1971-8364-4f7a-ab3d-48df2d6e7b0b"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"someCubes", "=", 
  RowBox[{"Table", "[", 
   RowBox[{
    RowBox[{"i", "^", "3"}], ",", 
    RowBox[{"{", 
     RowBox[{"i", ",", "0", ",", "7"}], "}"}]}], "]"}]}]], "Input",
 CellLabel->
  "In[186]:=",ExpressionUUID->"9bd694d6-b90d-412c-a33c-7a4539b152c1"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "0", ",", "1", ",", "8", ",", "27", ",", "64", ",", "125", ",", "216", ",", 
   "343"}], "}"}]], "Output",
 CellLabel->
  "Out[186]=",ExpressionUUID->"99c6a28b-c37f-446e-b0d5-01d15eb0bf47"]
}, Open  ]],

Cell[TextData[{
 "Applying the ",
 StyleBox["allPairSums", "Code"],
 " function once gives us all the sums of pairs of cubes (up to ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    SuperscriptBox["7", "3"], "=", "343"}], TraditionalForm]],ExpressionUUID->
  "259cfe66-6d2f-494c-9b46-48c5d12fbcc2"],
 ")."
}], "Text",ExpressionUUID->"8eb9a145-9944-4771-9d60-be282db55fbe"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"sumtwoCubes", "=", 
  RowBox[{"allPairSums", "[", 
   RowBox[{"someCubes", ",", "343"}], "]"}]}]], "Input",
 CellLabel->
  "In[187]:=",ExpressionUUID->"fd118ec4-1e28-4cf9-9aac-7c7c85ca9cd3"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "0", ",", "1", ",", "2", ",", "8", ",", "9", ",", "16", ",", "27", ",", 
   "28", ",", "35", ",", "54", ",", "64", ",", "65", ",", "72", ",", "91", 
   ",", "125", ",", "126", ",", "128", ",", "133", ",", "152", ",", "189", 
   ",", "216", ",", "217", ",", "224", ",", "243", ",", "250", ",", "280", 
   ",", "341", ",", "343"}], "}"}]], "Output",
 CellLabel->
  "Out[187]=",ExpressionUUID->"52d56bf2-109f-4404-bf2d-e0e0f21b3ddf"]
}, Open  ]],

Cell["\<\
Applying it to that result gives all possible sums of four cubes.\
\>", "Text",ExpressionUUID->"03a6f649-09c7-4b59-b69f-d363cd784031"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"sumfourCubes", "=", 
  RowBox[{"allPairSums", "[", 
   RowBox[{"sumtwoCubes", ",", "343"}], "]"}]}]], "Input",
 CellLabel->
  "In[188]:=",ExpressionUUID->"176f7d42-cd15-4452-95d4-1f46e8d5ddbf"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "8", ",", "9", ",", "10", 
   ",", "11", ",", "16", ",", "17", ",", "18", ",", "24", ",", "25", ",", 
   "27", ",", "28", ",", "29", ",", "30", ",", "32", ",", "35", ",", "36", 
   ",", "37", ",", "43", ",", "44", ",", "51", ",", "54", ",", "55", ",", 
   "56", ",", "62", ",", "63", ",", "64", ",", "65", ",", "66", ",", "67", 
   ",", "70", ",", "72", ",", "73", ",", "74", ",", "80", ",", "81", ",", 
   "82", ",", "88", ",", "89", ",", "91", ",", "92", ",", "93", ",", "99", 
   ",", "100", ",", "107", ",", "108", ",", "118", ",", "119", ",", "125", 
   ",", "126", ",", "127", ",", "128", ",", "129", ",", "130", ",", "133", 
   ",", "134", ",", "135", ",", "136", ",", "137", ",", "141", ",", "142", 
   ",", "144", ",", "145", ",", "149", ",", "152", ",", "153", ",", "154", 
   ",", "155", ",", "156", ",", "160", ",", "161", ",", "163", ",", "168", 
   ",", "179", ",", "180", ",", "182", ",", "187", ",", "189", ",", "190", 
   ",", "191", ",", "192", ",", "193", ",", "197", ",", "198", ",", "200", 
   ",", "205", ",", "206", ",", "216", ",", "217", ",", "218", ",", "219", 
   ",", "224", ",", "225", ",", "226", ",", "232", ",", "233", ",", "240", 
   ",", "243", ",", "244", ",", "245", ",", "250", ",", "251", ",", "252", 
   ",", "253", ",", "254", ",", "256", ",", "258", ",", "259", ",", "261", 
   ",", "266", ",", "270", ",", "271", ",", "277", ",", "278", ",", "280", 
   ",", "281", ",", "282", ",", "285", ",", "288", ",", "289", ",", "296", 
   ",", "297", ",", "304", ",", "307", ",", "308", ",", "314", ",", "315", 
   ",", "317", ",", "322", ",", "334", ",", "341", ",", "342", ",", "343"}], 
  "}"}]], "Output",
 CellLabel->
  "Out[188]=",ExpressionUUID->"fcd7a8bb-16a6-43a0-9a4d-754d97d490b2"]
}, Open  ]],

Cell["\<\
Once again, we obtain all integers up to 343 that can be obtained as the sum \
of eight cubes.\
\>", "Text",ExpressionUUID->"25d2d075-decc-4ffa-9ba0-206bd0eab2cc"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"sumeightCubes", "=", 
  RowBox[{"allPairSums", "[", 
   RowBox[{"sumfourCubes", ",", "343"}], "]"}]}]], "Input",
 CellLabel->
  "In[189]:=",ExpressionUUID->"28ceebdf-84d5-4df5-8641-06d2ee820aa2"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
  "0", ",", "1", ",", "2", ",", "3", ",", "4", ",", "5", ",", "6", ",", "7", 
   ",", "8", ",", "9", ",", "10", ",", "11", ",", "12", ",", "13", ",", "14", 
   ",", "15", ",", "16", ",", "17", ",", "18", ",", "19", ",", "20", ",", 
   "21", ",", "22", ",", "24", ",", "25", ",", "26", ",", "27", ",", "28", 
   ",", "29", ",", "30", ",", "31", ",", "32", ",", "33", ",", "34", ",", 
   "35", ",", "36", ",", "37", ",", "38", ",", "39", ",", "40", ",", "41", 
   ",", "42", ",", "43", ",", "44", ",", "45", ",", "46", ",", "47", ",", 
   "48", ",", "49", ",", "50", ",", "51", ",", "52", ",", "53", ",", "54", 
   ",", "55", ",", "56", ",", "57", ",", "58", ",", "59", ",", "60", ",", 
   "61", ",", "62", ",", "63", ",", "64", ",", "65", ",", "66", ",", "67", 
   ",", "68", ",", "69", ",", "70", ",", "71", ",", "72", ",", "73", ",", 
   "74", ",", "75", ",", "76", ",", "77", ",", "78", ",", "79", ",", "80", 
   ",", "81", ",", "82", ",", "83", ",", "84", ",", "85", ",", "86", ",", 
   "87", ",", "88", ",", "89", ",", "90", ",", "91", ",", "92", ",", "93", 
   ",", "94", ",", "95", ",", "96", ",", "97", ",", "98", ",", "99", ",", 
   "100", ",", "101", ",", "102", ",", "103", ",", "104", ",", "105", ",", 
   "106", ",", "107", ",", "108", ",", "109", ",", "110", ",", "111", ",", 
   "112", ",", "113", ",", "114", ",", "115", ",", "116", ",", "117", ",", 
   "118", ",", "119", ",", "120", ",", "121", ",", "122", ",", "123", ",", 
   "124", ",", "125", ",", "126", ",", "127", ",", "128", ",", "129", ",", 
   "130", ",", "131", ",", "132", ",", "133", ",", "134", ",", "135", ",", 
   "136", ",", "137", ",", "138", ",", "139", ",", "140", ",", "141", ",", 
   "142", ",", "143", ",", "144", ",", "145", ",", "146", ",", "147", ",", 
   "148", ",", "149", ",", "150", ",", "151", ",", "152", ",", "153", ",", 
   "154", ",", "155", ",", "156", ",", "157", ",", "158", ",", "159", ",", 
   "160", ",", "161", ",", "162", ",", "163", ",", "164", ",", "165", ",", 
   "166", ",", "167", ",", "168", ",", "169", ",", "170", ",", "171", ",", 
   "172", ",", "173", ",", "174", ",", "175", ",", "176", ",", "177", ",", 
   "178", ",", "179", ",", "180", ",", "181", ",", "182", ",", "183", ",", 
   "184", ",", "185", ",", "186", ",", "187", ",", "188", ",", "189", ",", 
   "190", ",", "191", ",", "192", ",", "193", ",", "194", ",", "195", ",", 
   "196", ",", "197", ",", "198", ",", "199", ",", "200", ",", "201", ",", 
   "202", ",", "203", ",", "204", ",", "205", ",", "206", ",", "207", ",", 
   "208", ",", "209", ",", "210", ",", "211", ",", "212", ",", "213", ",", 
   "214", ",", "215", ",", "216", ",", "217", ",", "218", ",", "219", ",", 
   "220", ",", "221", ",", "222", ",", "223", ",", "224", ",", "225", ",", 
   "226", ",", "227", ",", "228", ",", "229", ",", "230", ",", "231", ",", 
   "232", ",", "233", ",", "234", ",", "235", ",", "236", ",", "237", ",", 
   "238", ",", "240", ",", "241", ",", "242", ",", "243", ",", "244", ",", 
   "245", ",", "246", ",", "247", ",", "248", ",", "249", ",", "250", ",", 
   "251", ",", "252", ",", "253", ",", "254", ",", "255", ",", "256", ",", 
   "257", ",", "258", ",", "259", ",", "260", ",", "261", ",", "262", ",", 
   "263", ",", "264", ",", "265", ",", "266", ",", "267", ",", "268", ",", 
   "269", ",", "270", ",", "271", ",", "272", ",", "273", ",", "274", ",", 
   "275", ",", "276", ",", "277", ",", "278", ",", "279", ",", "280", ",", 
   "281", ",", "282", ",", "283", ",", "284", ",", "285", ",", "286", ",", 
   "287", ",", "288", ",", "289", ",", "290", ",", "291", ",", "292", ",", 
   "293", ",", "294", ",", "295", ",", "296", ",", "297", ",", "298", ",", 
   "299", ",", "300", ",", "301", ",", "302", ",", "303", ",", "304", ",", 
   "305", ",", "306", ",", "307", ",", "308", ",", "309", ",", "310", ",", 
   "311", ",", "312", ",", "313", ",", "314", ",", "315", ",", "316", ",", 
   "317", ",", "318", ",", "319", ",", "320", ",", "321", ",", "322", ",", 
   "323", ",", "324", ",", "325", ",", "326", ",", "327", ",", "328", ",", 
   "329", ",", "330", ",", "331", ",", "332", ",", "333", ",", "334", ",", 
   "335", ",", "336", ",", "337", ",", "338", ",", "339", ",", "340", ",", 
   "341", ",", "342", ",", "343"}], "}"}]], "Output",
 CellLabel->
  "Out[189]=",ExpressionUUID->"da21e875-1353-42f5-81fe-b84c0ca00e40"]
}, Open  ]],

Cell["\<\
Finally, we print out the integers that are missing from the list.\
\>", "Text",ExpressionUUID->"9420b59f-4b48-4f5f-a4f0-d1bb997de63a"],

Cell[CellGroupData[{

Cell[BoxData[
 RowBox[{"For", "[", 
  RowBox[{
   RowBox[{"i", "=", "1"}], ",", 
   RowBox[{"i", "\[LessEqual]", "343"}], ",", 
   RowBox[{"i", "++"}], ",", 
   RowBox[{"If", "[", 
    RowBox[{
     RowBox[{"!", 
      RowBox[{"MemberQ", "[", 
       RowBox[{"sumeightCubes", ",", "i"}], "]"}]}], ",", 
     RowBox[{"Print", "[", "i", "]"}]}], "]"}]}], "]"}]], "Input",
 CellLabel->
  "In[190]:=",ExpressionUUID->"291fa3b7-d4dd-4f49-839e-d08e771bd892"],

Cell[CellGroupData[{

Cell[BoxData["23"], "Print",
 CellLabel->
  "During evaluation of \
In[190]:=",ExpressionUUID->"639c0b90-0d56-4e5a-baea-566ed78c5d49"],

Cell[BoxData["239"], "Print",
 CellLabel->
  "During evaluation of \
In[190]:=",ExpressionUUID->"1e30ac27-47b5-4ea3-a5f9-2c4b4bf3af37"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]],

Cell[CellGroupData[{

Cell["Exercises", "Section",
 CellTags->"Exercises",ExpressionUUID->"92716c2a-19ce-43d4-a6c4-d610d8366903"],

Cell[CellGroupData[{

Cell[TextData[{
 "Write functions ",
 StyleBox["or", "Code"],
 ", ",
 StyleBox["xor", "Code"],
 ", and ",
 StyleBox["not", "Code"],
 " to implement those bit string operators."
}], "Item1Exercise",ExpressionUUID->"7d428c3f-6251-471f-9ed9-e23251ed9e00"],

Cell["\<\
Solve Exercises 23 through 27 in Section 1.2 of the main textbook, using the \
knights and knaves puzzle that was solved earlier in this chapter as a guide.\
\
\>", "Item1Exercise",ExpressionUUID->"9aa5e341-fa86-481b-9387-4309afc5e580"],

Cell["\<\
Implement the solution of Sudoku puzzles as a satisfiability problem \
described in the main text.\
\>", "Item1Exercise",ExpressionUUID->"122d71df-1e99-49e6-900f-06a649e0c80d"],

Cell[TextData[{
 "Write a function in the Wolfram Language to find the dual of a proposition. \
Dual is defined in the Exercises of Section 1.3. (Hint: you may find it \
useful to know that ",
 StyleBox[ButtonBox["And",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/And"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["Or",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Or"], "FunctionLink"],
 " are heads in logical expressions.)"
}], "Item1Exercise",ExpressionUUID->"04313464-b7ea-41a0-ae5e-9ef1a4920a83"],

Cell[TextData[{
 "Write a function ",
 StyleBox["uniqueness", "Code"],
 ", based on the built-in ",
 StyleBox[ButtonBox["Exists",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/Exists"], "FunctionLink"],
 " and ",
 StyleBox[ButtonBox["ForAll",
  BaseStyle->"Link",
  ButtonData->"paclet:ref/ForAll"], "FunctionLink"],
 " functions, to implement the uniqueness quantifier, described in Section \
1.4 of the text",
 ". "
}], "Item1Exercise",ExpressionUUID->"4f29a222-b8a9-429c-ae80-ee1da8c6cb86"],

Cell[CellGroupData[{

Cell[TextData[{
 "Write a function in the Wolfram Language that plays the obligato game in \
the role of the student, as described in the Supplementary Exercises of \
Chapter 1 in the main textbook. Specifically, the function should accept two \
arguments. The first argument is the new statement that you, as the teacher, \
provide. The second argument should be the list of ",
 StyleBox["Mathematica",
  FontSlant->"Italic"],
 "\[CloseCurlyQuote]s responses to all the previous statements. For example, \
suppose the teacher\[CloseCurlyQuote]s first statement is ",
 Cell[BoxData[
  FormBox[
   RowBox[{"p", "\[Rule]", 
    RowBox[{"(", 
     RowBox[{"q", "\[Or]", "r"}], ")"}]}], TraditionalForm]],ExpressionUUID->
  "63f4f104-0237-4407-ac4d-5da4a6ff46e3"],
 ", the second statement is ",
 Cell[BoxData[
  FormBox[
   RowBox[{
    RowBox[{"\[Not]", "p"}], "\[Or]", "q"}], TraditionalForm]],
  ExpressionUUID->"f6e95a60-0439-4f6e-837b-15cf01aa4084"],
 ", and the third statement is ",
 Cell[BoxData[
  FormBox["r", TraditionalForm]],ExpressionUUID->
  "c8208a03-dc6f-4f30-bd2d-a162bc86a374"],
 ". If the function/student accepts the first statement and denies the second \
statement, then you would obtain the response to the third statement by \
executing"
}], "Item1Exercise",
 CellGroupingRules->{
  GroupTogetherGrouping, 
   17001.},ExpressionUUID->"03eaf90e-03a9-49c4-afc0-c6b452efbeea"],

Cell[BoxData[
 RowBox[{"obligato", "[", 
  RowBox[{"r", ",", 
   RowBox[{"{", 
    RowBox[{
     RowBox[{"Implies", "[", 
      RowBox[{"p", ",", 
       RowBox[{"q", "||", "r"}]}], "]"}], ",", 
     RowBox[{"!", 
      RowBox[{"(", 
       RowBox[{
        RowBox[{"!", "p"}], "||", "q"}], ")"}]}]}], "}"}]}], "]"}]], "myCode",\

 Evaluatable->False,
 CellGroupingRules->{GroupTogetherGrouping, 17001.},
 InitializationCell->
  False,ExpressionUUID->"29a53037-2cc7-4012-b0e3-34d580d8279b"],

Cell[TextData[{
 "The function must accept the statement ",
 StyleBox["r",
  FontWeight->"Bold"],
 " and thus returns the list with that response included, as shown below:"
}], "ExerciseContinuation",
 CellGroupingRules->{
  GroupTogetherGrouping, 
   17001.},ExpressionUUID->"74656744-47f3-4581-b863-75a42356afcd"],

Cell[BoxData[
 RowBox[{"{", 
  RowBox[{
   RowBox[{"p", "\[Implies]", 
    RowBox[{"q", "||", "r"}]}], ",", 
   RowBox[{"!", 
    RowBox[{"(", 
     RowBox[{
      RowBox[{"!", "p"}], "||", "q"}], ")"}]}], ",", "r"}], "}"}]], "Output",
 CellMargins->{{80, 10}, {10, 5}},
 CellGroupingRules->{
  GroupTogetherGrouping, 
   17001.},ExpressionUUID->"4799d08e-1b33-494d-8cd8-5ae3a6805032"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]]
},
WindowSize->{725, 850},
WindowMargins->{{Automatic, 73}, {Automatic, 0}},
DockedCells->Cell[
  BoxData[
   TagBox[
    GridBox[{{"\"Exploring Discrete Mathematics with Mathematica\"", 
       ActionMenuBox[
       "\"Navigation\"", {
        "\"CloseAll\"" :> Module[{$CellContext`DJSection$}, SelectionMove[
             SelectedNotebook[], All, Notebook]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; 
           Do[NotebookLocate[$CellContext`DJSection$]; FrontEndExecute[
               FrontEndToken["OpenCloseGroup"]], {$CellContext`DJSection$, {
              "Section1a", "Section1b", "Section1c", "Section1d", "Section1e",
                "Section2a", "Section2b", "Section3a", "Section3b", 
               "Section3c", "Section4a", "Section4b", "Section6a", 
               "Section7a", "Section7b", "Section8a", "Section8b", 
               "SolutionsCE1", "SolutionsCP3", "Section1", "Section2", 
               "Section3", "Section4", "Section5", "Section6", "Section7", 
               "Section8", "Solutions", "Exercises"}}]; SelectionMove[
             SelectedNotebook[], Before, Notebook]], "\"Section1\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section1"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section2\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section2"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section3\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section3"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section4\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section4"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section5\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section5"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section6\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section6"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section7\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section7"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Section8\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Section8"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Solutions\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Solutions"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Exercises\"" :> 
         Module[{}, Do[NotebookLocate[$CellContext`DJSection]; FrontEndExecute[
                FrontEndToken[
                "SelectionCloseAllGroups"]], {$CellContext`DJSection, {
               "Section1", "Section2", "Section3", "Section4", "Section5", 
                "Section6", "Section7", "Section8", "Solutions", 
                "Exercises"}}] NotebookLocate["Exercises"]; FrontEndExecute[
             FrontEndToken["SelectionCloseAllGroups"]]; FrontEndExecute[
             FrontEndToken["SelectionOpenAllGroups"]]; SelectionMove[
             SelectedNotebook[], Before, Cell]], "\"Open All\"" :> 
         Module[{$CellContext`DJSection$}, 
           Do[NotebookLocate[$CellContext`DJSection$]; FrontEndExecute[
               FrontEndToken[
               "SelectionOpenAllGroups"]], {$CellContext`DJSection$, {
              "Exercises", "Section1", "Section1a", "Section1b", "Section1c", 
               "Section1d", "Section1e", "Section2", "Section2a", "Section2b",
                "Section3", "Section3a", "Section3b", "Section3c", "Section4",
                "Section4a", "Section4b", "Section5", "Section6", "Section6a",
                "Section7", "Section7a", "Section7b", "Section8", "Section8a",
                "Section8b", "Solutions", "SolutionsCE1", "SolutionsCP3"}}] 
           SelectionMove[
             SelectedNotebook[], Before, Notebook]]}]}}, 
     GridBoxAlignment -> {
      "Columns" -> {Left, Baseline}, "Rows" -> {Right, Baseline}}, AutoDelete -> 
     False, GridBoxItemSize -> {"Columns" -> {
         Scaled[0.8], 
         Scaled[0.2]}}], "Grid"]], "DockedCell", FontFamily -> "Times"],
PrintingCopies->1,
PrintingPageRange->{1, Automatic},
ShowSelection->True,
Magnification->1,
FrontEndVersion->"11.3 for Mac OS X x86 (32-bit, 64-bit Kernel) (March 5, \
2018)",
StyleDefinitions->Notebook[{
   Cell[
    StyleData[
    StyleDefinitions -> 
     FrontEnd`FileName[{"Book"}, "Textbook.nb", CharacterEncoding -> 
       "UTF-8"]]], 
   Cell[
    StyleData[All, "Printout"], PageWidth -> PaperWidth, 
    CellHorizontalScrolling -> True, 
    CellLabelMargins -> {{2, Inherited}, {Inherited, Inherited}}, 
    ShowAutoStyles -> False, 
    AutoStyleOptions -> {"HighlightMisspelledWords" -> False}, ScriptMinSize -> 
    9, MenuSortingValue -> 1500, 
    PrivateFontOptions -> {"FontType" -> "Outline"}, Magnification -> 1], 
   Cell[
    StyleData["Title"], Editable -> False, ShowCellBracket -> Automatic, 
    CellGroupingRules -> {"TitleGrouping", 0}, PageBreakBelow -> False, 
    DefaultNewInlineCellStyle -> {}, LanguageCategory -> "NaturalLanguage", 
    FontFamily -> "Helvetica", FontSize -> 25, FontWeight -> "Bold", 
    FontColor -> GrayLevel[0.137255]], 
   Cell[
    StyleData["BookChapterTitle", StyleDefinitions -> StyleData["Title"]], 
    CellFrame -> {{0, 0}, {1, 1}}, CellDingbat -> Cell[
      BoxData[
       GraphicsBox[{{
          RGBColor[0.09375, 0.570313, 0.816406], 
          RectangleBox[{0, 0}]}, {
          GrayLevel[1], FontSize -> 35, FontWeight -> Bold, FontFamily -> 
          "Helvetica", 
          InsetBox[
           CounterBox["ChapterNumber"], {0.5, 0.45}, {Center, Center}]}}, 
        ImageSize -> {70, 70}]], "Output"], 
    CellMargins -> {{100, 0}, {20, 20}}, CellFrameColor -> GrayLevel[1]], 
   Cell[
    StyleData["DockedCell"], CellMargins -> {{12, 12}, {20, 0}}, 
    CellGroupingRules -> "TitleGrouping", 
    ConversionRules :> {"TeX" -> {"\n\\chapter{", "}"}}, 
    TaggingRules :> {"CounterSettings" -> {"CounterTarget" -> "CellGroup"}}, 
    PageBreakAbove -> False, PageBreakBelow -> False, LineSpacing -> {1, 2}, 
    MenuSortingValue -> 1105, FontFamily -> "Helvetica", FontSize -> 27, 
    FontWeight -> "Bold", Background -> RGBColor[0.09375, 0.570313, 0.816406],
     CounterBoxOptions -> {
     CounterFunction :> Identity}, $CellContext`DefaultReturnCreatedCellStyle -> 
    "Section"], 
   Cell[
    StyleData["FunctionLink"], ConversionRules :> {"TeX" -> {{"", 
         $CellContext`ExportAsHyperRef[], ""}, {"", Automatic, ""}}}, 
    MenuSortingValue -> 1105, ButtonStyleMenuListing -> None, FontFamily -> 
    "Courier", FontVariations -> {"Underline" -> True}, FontColor -> 
    RGBColor[0, 0, 1], 
    ButtonBoxOptions -> {Active -> True, ButtonFunction :> (FrontEndExecute[{
         FrontEnd`NotebookLocate[#2]}]& ), ButtonNote -> ButtonData}], 
   Cell[
    StyleData["Problem"], CellMargins -> {{40, 12}, {15, 15}}, 
    CellGroupingRules -> {"GroupTogetherNestedGrouping", 15010}, 
    ConversionRules :> {
     "TeX" -> {{"", Automatic, ""}, {"\n\n", Automatic, ""}}}, 
    TaggingRules :> {
     "ExtraConversionRules" -> {"General" -> {"RestartList" -> False}}}], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Item1Exercise"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item1Exercise"], "."}], CellSize -> {30, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{50, 12}, {3, 5}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17000}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, CounterIncrements -> "Item1Exercise", 
       CounterAssignments -> {{"Item2Exercise", 0}}, MenuSortingValue -> 
       4100], 
      Cell[
       StyleData["Item1Exercise", "Printout"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item1Exercise"], "."}], CellSize -> {20, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{35, 12}, {3, 5}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17000}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6]}, Open]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["ExerciseContinuation"], CellMargins -> {{50, 12}, {1, 3}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17000}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, MenuSortingValue -> 4101], 
      Cell[
       StyleData["ExerciseContinuation", "Printout"], 
       CellMargins -> {{35, 12}, {1, 3}}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6]}, Open]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Item2Exercise"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item2Exercise"], "."}], CellSize -> {32, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{75, 12}, {1, 2}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 17100}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, CounterIncrements -> "Item2Exercise", MenuSortingValue -> 4200, 
       CounterBoxOptions -> {CounterFunction :> (Part[
           CharacterRange["a", "z"], #]& )}], 
      Cell[
       StyleData["Item2Exercise", "Printout"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item2Exercise"], "."}], CellSize -> {20, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Bold"], 
       CellMargins -> {{50, 12}, {1, 2}}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, CounterBoxOptions -> {CounterFunction :> (Part[
           CharacterRange["a", "z"], #]& )}]}, Open]], 
   Cell[
    StyleData["ExerciseEquation"], CellMargins -> {{36, 12}, {7, 7}}, 
    CellGroupingRules -> {"GroupTogetherNestedGrouping", 17200}, 
    CellHorizontalScrolling -> True, 
    CellFrameLabels -> {{None, None}, {None, None}}, DefaultFormatType -> 
    TraditionalForm, InputAutoReplacements -> {}, TextAlignment -> Center, 
    MenuSortingValue -> 4300, 
    ButtonBoxOptions -> {Appearance -> {Automatic, None}}], 
   Cell[
    StyleData["myCode"], CellMargins -> {{66, 10}, {5, 10}}, 
    StyleKeyMapping -> {"=" -> "WolframAlphaShort"}, Evaluatable -> False, 
    CellGroupingRules -> "InputGrouping", TextClipboardType -> "InputText", 
    PageBreakWithin -> False, GroupPageBreakWithin -> False, 
    DefaultFormatType -> DefaultInputFormatType, ContextMenu -> 
    FEPrivate`FrontEndResource["ContextMenus", "myCode"], ShowAutoStyles -> 
    True, "TwoByteSyntaxCharacterAutoReplacement" -> True, 
    HyphenationOptions -> {"HyphenationCharacter" -> "\[Continuation]"}, 
    AutoItalicWords -> {}, AutoQuoteCharacters -> {}, 
    PasteAutoQuoteCharacters -> {}, LanguageCategory -> "Mathematica", 
    FormatType -> InputForm, NumberMarks -> True, 
    LinebreakAdjustments -> {0.85, 2, 10, 0, 1}, CounterIncrements -> "Code", 
    MenuSortingValue -> 1495, MenuCommandKey -> "8", FontWeight -> 
    "Bold", $CellContext`StripStyleOnPaste -> True], 
   Cell[
    StyleData["CodeVar"], DefaultFormatType -> DefaultInputFormatType, 
    LineBreakWithin -> False, MenuSortingValue -> 10000, FontWeight -> "Bold",
     FontSlant -> "Italic", FontColor -> GrayLevel[0.4]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Section"], CellFrame -> {{6, 0}, {0, 1}}, ShowCellBracket -> 
       Automatic, CellMargins -> {{12, 12}, {3, 24}}, 
       CellGroupingRules -> {"SectionGrouping", 30}, 
       ConversionRules :> {
        "TeX" -> {"\n\\section{", "}"}, 
         "HTML" -> {"<h3 class=\"Section\">", "</h3>"}}, 
       TaggingRules :> {
        "CounterSettings" -> {
          "CounterFormat" -> {"BookChapterNumber", ".", "Section"}, 
           "CounterTarget" -> "Cell", "XRefPrefix" -> "Section"}}, 
       PageBreakBelow -> False, CellFrameMargins -> {{8, 8}, {4, 6}}, 
       CellFrameColor -> RGBColor[0.09375, 0.570313, 0.816406], TabSpacings -> 
       2.1, CounterIncrements -> {
        "Section", "SectionHeader", "SubsectionHeader", "SubsubsectionHeader",
          "SubsubsubsectionHeader"}, FontFamily -> "Helvetica", FontSize -> 
       16, FontWeight -> "Bold", Background -> GrayLevel[0.999985]], 
      Cell[
       StyleData["Section", "Printout"], CellFrame -> {{4, 0}, {0, 0.5}}, 
       CellMargins -> {{2, 2}, {3, 21}}, CellFrameMargins -> {{6, 6}, {3, 5}},
        CellFrameColor -> RGBColor[0.09375, 0.570313, 0.816406]], 
      Cell[
       StyleData["Section", "DoubleSpacedPrintout"], 
       CellFrame -> {{4, 0}, {0, 0.5}}, CellMargins -> {{2, 2}, {3, 21}}, 
       CellFrameMargins -> {{6, 6}, {3, 5}}, CellFrameColor -> 
       RGBColor[0.09375, 0.570313, 0.816406], FontSize -> 14]}, Open]], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Subsubsection"], CellDingbat -> None, 
       CellMargins -> {{12, 12}, {0, 6}}, 
       CellElementSpacings -> {"ClosedGroupTopMargin" -> 12}, 
       CellGroupingRules -> {"SectionGrouping", 50}, 
       ConversionRules :> {
        "TeX" -> {"\n\\subsubsection{", "}"}, 
         "HTML" -> {"<h5 class=\"Subsubsection\">", "</h5>"}}, PageBreakBelow -> 
       False, CellFrameLabelMargins -> 4, 
       CounterIncrements -> {
        "Subsubsection", "SubsubsectionHeader", "SubsubsubsectionHeader"}, 
       FontFamily -> "Helvetica", FontSize -> 11, FontWeight -> "Bold", 
       FontSlant -> "Italic"], 
      Cell[
       StyleData["Subsubsection", "Printout"], FontFamily -> "Helvetica", 
       FontSize -> 11, FontWeight -> "Bold", FontSlant -> "Italic"]}, Open]], 
   
   Cell[
    StyleData["Equation"], CellMargins -> {{26, 10}, {7, 7}}, 
    ConversionRules :> {
     "HTML" -> {{"", ""}, {"<p class=\"Equation\">", "</p>"}}}, 
    CellHorizontalScrolling -> True, DefaultFormatType -> TraditionalForm, 
    InputAutoReplacements -> {}, TextAlignment -> Center, CounterIncrements -> 
    "Equation", ButtonBoxOptions -> {Appearance -> {Automatic, None}}], 
   Cell[
    CellGroupData[{
      Cell[
       StyleData["Item1Numbered"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item1Numbered"], "."}], CellSize -> {32, Inherited}, 
         TextAlignment -> Right, 
         TextJustification -> (FontWeight -> "Plain")], 
       CellMargins -> {{36, 12}, {1, 3}}, 
       CellGroupingRules -> {"GroupTogetherNestedGrouping", 15000}, 
       ConversionRules :> {{"TeX" -> {"\n\\item ", ""}}, {
         "HTML" -> {"<li>", "</li>"}}}, 
       TaggingRules :> {
        "ExtraConversionRules" -> {
          "General" -> {"NestingLevel" -> 30}, 
           "TeX" -> {"CellGroupEnvironment" -> "enumerate"}, 
           "HTML" -> {"CellGroupEnvironment" -> "ol"}}}, 
       CellFrameLabels -> {{None, None}, {None, None}}, CellFrameLabelMargins -> 
       6, TextJustification -> 1, CounterIncrements -> "Item1Numbered", 
       CounterAssignments -> {{"Item2Numbered", 0}, {"Item3Numbered", 0}}], 
      Cell[
       StyleData["Item1Numbered", "Printout"], CellDingbat -> Cell[
         TextData[{
           CounterBox["Item1Numbered"], "."}], CellSize -> {20, Inherited}, 
         TextAlignment -> Right, FontWeight -> "Plain"], 
       CellMargins -> {{24, 2}, {1, 2}}, CellFrameLabelMargins -> 3, 
       TextJustification -> 1]}, Open]], 
   Cell[
    StyleData["InitializationCell"], Background -> GrayLevel[1]], 
   Cell[
    StyleData["Item1"], TextJustification -> 1], 
   Cell[
    StyleData["Item1Printout"], TextJustification -> 1, MenuSortingValue -> 
    10000], 
   Cell[
    StyleData["Code"], FormatType -> InputForm]}, Visible -> False, 
  FrontEndVersion -> 
  "11.3 for Mac OS X x86 (32-bit, 64-bit Kernel) (March 5, 2018)", 
  StyleDefinitions -> "PrivateStylesheetFormatting.nb"]
]
(* End of Notebook Content *)

(* Internal cache information *)
(*CellTagsOutline
CellTagsIndex->{
 "Section1"->{
  Cell[1527, 48, 120, 1, 55, "Section",ExpressionUUID->"109df940-8540-4a38-8867-0f4b046f6b0b",
   CellTags->"Section1"]},
 "Section1a"->{
  Cell[4825, 147, 120, 1, 32, "Subsection",ExpressionUUID->"d5c17553-5774-4cf0-98a2-09a70a625fd1",
   CellTags->"Section1a"]},
 "Section1b"->{
  Cell[13496, 404, 123, 1, 32, "Subsection",ExpressionUUID->"e1072977-7b75-482e-ace2-136198601e49",
   CellTags->"Section1b"]},
 "Section1c"->{
  Cell[23639, 667, 123, 1, 32, "Subsection",ExpressionUUID->"29c005f5-10b1-48f1-8b03-6e03264b0412",
   CellTags->"Section1c"]},
 "Section1d"->{
  Cell[29095, 836, 123, 1, 32, "Subsection",ExpressionUUID->"0f8838d4-0c4d-46b1-9825-2167fddcf4e2",
   CellTags->"Section1d"]},
 "Section1e"->{
  Cell[41568, 1195, 125, 1, 32, "Subsection",ExpressionUUID->"dc41b0cd-d50f-4ce8-a063-042e483cfd23",
   CellTags->"Section1e"]},
 "Section2"->{
  Cell[71495, 2085, 136, 1, 55, "Section",ExpressionUUID->"24baadba-7542-43af-84e4-181f4a4bb1ec",
   CellTags->"Section2"]},
 "Section2a"->{
  Cell[72044, 2099, 122, 1, 32, "Subsection",ExpressionUUID->"57c1656b-f950-4ad4-829a-bfa697ba05c8",
   CellTags->"Section2a"]},
 "Section2b"->{
  Cell[94131, 2772, 114, 1, 32, "Subsection",ExpressionUUID->"eff2eb80-9f53-4d45-96e1-83e66d3c018a",
   CellTags->"Section2b"]},
 "Section3"->{
  Cell[100540, 2943, 126, 1, 55, "Section",ExpressionUUID->"d1c43771-0c2f-4dff-b301-9f7e47bf2572",
   CellTags->"Section3"]},
 "Section3a"->{
  Cell[101250, 2962, 119, 1, 32, "Subsection",ExpressionUUID->"182f68f5-fb92-4249-b54d-1424395ea9ad",
   CellTags->"Section3a"]},
 "Section3b"->{
  Cell[107586, 3149, 128, 1, 32, "Subsection",ExpressionUUID->"5657657d-bbe3-4ee8-80f4-5be8d952f98b",
   CellTags->"Section3b"]},
 "Section3c"->{
  Cell[172383, 5085, 248, 7, 33, "Subsection",ExpressionUUID->"53c75699-a838-4dd1-ba94-9aed834605a6",
   CellTags->"Section3c"]},
 "Section4"->{
  Cell[200501, 5960, 127, 1, 55, "Section",ExpressionUUID->"7ac4187e-7018-405a-a934-849880f911c8",
   CellTags->"Section4"]},
 "Section4a"->{
  Cell[202975, 6038, 155, 2, 32, "Subsection",ExpressionUUID->"86ae9358-2b36-46f6-ae75-fdd8851cce21",
   PageBreakWithin->False,
   CellTags->"Section4a"]},
 "Section4b"->{
  Cell[209545, 6253, 138, 1, 32, "Subsection",ExpressionUUID->"64525962-1926-46a2-9954-94bc18205665",
   CellTags->"Section4b"]},
 "Section5"->{
  Cell[221941, 6668, 119, 1, 55, "Section",ExpressionUUID->"4a07aace-d433-46de-b92c-4cb22ecf3437",
   CellTags->"Section5"]},
 "Section6"->{
  Cell[231196, 6991, 119, 1, 55, "Section",ExpressionUUID->"e06179c6-6f6b-4807-bdb1-99f50d6e5b2b",
   CellTags->"Section6"]},
 "Section6a"->{
  Cell[239288, 7219, 131, 1, 32, "Subsection",ExpressionUUID->"419e1445-3d3c-4d63-afcd-5c63a0f11b57",
   CellTags->"Section6a"]},
 "Section7"->{
  Cell[253870, 7639, 123, 1, 55, "Section",ExpressionUUID->"3a9a9222-9952-41f3-bb49-0db02ae48c98",
   CellTags->"Section7"]},
 "Section7a"->{
  Cell[254903, 7664, 125, 1, 32, "Subsection",ExpressionUUID->"32432fd3-2627-40b3-9d93-d341eaa4b9a5",
   CellTags->"Section7a"]},
 "Section7b"->{
  Cell[263339, 7894, 106, 1, 32, "Subsection",ExpressionUUID->"5b91512a-700d-41ea-bb4f-278a5b7bb292",
   CellTags->"Section7b"]},
 "Section8"->{
  Cell[272709, 8152, 127, 1, 55, "Section",ExpressionUUID->"5d2577e6-7ebe-4b05-847f-864155adbfb9",
   CellTags->"Section8"]},
 "Section8a"->{
  Cell[273132, 8164, 117, 1, 32, "Subsection",ExpressionUUID->"25ef834a-f737-40ac-9540-62433ce5153a",
   CellTags->"Section8a"]},
 "Section8b"->{
  Cell[282592, 8426, 117, 1, 32, "Subsection",ExpressionUUID->"071f504d-87ac-4c0e-8ded-e5ae18d17d68",
   CellTags->"Section8b"]},
 "Solutions"->{
  Cell[288449, 8588, 170, 3, 55, "Section",ExpressionUUID->"09a943cc-d17b-479d-aedd-574567ffe38f",
   CellTags->"Solutions"]},
 "SolutionsCP3"->{
  Cell[288644, 8595, 126, 2, 32, "Subsection",ExpressionUUID->"026465c8-9bc9-4ddc-8018-06a0a9dd7aab",
   CellTags->"SolutionsCP3"]},
 "SolutionsCE1"->{
  Cell[296207, 8836, 138, 2, 32, "Subsection",ExpressionUUID->"fd6cf4a1-4e4c-4114-9cb4-f1ddfa8e875c",
   CellTags->"SolutionsCE1"]},
 "Exercises"->{
  Cell[315254, 9301, 107, 1, 55, "Section",ExpressionUUID->"92716c2a-19ce-43d4-a6c4-d610d8366903",
   CellTags->"Exercises"]}
 }
*)
(*CellTagsIndex
CellTagsIndex->{
 {"Section1", 339939, 9814},
 {"Section1a", 340077, 9817},
 {"Section1b", 340220, 9820},
 {"Section1c", 340364, 9823},
 {"Section1d", 340508, 9826},
 {"Section1e", 340652, 9829},
 {"Section2", 340796, 9832},
 {"Section2a", 340937, 9835},
 {"Section2b", 341082, 9838},
 {"Section3", 341226, 9841},
 {"Section3a", 341368, 9844},
 {"Section3b", 341514, 9847},
 {"Section3c", 341660, 9850},
 {"Section4", 341805, 9853},
 {"Section4a", 341947, 9856},
 {"Section4b", 342120, 9860},
 {"Section5", 342265, 9863},
 {"Section6", 342406, 9866},
 {"Section6a", 342548, 9869},
 {"Section7", 342693, 9872},
 {"Section7a", 342835, 9875},
 {"Section7b", 342981, 9878},
 {"Section8", 343126, 9881},
 {"Section8a", 343268, 9884},
 {"Section8b", 343414, 9887},
 {"Solutions", 343560, 9890},
 {"SolutionsCP3", 343706, 9893},
 {"SolutionsCE1", 343858, 9896},
 {"Exercises", 344007, 9899}
 }
*)
(*NotebookFileOutline
Notebook[{
Cell[CellGroupData[{
Cell[580, 22, 170, 3, 108, "BookChapterTitle",ExpressionUUID->"c09afbd1-27d0-443f-b74d-f99f24e3478f",
 CounterAssignments->{{"ChapterNumber", 1}}],
Cell[CellGroupData[{
Cell[775, 29, 86, 0, 55, "Section",ExpressionUUID->"6fbcc4d5-94cd-4b66-9603-6adbbbfb15da"],
Cell[864, 31, 626, 12, 65, "Text",ExpressionUUID->"2edb58d2-6b53-4e74-9ffd-a137d125d08f"]
}, Open  ]],
Cell[CellGroupData[{
Cell[1527, 48, 120, 1, 55, "Section",ExpressionUUID->"109df940-8540-4a38-8867-0f4b046f6b0b",
 CellTags->"Section1"],
Cell[1650, 51, 481, 8, 50, "Text",ExpressionUUID->"babc3d43-172f-4704-aa99-1b639e9c37bf"],
Cell[2134, 61, 655, 18, 55, "Text",ExpressionUUID->"1da7ac06-4d2f-435a-b190-24db1d45789a"],
Cell[CellGroupData[{
Cell[2814, 83, 109, 1, 31, "Input",ExpressionUUID->"f3fc2257-be33-4207-80ea-5a7290173d1f"],
Cell[2926, 86, 110, 1, 31, "Output",ExpressionUUID->"ad0c2bb3-9140-402d-9a06-6524bf3b1620"]
}, Open  ]],
Cell[3051, 90, 240, 5, 20, "Text",ExpressionUUID->"7cdbc6a1-585c-4172-b34b-964fe2b72c24"],
Cell[CellGroupData[{
Cell[3316, 99, 134, 2, 31, "Input",ExpressionUUID->"dbd36cee-1ac6-482e-9532-7b3b938a1f13"],
Cell[3453, 103, 109, 1, 31, "Output",ExpressionUUID->"8fb698b2-902a-4df8-bf0b-ab4c8af68132"]
}, Open  ]],
Cell[CellGroupData[{
Cell[3599, 109, 109, 1, 31, "Input",ExpressionUUID->"aceb354a-7cdf-4932-841c-c7e0eadde96a"],
Cell[3711, 112, 109, 1, 31, "Output",ExpressionUUID->"08e76539-1d30-4931-8130-195b55044cf0"]
}, Open  ]],
Cell[3835, 116, 692, 19, 43, "Text",ExpressionUUID->"3d5e4e90-2ac0-4cc6-96a2-ea689f922729"],
Cell[4530, 137, 140, 2, 31, "Input",ExpressionUUID->"551926cf-97ae-4695-ae56-e3f731835626"],
Cell[4673, 141, 127, 2, 31, "Input",ExpressionUUID->"177fbc41-62eb-4275-a34e-b348616d5d6d"],
Cell[CellGroupData[{
Cell[4825, 147, 120, 1, 32, "Subsection",ExpressionUUID->"d5c17553-5774-4cf0-98a2-09a70a625fd1",
 CellTags->"Section1a"],
Cell[4948, 150, 1169, 34, 73, "Text",ExpressionUUID->"31ed25ab-df9e-479e-9ff8-0f867e723d62"],
Cell[6120, 186, 880, 23, 50, "Text",ExpressionUUID->"68ebd539-b3f7-49c3-94fb-fd2b9e61b595"],
Cell[CellGroupData[{
Cell[7025, 213, 163, 3, 31, "Input",ExpressionUUID->"f97ec2ee-6108-4ec5-b0da-cff78f301cab"],
Cell[7191, 218, 109, 1, 31, "Output",ExpressionUUID->"4f2efab2-df08-42ce-93aa-79373fc9b186"]
}, Open  ]],
Cell[CellGroupData[{
Cell[7337, 224, 227, 5, 31, "Input",ExpressionUUID->"f7db5dd6-58c1-4c4a-825c-579ce7fa7e97"],
Cell[7567, 231, 110, 1, 31, "Output",ExpressionUUID->"6447c302-5c19-49a5-a105-bd2157791d30"]
}, Open  ]],
Cell[CellGroupData[{
Cell[7714, 237, 163, 3, 31, "Input",ExpressionUUID->"523622dc-0f70-42b7-9917-bec5587cb715"],
Cell[7880, 242, 110, 1, 31, "Output",ExpressionUUID->"6c985d50-7111-4fd7-86d7-e54df25afa1b"]
}, Open  ]],
Cell[8005, 246, 870, 28, 62, "Text",ExpressionUUID->"3d13a13d-0876-4b56-9a72-bdd71c71dae2"],
Cell[CellGroupData[{
Cell[8900, 278, 125, 2, 31, "Input",ExpressionUUID->"7a1f44b2-3e06-493e-9df4-ec6bd22e91c5"],
Cell[9028, 282, 110, 1, 31, "Output",ExpressionUUID->"5a2e9c58-a454-4cdd-87cf-ef293a7f20e9"]
}, Open  ]],
Cell[CellGroupData[{
Cell[9175, 288, 187, 4, 31, "Input",ExpressionUUID->"7c535ce5-d226-4278-a2e2-d426f8eb14a8"],
Cell[9365, 294, 110, 1, 31, "Output",ExpressionUUID->"162a1e5b-f343-48d8-b1c7-848127680f31"]
}, Open  ]],
Cell[9490, 298, 542, 10, 50, "Text",ExpressionUUID->"8891c6df-83d0-4689-886d-ba29bf6f4342"],
Cell[CellGroupData[{
Cell[10057, 312, 150, 2, 31, "Input",ExpressionUUID->"96fa0e90-4e25-4306-9a7e-c4744f364467"],
Cell[10210, 316, 111, 1, 31, "Output",ExpressionUUID->"5230ad4b-830e-426d-b404-1bb1bedac38e"]
}, Open  ]],
Cell[10336, 320, 315, 6, 35, "Text",ExpressionUUID->"db369c88-b90e-4bea-94bd-95e092f8a167"],
Cell[CellGroupData[{
Cell[10676, 330, 155, 2, 31, "Input",ExpressionUUID->"107bd348-bb14-412b-98aa-3e82967ba0ca"],
Cell[10834, 334, 110, 1, 31, "Output",ExpressionUUID->"43f2c530-764a-44af-8ee1-6a7630f43728"]
}, Open  ]],
Cell[10959, 338, 402, 6, 50, "Text",ExpressionUUID->"83408c68-841b-46d2-ac10-cd0348290a85"],
Cell[11364, 346, 1526, 43, 138, "Text",ExpressionUUID->"12d2b6aa-1027-4414-b2e4-5aaf9df34172"],
Cell[12893, 391, 566, 8, 65, "Text",ExpressionUUID->"71f489b8-bfb2-4788-be63-160c78310b52"]
}, Open  ]],
Cell[CellGroupData[{
Cell[13496, 404, 123, 1, 32, "Subsection",ExpressionUUID->"e1072977-7b75-482e-ace2-136198601e49",
 CellTags->"Section1b"],
Cell[13622, 407, 830, 18, 51, "Text",ExpressionUUID->"23e10dd7-687a-4d9f-9a7a-09bf3b53925c"],
Cell[14455, 427, 574, 8, 65, "Text",ExpressionUUID->"64b749df-0b43-448c-ac2e-9c239d039bc1"],
Cell[15032, 437, 327, 8, 31, "Input",ExpressionUUID->"ca788508-ce68-49c7-83da-1d888270e477",
 InitializationCell->True],
Cell[15362, 447, 483, 9, 35, "Text",ExpressionUUID->"afcae5e4-caba-43ae-9684-a68102b5a824"],
Cell[CellGroupData[{
Cell[15870, 460, 141, 2, 31, "Input",ExpressionUUID->"578be923-4f3f-49f2-a6e7-5dcf31caf11c"],
Cell[16014, 464, 107, 1, 31, "Output",ExpressionUUID->"05f54868-10d2-441e-b061-f4a53c1b6ed1"]
}, Open  ]],
Cell[CellGroupData[{
Cell[16158, 470, 141, 2, 31, "Input",ExpressionUUID->"3b81d40f-03bc-45bb-955e-f403f5857a22"],
Cell[16302, 474, 107, 1, 31, "Output",ExpressionUUID->"1a06df00-81c6-4785-babd-d39dec06797a"]
}, Open  ]],
Cell[16424, 478, 607, 9, 69, "Text",ExpressionUUID->"2375c7f0-c889-4c94-aae3-e4759571c422"],
Cell[17034, 489, 520, 10, 54, "Text",ExpressionUUID->"ddaed04e-3ebb-4668-ab5b-c184cd10ddae"],
Cell[17557, 501, 1134, 34, 73, "Text",ExpressionUUID->"d2a3b362-9223-475b-99e8-2f00fbf33bd2"],
Cell[18694, 537, 1295, 27, 104, "Text",ExpressionUUID->"7309181e-4b12-4d85-bb7e-9f6d4382730b"],
Cell[19992, 566, 723, 16, 52, "Text",ExpressionUUID->"4a11ad0d-5400-4b28-815c-e8f8e8982cd6"],
Cell[20718, 584, 181, 4, 31, "Input",ExpressionUUID->"e1a45144-3f09-4c19-9641-f424ce8e8b5a"],
Cell[20902, 590, 1188, 29, 91, "Text",ExpressionUUID->"cdec9525-9b49-4bd9-8827-eb41f91f5cfb"],
Cell[CellGroupData[{
Cell[22115, 623, 192, 4, 31, "Input",ExpressionUUID->"5bcf1726-6b6e-49ca-a17e-bbf95af762a4"],
Cell[22310, 629, 193, 4, 31, "Output",ExpressionUUID->"eb2e5f5d-aac1-4190-a2a9-673e802e08e6"]
}, Open  ]],
Cell[22518, 636, 181, 3, 20, "Text",ExpressionUUID->"5362ab6d-740c-4b54-bd90-0f84d27c039a"],
Cell[CellGroupData[{
Cell[22724, 643, 202, 4, 31, "Input",ExpressionUUID->"ab5bcb79-814d-4937-a619-5ca4f19af0c7"],
Cell[22929, 649, 107, 1, 31, "Output",ExpressionUUID->"12dab3bf-7e99-4c95-8980-21a42b8a536a"]
}, Open  ]],
Cell[23051, 653, 551, 9, 50, "Text",ExpressionUUID->"c6f7b4b5-ceaa-4610-8eca-8438f49c3a15"]
}, Open  ]],
Cell[CellGroupData[{
Cell[23639, 667, 123, 1, 32, "Subsection",ExpressionUUID->"29c005f5-10b1-48f1-8b03-6e03264b0412",
 CellTags->"Section1c"],
Cell[23765, 670, 376, 7, 35, "Text",ExpressionUUID->"4b115896-0cc5-4ee6-ba2d-b6172181b38c"],
Cell[24144, 679, 188, 4, 31, "Input",ExpressionUUID->"0ee772e1-70da-4aad-b2a7-35fc763796cb",
 InitializationCell->True],
Cell[24335, 685, 558, 15, 62, "Text",ExpressionUUID->"86a65796-bf53-4a1f-9334-0c4548efa2f9"],
Cell[CellGroupData[{
Cell[24918, 704, 142, 2, 31, "Input",ExpressionUUID->"7bc8e863-3705-49e7-bdba-ea3ea38a8796"],
Cell[25063, 708, 111, 1, 31, "Output",ExpressionUUID->"6a215bd6-7de7-49c8-8e2f-0551af22e00a"]
}, Open  ]],
Cell[CellGroupData[{
Cell[25211, 714, 110, 1, 31, "Input",ExpressionUUID->"545f2af9-2e63-4b48-8f55-986759a27dd0"],
Cell[25324, 717, 110, 1, 31, "Output",ExpressionUUID->"6e3aba34-3b17-4ea1-8033-c92a570a9b3d"]
}, Open  ]],
Cell[25449, 721, 414, 11, 43, "Text",ExpressionUUID->"ba0c24fc-32e9-4562-bbca-b169f2cc5ea0"],
Cell[25866, 734, 124, 2, 31, "Input",ExpressionUUID->"3980938c-7d85-483d-bd04-8ff56a12e780"],
Cell[25993, 738, 651, 15, 55, "Text",ExpressionUUID->"782e7775-8321-4a6c-a994-77c559c21e72"],
Cell[CellGroupData[{
Cell[26669, 757, 165, 3, 31, "Input",ExpressionUUID->"f83a0b0c-a81a-4f04-83b6-7cb7e1283d5f"],
Cell[26837, 762, 111, 1, 31, "Output",ExpressionUUID->"c11f7658-289a-4023-bdb0-aaa07ef2705c"]
}, Open  ]],
Cell[26963, 766, 923, 26, 77, "Text",ExpressionUUID->"712a2e62-ed93-4576-9be6-8c9bc26f7e5c"],
Cell[27889, 794, 706, 20, 35, "Text",ExpressionUUID->"3296a06d-c30e-4931-9172-8bcbaef189f9"],
Cell[CellGroupData[{
Cell[28620, 818, 313, 9, 31, "Input",ExpressionUUID->"98489b31-82ce-4812-a67e-01eb42b55fc0"],
Cell[28936, 829, 110, 1, 31, "Output",ExpressionUUID->"77ab5b9d-71a1-4c90-8694-225c93fb1941"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[29095, 836, 123, 1, 32, "Subsection",ExpressionUUID->"0f8838d4-0c4d-46b1-9825-2167fddcf4e2",
 CellTags->"Section1d"],
Cell[29221, 839, 559, 10, 51, "Text",ExpressionUUID->"f6b2d3c5-2290-4911-aa2e-a6411f4af5b6"],
Cell[29783, 851, 523, 9, 54, "Text",ExpressionUUID->"b804e20b-b88a-4482-9c36-c012e39e4ec2"],
Cell[30309, 862, 1502, 37, 81, "Text",ExpressionUUID->"042bca9d-d444-4e27-81f4-457d32109458"],
Cell[31814, 901, 1755, 45, 105, "Text",ExpressionUUID->"af886618-38f2-4b9a-8d33-4cf1d0fd76e6"],
Cell[33572, 948, 430, 8, 58, "Text",ExpressionUUID->"cfac9852-e6bf-4126-991c-cb2f6991c60f"],
Cell[CellGroupData[{
Cell[34027, 960, 363, 10, 31, "Input",ExpressionUUID->"ae3268e0-1b19-420c-95c7-1e339bd848f1"],
Cell[CellGroupData[{
Cell[34415, 974, 289, 8, 24, "Print",ExpressionUUID->"088efda8-6ae3-4a19-9a9f-024c2ee92a6c"],
Cell[34707, 984, 289, 8, 24, "Print",ExpressionUUID->"48c2520b-e785-44d5-aee3-330239d70cfa"]
}, Open  ]]
}, Open  ]],
Cell[35023, 996, 945, 21, 66, "Text",ExpressionUUID->"4ebf6fbf-9cfb-4055-8c59-602579045d8f"],
Cell[CellGroupData[{
Cell[35993, 1021, 695, 19, 70, "Input",ExpressionUUID->"2ba65e53-b530-4b34-a9f8-ec158bf41d2f"],
Cell[CellGroupData[{
Cell[36713, 1044, 365, 9, 24, "Print",ExpressionUUID->"f98b7884-3375-4d0d-aa85-2bc19d06c111"],
Cell[37081, 1055, 367, 9, 24, "Print",ExpressionUUID->"170bf41e-364d-487a-835e-1c26c0329c9e"],
Cell[37451, 1066, 367, 9, 24, "Print",ExpressionUUID->"8baf9255-31d8-4ac5-bd8f-e99a7cd05f67"],
Cell[37821, 1077, 369, 9, 24, "Print",ExpressionUUID->"3cbdc326-dcd1-4abf-a4b3-8f72895e8802"]
}, Open  ]]
}, Open  ]],
Cell[38217, 1090, 713, 20, 59, "Text",ExpressionUUID->"7f8c6579-378f-4d96-9691-df4ee08ed6ee"],
Cell[CellGroupData[{
Cell[38955, 1114, 582, 16, 31, "Input",ExpressionUUID->"90e6a2fa-9f72-410b-8e5b-e8bd09f2d6e5"],
Cell[CellGroupData[{
Cell[39562, 1134, 365, 9, 24, "Print",ExpressionUUID->"5f750161-60ed-4a92-b3cd-cfb54073d783"],
Cell[39930, 1145, 367, 9, 24, "Print",ExpressionUUID->"c69a8623-97c8-4534-9fc6-dd6eccab8226"],
Cell[40300, 1156, 367, 9, 24, "Print",ExpressionUUID->"d0811962-22f0-4294-8c4c-6acd4642796f"],
Cell[40670, 1167, 369, 9, 24, "Print",ExpressionUUID->"db600ea2-2a0e-45b3-bdfc-ab9e13470151"]
}, Open  ]]
}, Open  ]],
Cell[41066, 1180, 465, 10, 35, "Text",ExpressionUUID->"4cc3cd64-25ed-4574-b13a-d521b33804b7"]
}, Open  ]],
Cell[CellGroupData[{
Cell[41568, 1195, 125, 1, 32, "Subsection",ExpressionUUID->"dc41b0cd-d50f-4ce8-a063-042e483cfd23",
 CellTags->"Section1e"],
Cell[41696, 1198, 692, 13, 65, "Text",ExpressionUUID->"1459c6f9-0d74-4db7-857d-a3a2360f5c60"],
Cell[CellGroupData[{
Cell[42413, 1215, 102, 0, 18, "Subsubsection",ExpressionUUID->"ebae6291-fc82-4bcd-95d3-dcc037e30ad0"],
Cell[42518, 1217, 1015, 29, 52, "Text",ExpressionUUID->"e3e3c596-0dcf-402e-b1ad-e0fc722e2909"],
Cell[CellGroupData[{
Cell[43558, 1250, 161, 3, 31, "Input",ExpressionUUID->"fc6a6f05-962b-4304-824b-bd7cebbea9d2"],
Cell[43722, 1255, 107, 1, 31, "Output",ExpressionUUID->"04641b18-6797-4e06-bac6-3274390ff5d4"]
}, Open  ]],
Cell[43844, 1259, 473, 12, 21, "Text",ExpressionUUID->"cf64246d-41f6-4997-b8b2-af643e00933c"],
Cell[CellGroupData[{
Cell[44342, 1275, 180, 3, 31, "Input",ExpressionUUID->"207ff25a-f358-476b-a8e1-496dc266b0e9"],
Cell[44525, 1280, 107, 1, 31, "Output",ExpressionUUID->"c713ccf0-014e-4c51-8f73-47938e1e6df1"]
}, Open  ]],
Cell[44647, 1284, 423, 8, 36, "Text",ExpressionUUID->"d414696f-6259-46fa-9fe8-b0f4243d3343"],
Cell[CellGroupData[{
Cell[45095, 1296, 242, 6, 31, "Input",ExpressionUUID->"9c8f9d34-497d-4bd7-9f4b-1770c0746025"],
Cell[45340, 1304, 234, 6, 31, "Output",ExpressionUUID->"0287c41f-bc0c-46eb-b683-e21c3f776d79"]
}, Open  ]],
Cell[45589, 1313, 571, 10, 50, "Text",ExpressionUUID->"971c41ad-c33f-4790-938f-2859cf0a7f56"],
Cell[CellGroupData[{
Cell[46185, 1327, 322, 8, 31, "Input",ExpressionUUID->"4ef5e046-faed-492e-82e3-54c96eb5f702"],
Cell[46510, 1337, 182, 3, 31, "Output",ExpressionUUID->"62259230-072c-469c-8452-ada5b9bf53fa"]
}, Open  ]],
Cell[46707, 1343, 323, 9, 21, "Text",ExpressionUUID->"76464125-5304-4605-98a8-2ac0a1d2d78c"],
Cell[CellGroupData[{
Cell[47055, 1356, 161, 3, 31, "Input",ExpressionUUID->"8eaf7572-29f2-4909-a7a5-702f2df5c673"],
Cell[47219, 1361, 108, 1, 31, "Output",ExpressionUUID->"d318d5c3-cd78-4ad9-ad8e-91c4c4def82f"]
}, Open  ]],
Cell[47342, 1365, 536, 13, 51, "Text",ExpressionUUID->"c088fc42-172b-4167-93ce-8570e861196a"],
Cell[CellGroupData[{
Cell[47903, 1382, 169, 3, 31, "Input",ExpressionUUID->"a12ae2f4-3090-4d3e-a7be-505b0064d623"],
Cell[48075, 1387, 182, 3, 31, "Output",ExpressionUUID->"1736af2c-78fc-49cb-96de-471c3734f547"]
}, Open  ]],
Cell[CellGroupData[{
Cell[48294, 1395, 168, 3, 31, "Input",ExpressionUUID->"1d95f4c9-20ca-446f-9e9a-c96633e1be57"],
Cell[48465, 1400, 162, 3, 31, "Output",ExpressionUUID->"b14bf0d7-43c2-40c0-8a78-a5e9977b1836"]
}, Open  ]],
Cell[48642, 1406, 332, 7, 36, "Text",ExpressionUUID->"6520bf56-fa44-4537-a6ee-cd859c8f6b3a"],
Cell[CellGroupData[{
Cell[48999, 1417, 321, 8, 31, "Input",ExpressionUUID->"2176c7ac-aa13-4d89-858e-f8b153b1e32e"],
Cell[49323, 1427, 182, 3, 31, "Output",ExpressionUUID->"187e842a-de46-43a5-99e9-98b4d43da51d"]
}, Open  ]],
Cell[49520, 1433, 461, 12, 36, "Text",ExpressionUUID->"3ab8fd89-e71c-4d9d-aa14-58287b155638"],
Cell[CellGroupData[{
Cell[50006, 1449, 247, 6, 31, "Input",ExpressionUUID->"f8beabfc-690f-4832-ac58-15045b66358c"],
Cell[50256, 1457, 108, 1, 31, "Output",ExpressionUUID->"50dd0d9d-3ae0-4492-bbfc-0be4ed6b2463"]
}, Open  ]],
Cell[50379, 1461, 425, 8, 36, "Text",ExpressionUUID->"8d0e7214-843b-4f41-a9ac-8823c26e43f5"],
Cell[CellGroupData[{
Cell[50829, 1473, 138, 2, 31, "Input",ExpressionUUID->"390aeada-eff9-445c-8d93-c3915e2fa9d9"],
Cell[50970, 1477, 124, 2, 31, "Output",ExpressionUUID->"1a433bc3-c40e-4bd1-b437-218e8f8d5449"]
}, Open  ]],
Cell[CellGroupData[{
Cell[51131, 1484, 138, 2, 31, "Input",ExpressionUUID->"66e4abca-f87f-4888-82ec-31b871d2a61f"],
Cell[51272, 1488, 124, 2, 31, "Output",ExpressionUUID->"c36ed259-f65c-4777-9515-8e7599764b8b"]
}, Open  ]],
Cell[51411, 1493, 1226, 31, 66, "Text",ExpressionUUID->"308a6155-887c-4fd3-bf52-69c374c04734"],
Cell[CellGroupData[{
Cell[52662, 1528, 195, 4, 31, "Input",ExpressionUUID->"0717c471-e923-4d91-a2fc-c13dc55dc3a6"],
Cell[52860, 1534, 107, 1, 31, "Output",ExpressionUUID->"5ea9236c-d84c-4cff-afa0-5757885d58c0"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[53016, 1541, 106, 0, 18, "Subsubsection",ExpressionUUID->"cb07fe57-3c47-4972-874b-e7541a727d2a"],
Cell[53125, 1543, 406, 6, 50, "Text",ExpressionUUID->"7d6762bd-65d0-4c05-b09d-aea44bbd6830"],
Cell[53534, 1551, 455, 10, 40, "Text",ExpressionUUID->"e045f207-649e-4b65-87ea-0e11d8154d81"],
Cell[53992, 1563, 706, 19, 55, "Text",ExpressionUUID->"192263eb-ef4d-4dd8-93fb-7f4f14e36f13"],
Cell[54701, 1584, 1151, 21, 34, "myCode",ExpressionUUID->"a9f75772-9c82-4fb6-be6d-cf466fce0198"],
Cell[55855, 1607, 633, 13, 51, "Text",ExpressionUUID->"8319f899-96db-45e5-b4ac-cf86af344ae8"],
Cell[56491, 1622, 623, 13, 55, "Text",ExpressionUUID->"41864553-8168-4f20-8f2a-3542edf27b01"],
Cell[57117, 1637, 567, 16, 31, "Input",ExpressionUUID->"698dec49-4f72-452a-8b48-93c35d4891a2"],
Cell[57687, 1655, 218, 5, 24, "Text",ExpressionUUID->"8c0a5a3e-92d9-404d-a35a-c1c8eee22f80"],
Cell[CellGroupData[{
Cell[57930, 1664, 158, 3, 31, "Input",ExpressionUUID->"ed7489ad-f7a7-4ef6-a09d-2ab391a8397f"],
Cell[58091, 1669, 107, 1, 31, "Output",ExpressionUUID->"9ff2a98f-194a-42ca-bdbf-5ea5d1099c90"]
}, Open  ]],
Cell[CellGroupData[{
Cell[58235, 1675, 158, 3, 31, "Input",ExpressionUUID->"589619c2-6341-4f7c-9594-7c6efb699981"],
Cell[58396, 1680, 107, 1, 31, "Output",ExpressionUUID->"823eecc4-475a-4e25-9849-402c55afd530"]
}, Open  ]],
Cell[CellGroupData[{
Cell[58540, 1686, 159, 3, 31, "Input",ExpressionUUID->"a17abbbe-b43e-47d5-82bd-a2ac8d567ca5"],
Cell[58702, 1691, 570, 13, 108, "Output",ExpressionUUID->"95ba0556-2c46-47e6-b980-ba1d1774cdfa"]
}, Open  ]],
Cell[59287, 1707, 1317, 33, 74, "Text",ExpressionUUID->"978802b3-ad6a-45af-a6b5-461643ca7376"],
Cell[60607, 1742, 247, 6, 31, "Input",ExpressionUUID->"d0f8f5b6-763e-4954-8666-1058b1cc13a9",
 InitializationCell->True],
Cell[60857, 1750, 681, 19, 51, "Input",ExpressionUUID->"4a70430e-1d68-4903-b31c-b4ea275eea1c",
 InitializationCell->True],
Cell[61541, 1771, 131, 0, 20, "Text",ExpressionUUID->"2a3b9682-87cc-45d4-86f2-0958a207c994"],
Cell[CellGroupData[{
Cell[61697, 1775, 159, 3, 31, "Input",ExpressionUUID->"345075b6-b2a6-4304-843b-19eb4afcc465"],
Cell[61859, 1780, 285, 7, 24, "Message",ExpressionUUID->"d823a3ae-6da6-46c3-9a8e-72730b46d4c8"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[62193, 1793, 102, 0, 18, "Subsubsection",ExpressionUUID->"7a8880d9-0506-4c1b-8bd9-d3248bfb8ae6"],
Cell[62298, 1795, 302, 4, 35, "Text",ExpressionUUID->"071d999b-01f1-4d34-aac8-64427db700ec"],
Cell[62603, 1801, 568, 17, 40, "Text",ExpressionUUID->"26f52c64-b683-4b3f-bdbb-ae0254550a94"],
Cell[63174, 1820, 571, 17, 38, "Text",ExpressionUUID->"d9987abf-491f-44b7-93dc-8c118d6d34d4"],
Cell[63748, 1839, 218, 5, 31, "Input",ExpressionUUID->"30e6b2d2-a84e-46f0-b176-7150dd20059d",
 InitializationCell->True],
Cell[63969, 1846, 297, 7, 21, "Text",ExpressionUUID->"7a7945bc-eb95-45bc-8cad-7b70bcf93d66"],
Cell[CellGroupData[{
Cell[64291, 1857, 250, 6, 31, "Input",ExpressionUUID->"88d50cbb-6438-47f5-8e45-bdd0d63f3287"],
Cell[64544, 1865, 198, 4, 31, "Output",ExpressionUUID->"4ff8a4ad-32f9-442d-b665-3307e5993340"]
}, Open  ]],
Cell[64757, 1872, 306, 7, 39, "Text",ExpressionUUID->"7cf352dd-aa67-4e20-adee-e730563477e9"],
Cell[CellGroupData[{
Cell[65088, 1883, 220, 5, 31, "Input",ExpressionUUID->"53da44be-628e-4746-a5f0-0d105f82c502"],
Cell[65311, 1890, 198, 4, 31, "Output",ExpressionUUID->"912c7170-9b1f-4b4e-88cc-ca4ceae7bc6f"]
}, Open  ]],
Cell[65524, 1897, 1946, 57, 73, "Text",ExpressionUUID->"f913754d-dda2-4206-a523-d808faaa31bf"],
Cell[67473, 1956, 281, 8, 31, "Input",ExpressionUUID->"80c37b41-b5ae-4668-ae58-ec4bcfdcf0be",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[67779, 1968, 339, 9, 31, "Input",ExpressionUUID->"5ea47883-d3e2-4436-82b9-ab0a3aebf812"],
Cell[68121, 1979, 312, 9, 34, "Output",ExpressionUUID->"ce059617-08fc-47fb-b9da-81ddf3a391cc"]
}, Open  ]],
Cell[68448, 1991, 396, 11, 21, "Text",ExpressionUUID->"3ae96b85-0cdb-47d5-b8ff-eda36400604b"],
Cell[CellGroupData[{
Cell[68869, 2006, 384, 10, 31, "Input",ExpressionUUID->"bc891f51-b065-459e-ae5a-a7925a5624d5"],
Cell[69256, 2018, 182, 3, 31, "Output",ExpressionUUID->"b298f36b-e69f-43af-8e6a-7697b73c591a"]
}, Open  ]],
Cell[69453, 2024, 947, 20, 86, "Text",ExpressionUUID->"90479869-e881-4a0e-b4fa-cd8ed4ac9f07"],
Cell[70403, 2046, 204, 4, 31, "Input",ExpressionUUID->"302b854e-c91b-4e9f-97ad-4baba163f813",
 InitializationCell->True],
Cell[70610, 2052, 283, 8, 24, "Text",ExpressionUUID->"bf518505-d91c-4428-8d65-31f59bc080dd"],
Cell[CellGroupData[{
Cell[70918, 2064, 319, 8, 31, "Input",ExpressionUUID->"499b10d8-3b7d-436c-bfc2-e9aa45c41e7c"],
Cell[71240, 2074, 182, 3, 31, "Output",ExpressionUUID->"f4fb110a-e8cb-4238-ac0d-f513338427c6"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[71495, 2085, 136, 1, 55, "Section",ExpressionUUID->"24baadba-7542-43af-84e4-181f4a4bb1ec",
 CellTags->"Section2"],
Cell[71634, 2088, 385, 7, 35, "Text",ExpressionUUID->"61915f6c-7ecd-437e-836f-c9913c741f2d"],
Cell[CellGroupData[{
Cell[72044, 2099, 122, 1, 32, "Subsection",ExpressionUUID->"57c1656b-f950-4ad4-829a-bfa697ba05c8",
 CellTags->"Section2a"],
Cell[72169, 2102, 358, 5, 50, "Text",ExpressionUUID->"34b7fa87-c2f9-4395-9c4c-37b533db849a"],
Cell[72530, 2109, 1521, 40, 80, "Text",ExpressionUUID->"60d63228-8079-4cc5-84f7-5bbea0a35a2b"],
Cell[74054, 2151, 576, 15, 62, "Text",ExpressionUUID->"6188f7d7-6615-4f62-a325-56d4e4f79ef6"],
Cell[CellGroupData[{
Cell[74655, 2170, 537, 16, 31, "Input",ExpressionUUID->"381533c6-c463-4264-bbac-d32c93530c5c"],
Cell[75195, 2188, 171, 3, 31, "Output",ExpressionUUID->"91d07e90-63e7-40f7-9af6-61163a094489"]
}, Open  ]],
Cell[75381, 2194, 639, 14, 52, "Text",ExpressionUUID->"07f05c80-921d-4e2f-b7fa-de1775ee9a39"],
Cell[76023, 2210, 455, 9, 36, "Text",ExpressionUUID->"4d95b7b4-71e8-42a7-8df8-d84bf6fe55a8"],
Cell[CellGroupData[{
Cell[76503, 2223, 287, 8, 31, "Input",ExpressionUUID->"3c9fe861-588a-44e2-b6a4-94c90fbb2fbf"],
Cell[76793, 2233, 189, 4, 31, "Output",ExpressionUUID->"c1daba39-4f09-4d87-98c3-188db981c511"]
}, Open  ]],
Cell[76997, 2240, 437, 8, 36, "Text",ExpressionUUID->"7ad7b632-4e11-4f61-9e06-ed90c969da29"],
Cell[CellGroupData[{
Cell[77459, 2252, 352, 10, 31, "Input",ExpressionUUID->"e02237b1-f92d-4282-801e-a63703412eda"],
Cell[77814, 2264, 451, 11, 31, "Output",ExpressionUUID->"98a0f29b-6ab3-4f4b-9d76-511e60d750bb"]
}, Open  ]],
Cell[78280, 2278, 691, 15, 54, "Text",ExpressionUUID->"4300d1e4-d3ee-46cc-b382-819c2d5ef1be"],
Cell[CellGroupData[{
Cell[78996, 2297, 392, 11, 31, "Input",ExpressionUUID->"9414eee6-fb45-475d-ba02-1d6c8469aebe"],
Cell[79391, 2310, 724, 21, 92, "Output",ExpressionUUID->"d8999938-27f1-4e71-9346-b3131d3534c7"]
}, Open  ]],
Cell[80130, 2334, 251, 4, 35, "Text",ExpressionUUID->"63d08faa-4e09-4329-9eaf-54305078c976"],
Cell[CellGroupData[{
Cell[80406, 2342, 326, 9, 31, "Input",ExpressionUUID->"18bd6003-aff1-4582-9eb3-3ff3f0633a2f",
 InitializationCell->True],
Cell[80735, 2353, 239, 6, 31, "Output",ExpressionUUID->"50dc90e9-9272-45af-8092-237ef7c3e2c7"]
}, Open  ]],
Cell[80989, 2362, 252, 6, 21, "Text",ExpressionUUID->"82dd6dce-8a88-4a0c-98e0-1ae535667a85"],
Cell[CellGroupData[{
Cell[81266, 2372, 318, 8, 31, "Input",ExpressionUUID->"59d6ff5c-08ec-46de-87bd-5d3968f2a4b4"],
Cell[81587, 2382, 2766, 78, 200, "Output",ExpressionUUID->"5681ddb0-aa53-438d-8513-592ce559ba15"]
}, Open  ]],
Cell[84368, 2463, 865, 25, 58, "Text",ExpressionUUID->"b12c9d71-e394-4313-a1b0-2aa1b6a70cce"],
Cell[85236, 2490, 623, 16, 35, "Text",ExpressionUUID->"aa431adb-7afd-4056-9c5a-b164f644a147"],
Cell[CellGroupData[{
Cell[85884, 2510, 360, 10, 31, "Input",ExpressionUUID->"4c41e903-6bd4-49e0-908b-44eb9da0c5b5",
 InitializationCell->True],
Cell[86247, 2522, 263, 7, 31, "Output",ExpressionUUID->"45e81280-1fac-4f86-9149-855dd26fb7b0"]
}, Open  ]],
Cell[CellGroupData[{
Cell[86547, 2534, 319, 8, 31, "Input",ExpressionUUID->"f2ec5902-2fe5-473b-bbf2-74a0aa0557c9"],
Cell[86869, 2544, 724, 21, 92, "Output",ExpressionUUID->"ea750458-2e71-474c-a35e-bd1e8f2f481f"]
}, Open  ]],
Cell[87608, 2568, 266, 4, 35, "Text",ExpressionUUID->"b38192ea-b44d-4ce0-be13-13edc0c794e2"],
Cell[87877, 2574, 723, 16, 53, "Text",ExpressionUUID->"1a77e955-d7bd-4a1c-8ea9-78196f55020c"],
Cell[CellGroupData[{
Cell[88625, 2594, 223, 5, 31, "Input",ExpressionUUID->"e733b919-fd1e-49f0-8c9d-f579676160f1"],
Cell[88851, 2601, 110, 1, 31, "Output",ExpressionUUID->"6db4fb37-90b9-4f2e-b3ea-68395a5f47d4"]
}, Open  ]],
Cell[88976, 2605, 373, 7, 36, "Text",ExpressionUUID->"c7b5a468-557c-44e9-a235-1b6fc0bd7e35"],
Cell[CellGroupData[{
Cell[89374, 2616, 234, 5, 31, "Input",ExpressionUUID->"995a32cb-41b3-4ead-bf10-6f9221345713"],
Cell[89611, 2623, 183, 4, 31, "Output",ExpressionUUID->"1e332bf6-23c7-4e55-91b8-746a1a624cd1"]
}, Open  ]],
Cell[89809, 2630, 410, 9, 35, "Text",ExpressionUUID->"4c5e92bf-14d3-42ee-bea0-044fceb6175a"],
Cell[CellGroupData[{
Cell[90244, 2643, 297, 7, 31, "Input",ExpressionUUID->"047b984c-5f07-4973-966f-089a9deacc09"],
Cell[90544, 2652, 330, 9, 31, "Output",ExpressionUUID->"a7b18779-8417-4ada-b577-6b38ee3b8963"]
}, Open  ]],
Cell[90889, 2664, 381, 8, 35, "Text",ExpressionUUID->"f5e0c196-c84f-4914-8887-65bc0ed000fd"],
Cell[CellGroupData[{
Cell[91295, 2676, 221, 5, 31, "Input",ExpressionUUID->"ce59ae3c-5985-4d4a-bf66-3fd4666602b0",
 InitializationCell->True],
Cell[91519, 2683, 292, 8, 31, "Output",ExpressionUUID->"85b15e9a-9864-40f9-8fc7-1a3ca01ecea6"]
}, Open  ]],
Cell[CellGroupData[{
Cell[91848, 2696, 318, 8, 31, "Input",ExpressionUUID->"88c2ff89-d4cc-4f52-a2cd-bf58fcc2197f"],
Cell[92169, 2706, 725, 21, 92, "Output",ExpressionUUID->"abf322a2-d192-4225-818d-5842cec387c7"]
}, Open  ]],
Cell[92909, 2730, 415, 10, 21, "Text",ExpressionUUID->"d5c7413d-5559-4446-9a68-d62ec5f0a7c3"],
Cell[CellGroupData[{
Cell[93349, 2744, 222, 5, 31, "Input",ExpressionUUID->"9342b3dc-d4da-47fe-accd-4730a7a8b8ae"],
Cell[93574, 2751, 111, 1, 31, "Output",ExpressionUUID->"9e0b5ee5-0197-434b-9d57-9c36ea3677a3"]
}, Open  ]],
Cell[CellGroupData[{
Cell[93722, 2757, 233, 5, 31, "Input",ExpressionUUID->"ad758a1e-4a8b-44ba-9ff8-92b3ca6e1e53"],
Cell[93958, 2764, 124, 2, 31, "Output",ExpressionUUID->"1a5e05b8-21a4-4068-92c1-d9e7aed4763e"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[94131, 2772, 114, 1, 32, "Subsection",ExpressionUUID->"eff2eb80-9f53-4d45-96e1-83e66d3c018a",
 CellTags->"Section2b"],
Cell[94248, 2775, 608, 9, 65, "Text",ExpressionUUID->"5201592a-6775-4f90-bb77-2bd659c3ca16"],
Cell[94859, 2786, 1177, 28, 50, "Text",ExpressionUUID->"c45ec1cb-4e12-4a36-82fd-b3ca0ea7d7d2"],
Cell[96039, 2816, 1690, 35, 96, "Text",ExpressionUUID->"f7f6fa69-0383-40dc-b4df-19512823cba2"],
Cell[CellGroupData[{
Cell[97754, 2855, 219, 5, 31, "Input",ExpressionUUID->"f6bba154-f9f0-4d57-aea0-f0125736101a",
 InitializationCell->True],
Cell[97976, 2862, 141, 2, 31, "Output",ExpressionUUID->"eaae6d6c-4dc3-4f7d-a54f-c112e5f77b32"]
}, Open  ]],
Cell[CellGroupData[{
Cell[98154, 2869, 399, 12, 31, "Input",ExpressionUUID->"e5a82c6f-3127-45f7-8276-8fcc47d8ff1e",
 InitializationCell->True],
Cell[98556, 2883, 307, 9, 31, "Output",ExpressionUUID->"c212a42e-476d-444e-b418-23a9f0bd96d1"]
}, Open  ]],
Cell[98878, 2895, 507, 11, 35, "Text",ExpressionUUID->"9f7fedb8-6ae5-4b96-9873-ec5be5d0a1af"],
Cell[CellGroupData[{
Cell[99410, 2910, 268, 6, 31, "Input",ExpressionUUID->"3a2779c4-827c-48ae-9105-c0924321cfa7"],
Cell[99681, 2918, 184, 4, 31, "Output",ExpressionUUID->"f73e81cf-cd3a-4bb8-b54f-54c8ecba5743"]
}, Open  ]],
Cell[99880, 2925, 611, 12, 50, "Text",ExpressionUUID->"b498a621-0ea0-4a4a-99af-d654d9baa7d0"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[100540, 2943, 126, 1, 55, "Section",ExpressionUUID->"d1c43771-0c2f-4dff-b301-9f7e47bf2572",
 CellTags->"Section3"],
Cell[100669, 2946, 556, 12, 50, "Text",ExpressionUUID->"60a1e56b-f383-4224-9cf8-f064fcca4b69"],
Cell[CellGroupData[{
Cell[101250, 2962, 119, 1, 32, "Subsection",ExpressionUUID->"182f68f5-fb92-4249-b54d-1424395ea9ad",
 CellTags->"Section3a"],
Cell[101372, 2965, 1357, 34, 67, "Text",ExpressionUUID->"7bfd1b3d-7dd6-4a0e-8898-36ffb3a30370"],
Cell[102732, 3001, 504, 13, 20, "Text",ExpressionUUID->"b85e8533-aaaf-4674-b6e8-7bf23a1a9411"],
Cell[CellGroupData[{
Cell[103261, 3018, 425, 13, 31, "Input",ExpressionUUID->"cf49e959-2e84-42a0-9c7b-3d8c02a0c7de"],
Cell[103689, 3033, 110, 1, 31, "Output",ExpressionUUID->"23073764-9c86-45f8-b04e-bb5e83083713"]
}, Open  ]],
Cell[103814, 3037, 409, 8, 36, "Text",ExpressionUUID->"4b949389-fda5-42ee-b264-68b73f1b7c20"],
Cell[104226, 3047, 683, 13, 51, "Text",ExpressionUUID->"3d825ea3-dc28-4068-96b5-ea4153cf041e"],
Cell[CellGroupData[{
Cell[104934, 3064, 345, 10, 31, "Input",ExpressionUUID->"ec9e7122-8112-40b4-bfe1-0b14f74ef302"],
Cell[105282, 3076, 110, 1, 31, "Output",ExpressionUUID->"e2c996c7-d51e-4533-acd4-56e1a1715c6b"]
}, Open  ]],
Cell[105407, 3080, 644, 13, 51, "Text",ExpressionUUID->"55ae7410-02c3-4c8d-a13c-eaba23d3cef8"],
Cell[106054, 3095, 320, 8, 31, "Input",ExpressionUUID->"30a91e65-20bf-462e-b265-41812d7c130b",
 InitializationCell->True],
Cell[106377, 3105, 184, 3, 20, "Text",ExpressionUUID->"966903e5-0514-44fe-8b21-b25c426a26a0"],
Cell[CellGroupData[{
Cell[106586, 3112, 344, 10, 31, "Input",ExpressionUUID->"bdf3aea5-101b-4300-b5b9-36efd6293576"],
Cell[106933, 3124, 110, 1, 31, "Output",ExpressionUUID->"f937cfc7-bd5a-4773-b67b-2e3eaccc0807"]
}, Open  ]],
Cell[CellGroupData[{
Cell[107080, 3130, 344, 10, 31, "Input",ExpressionUUID->"04b90f42-1973-4c3f-9ea6-07caa2693e42"],
Cell[107427, 3142, 110, 1, 31, "Output",ExpressionUUID->"27cab972-fa1e-4a85-a352-789e6c20cdda"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[107586, 3149, 128, 1, 32, "Subsection",ExpressionUUID->"5657657d-bbe3-4ee8-80f4-5be8d952f98b",
 CellTags->"Section3b"],
Cell[107717, 3152, 698, 11, 80, "Text",ExpressionUUID->"d2a30189-f32c-4227-baa7-06b7f473d1cc"],
Cell[108418, 3165, 340, 7, 35, "Text",ExpressionUUID->"a35136ca-4871-44d7-9d5a-5bd961731823"],
Cell[108761, 3174, 1219, 26, 115, "Text",ExpressionUUID->"ae744a75-0ca9-406b-82fb-be168384997c"],
Cell[109983, 3202, 294, 4, 35, "Text",ExpressionUUID->"77db9ccb-e553-4176-afd8-44c2321ca0cf"],
Cell[CellGroupData[{
Cell[110302, 3210, 100, 0, 18, "Subsubsection",ExpressionUUID->"b1936b15-ba6e-42e5-94dd-f63af6deaf7f"],
Cell[110405, 3212, 258, 6, 20, "Text",ExpressionUUID->"1fa5b640-903c-41f6-9937-3c6d0f0cfdf0"],
Cell[CellGroupData[{
Cell[110688, 3222, 429, 13, 31, "Input",ExpressionUUID->"36986fca-5508-4eb7-92b3-c44a18f16eb7",
 InitializationCell->True],
Cell[111120, 3237, 360, 11, 31, "Output",ExpressionUUID->"b7c206db-c05c-472c-bdd3-b44d467658f8"]
}, Open  ]],
Cell[111495, 3251, 205, 3, 20, "Text",ExpressionUUID->"8373678a-1606-4ea7-b59d-0bbc870b2522"],
Cell[CellGroupData[{
Cell[111725, 3258, 183, 4, 18, "Subsubsubsection",ExpressionUUID->"30da3d80-9a5e-42ad-9ea3-bb22214f28a6",
 PageBreakWithin->False,
 PageBreakBelow->False],
Cell[111911, 3264, 1346, 30, 78, "Text",ExpressionUUID->"162b5e1b-ebf3-452d-b174-77f11a0a01b0",
 PageBreakAbove->False,
 PageBreakWithin->False],
Cell[CellGroupData[{
Cell[113282, 3298, 159, 3, 31, "Input",ExpressionUUID->"f31a0a93-bd8e-4930-9496-c4dd456c63a8"],
Cell[113444, 3303, 298, 10, 42, "Output",ExpressionUUID->"d9e7da79-43d6-4b9b-8f19-a26792390061"]
}, Open  ]],
Cell[CellGroupData[{
Cell[113779, 3318, 145, 2, 31, "Input",ExpressionUUID->"87bc78ea-f4f6-4b16-bfa1-3996b2cf57d0"],
Cell[113927, 3322, 585, 19, 42, "Output",ExpressionUUID->"3f54f6b3-8945-4fd3-b1de-a06cdc9ccc3f"]
}, Open  ]],
Cell[CellGroupData[{
Cell[114549, 3346, 206, 5, 31, "Input",ExpressionUUID->"476a0905-ae78-43d8-abda-587a644bd6d1"],
Cell[114758, 3353, 318, 10, 42, "Output",ExpressionUUID->"89f9eb61-ea10-4e89-9996-24d9d520e7e0"]
}, Open  ]],
Cell[115091, 3366, 301, 6, 21, "Text",ExpressionUUID->"5084e3b1-266c-45e5-852e-ed3ef938e46e"],
Cell[CellGroupData[{
Cell[115417, 3376, 159, 3, 31, "Input",ExpressionUUID->"c0829565-599e-406e-9209-5f5152bf810d"],
Cell[115579, 3381, 110, 1, 31, "Output",ExpressionUUID->"ea2f42e5-c8ca-4f81-921e-a52dbfc47292"]
}, Open  ]],
Cell[CellGroupData[{
Cell[115726, 3387, 145, 2, 31, "Input",ExpressionUUID->"243111fd-f55e-41b6-a8eb-4c0815f5f8a2"],
Cell[115874, 3391, 109, 1, 31, "Output",ExpressionUUID->"2fc0a823-5bed-4fa4-9848-1986a7ee530c"]
}, Open  ]],
Cell[CellGroupData[{
Cell[116020, 3397, 203, 4, 31, "Input",ExpressionUUID->"d08c0833-8bb7-4e0c-ab81-10508b0ddc28"],
Cell[116226, 3403, 110, 1, 31, "Output",ExpressionUUID->"6181e56e-a296-4fd8-9794-18d3d5ce1aea"]
}, Open  ]],
Cell[116351, 3407, 316, 8, 24, "Text",ExpressionUUID->"4de74996-3a6a-42d2-9bca-261d46be8b88"],
Cell[CellGroupData[{
Cell[116692, 3419, 203, 5, 31, "Input",ExpressionUUID->"790f6f01-9810-413e-a8c5-cc08c90e3f46"],
Cell[116898, 3426, 110, 1, 31, "Output",ExpressionUUID->"a690dbb2-7ce7-4600-a34c-72edce1ee464"]
}, Open  ]],
Cell[CellGroupData[{
Cell[117045, 3432, 165, 3, 31, "Input",ExpressionUUID->"e33f4938-51d6-4b53-9447-018d732435f6"],
Cell[117213, 3437, 109, 1, 31, "Output",ExpressionUUID->"278af99d-060e-4c95-85db-468e775e09f2"]
}, Open  ]],
Cell[CellGroupData[{
Cell[117359, 3443, 223, 5, 31, "Input",ExpressionUUID->"0a8a7368-8304-4a37-b1b5-5015f55c5bd0"],
Cell[117585, 3450, 110, 1, 31, "Output",ExpressionUUID->"87522410-c25f-4a48-af93-029c8138eb40"]
}, Open  ]],
Cell[117710, 3454, 1227, 34, 69, "Text",ExpressionUUID->"51d675da-4059-468f-8aff-cdfe70e4a0e6"],
Cell[CellGroupData[{
Cell[118962, 3492, 429, 12, 31, "Input",ExpressionUUID->"b4ef6750-f8c7-4ae2-a821-f74f29705f15"],
Cell[119394, 3506, 336, 10, 31, "Output",ExpressionUUID->"ee4ce7d4-3848-4804-b6dd-829bb53d8fc0"]
}, Open  ]],
Cell[119745, 3519, 646, 15, 58, "Text",ExpressionUUID->"d5f6e002-6ea0-49c2-b390-4635a60b0bf7"],
Cell[CellGroupData[{
Cell[120416, 3538, 160, 3, 31, "Input",ExpressionUUID->"f0efb962-503f-4ab6-aa5f-50092fcf4d56"],
Cell[120579, 3543, 129, 2, 31, "Output",ExpressionUUID->"faa03dad-2a11-4d08-92e0-5a0a69dee5c3"]
}, Open  ]],
Cell[CellGroupData[{
Cell[120745, 3550, 192, 4, 31, "Input",ExpressionUUID->"043b67aa-0468-4755-a320-89e9b8b7adc6"],
Cell[120940, 3556, 110, 1, 31, "Output",ExpressionUUID->"29f860da-3646-45a9-a65a-1005c77aea85"]
}, Open  ]],
Cell[CellGroupData[{
Cell[121087, 3562, 115, 1, 31, "Input",ExpressionUUID->"be2e94b5-1d11-4406-9c3a-0d41f5797abe"],
Cell[121205, 3565, 152, 3, 31, "Output",ExpressionUUID->"654b2382-1568-4004-8b32-e326a9a7aa3a"]
}, Open  ]],
Cell[121372, 3571, 686, 14, 73, "Text",ExpressionUUID->"2b7eacd1-f376-455f-a5aa-579185b515f4"],
Cell[CellGroupData[{
Cell[122083, 3589, 174, 3, 31, "Input",ExpressionUUID->"10434b51-75d7-4023-86fc-c977ba003bef"],
Cell[122260, 3594, 129, 2, 31, "Output",ExpressionUUID->"1bfd3d82-c611-432e-b953-7cb4e4e2f245"]
}, Open  ]],
Cell[122404, 3599, 813, 21, 59, "Text",ExpressionUUID->"4762d2f6-9e93-4059-9634-19ba4776e456"],
Cell[CellGroupData[{
Cell[123242, 3624, 460, 11, 70, "Input",ExpressionUUID->"0984d7ae-be49-404e-832b-adfaadfb1477"],
Cell[123705, 3637, 149, 3, 24, "Print",ExpressionUUID->"3c736ea3-dbe0-40ce-9b69-58d2e72b17ed"]
}, Open  ]],
Cell[123869, 3643, 692, 20, 43, "Text",ExpressionUUID->"4fb50560-1958-453b-b78e-b1531a4d97c1"]
}, Open  ]],
Cell[CellGroupData[{
Cell[124598, 3668, 111, 0, 18, "Subsubsubsection",ExpressionUUID->"38ce88a6-fd28-426e-bbbc-6c0dd75c44a1"],
Cell[124712, 3670, 525, 8, 69, "Text",ExpressionUUID->"8a868461-fad6-4e28-af14-74eb0ed0a6d1"],
Cell[125240, 3680, 890, 26, 62, "Text",ExpressionUUID->"fcbdc472-be82-4ba8-9366-175ccd535d18"],
Cell[CellGroupData[{
Cell[126155, 3710, 177, 3, 31, "Input",ExpressionUUID->"125a2f22-c891-4cc2-9b6e-98f026541344"],
Cell[126335, 3715, 336, 10, 31, "Output",ExpressionUUID->"6d3ba035-bcc6-4535-a959-baded61b85c9"]
}, Open  ]],
Cell[126686, 3728, 184, 3, 20, "Text",ExpressionUUID->"284b452a-6c5d-40e2-8305-83338074e5ab"],
Cell[126873, 3733, 443, 10, 39, "Text",ExpressionUUID->"49687ff4-16ce-4caa-ab9b-f6221e40ddc7"],
Cell[CellGroupData[{
Cell[127341, 3747, 169, 3, 31, "Input",ExpressionUUID->"2b6dd508-8d3e-4324-98f9-63cbea95e734"],
Cell[127513, 3752, 246, 7, 31, "Output",ExpressionUUID->"367a9ea3-86c2-445d-8194-2ffd5cd703a8"]
}, Open  ]],
Cell[127774, 3762, 310, 8, 24, "Text",ExpressionUUID->"c23a3063-d1a5-4d86-b05e-8fce48ace813"],
Cell[CellGroupData[{
Cell[128109, 3774, 250, 6, 31, "Input",ExpressionUUID->"bc14d31f-7a9c-42fd-88c4-90810cd523f2"],
Cell[128362, 3782, 110, 1, 31, "Output",ExpressionUUID->"c9cdfb34-b7a2-4a44-b538-8540692206e4"]
}, Open  ]],
Cell[128487, 3786, 220, 5, 24, "Text",ExpressionUUID->"6b4984b0-da75-4cb4-9bfb-b6e754bbb93c"],
Cell[CellGroupData[{
Cell[128732, 3795, 139, 2, 31, "Input",ExpressionUUID->"015cc428-ae70-406a-a141-50749b780272"],
Cell[128874, 3799, 310, 9, 31, "Output",ExpressionUUID->"c85368d9-17cc-4d99-8d37-ad206f3b5c03"]
}, Open  ]],
Cell[129199, 3811, 517, 11, 54, "Text",ExpressionUUID->"6f2deef3-ad11-4324-8a90-5dfa281dbb98"],
Cell[CellGroupData[{
Cell[129741, 3826, 188, 3, 31, "Input",ExpressionUUID->"3e513f25-7710-4764-a7bb-65bcf4724904"],
Cell[129932, 3831, 265, 7, 31, "Output",ExpressionUUID->"3f41d7ce-fb79-4a3d-b0e5-0ccfff32aee2"]
}, Open  ]],
Cell[130212, 3841, 429, 10, 43, "Text",ExpressionUUID->"487ca5b3-d9d5-49ce-b928-fe099743040b"],
Cell[CellGroupData[{
Cell[130666, 3855, 288, 7, 51, "Input",ExpressionUUID->"f7e02cb1-333b-45bb-b646-a202b75e815d"],
Cell[130957, 3864, 293, 9, 31, "Output",ExpressionUUID->"8e05dc57-5b56-4287-a42a-43acc2b286eb"]
}, Open  ]],
Cell[131265, 3876, 259, 6, 21, "Text",ExpressionUUID->"c1c4c12a-95fa-463d-a8ad-8d22f9e4f3e8"],
Cell[CellGroupData[{
Cell[131549, 3886, 192, 4, 31, "Input",ExpressionUUID->"4510c7c9-57ae-4765-af81-a6b5bbcf0074"],
Cell[131744, 3892, 254, 7, 31, "Output",ExpressionUUID->"2abb8368-7e5e-4586-9f1e-7039fdea84ba"]
}, Open  ]],
Cell[132013, 3902, 302, 7, 43, "Text",ExpressionUUID->"06677933-8a48-452d-9f54-0b9dfd7d89d0"],
Cell[CellGroupData[{
Cell[132340, 3913, 292, 8, 51, "Input",ExpressionUUID->"58fcd2ad-1e2f-40a7-8a03-5a67a4f33fe7"],
Cell[132635, 3923, 279, 8, 31, "Output",ExpressionUUID->"d692da43-c573-4fed-ba43-a30591849bde"]
}, Open  ]],
Cell[132929, 3934, 109, 0, 20, "Text",ExpressionUUID->"7327b388-9b80-44ab-b1d7-a9f6873464c5"],
Cell[CellGroupData[{
Cell[133063, 3938, 202, 4, 31, "Input",ExpressionUUID->"72e64f45-85e2-4829-b69d-2675991f72bc"],
Cell[133268, 3944, 238, 6, 31, "Output",ExpressionUUID->"2c0aca83-d45c-46ab-8032-ffb43929b90e"]
}, Open  ]],
Cell[133521, 3953, 375, 9, 40, "Text",ExpressionUUID->"d9ad8700-8cfc-480a-a05a-86d5ebad6825"],
Cell[CellGroupData[{
Cell[133921, 3966, 361, 10, 51, "Input",ExpressionUUID->"c85b8a82-fb18-45ca-b4d3-4d1d87f5a863"],
Cell[134285, 3978, 219, 5, 31, "Output",ExpressionUUID->"d8499665-17ee-4b90-bd5b-08c60ce6a967"]
}, Open  ]],
Cell[134519, 3986, 107, 0, 20, "Text",ExpressionUUID->"1932f69e-4992-4b95-94e2-daad75455c24"],
Cell[CellGroupData[{
Cell[134651, 3990, 361, 10, 51, "Input",ExpressionUUID->"8011c0cc-2c21-4621-bd7c-ee94b581045a"],
Cell[135015, 4002, 199, 5, 31, "Output",ExpressionUUID->"058b45a9-2806-4358-b77b-6a43e486df33"]
}, Open  ]],
Cell[135229, 4010, 306, 7, 21, "Text",ExpressionUUID->"c2cc256b-6617-42b4-bd5c-2fd759cbcf8d"],
Cell[CellGroupData[{
Cell[135560, 4021, 201, 4, 31, "Input",ExpressionUUID->"7f5b3f4c-25e7-4561-8366-485d9d4d2226"],
Cell[135764, 4027, 176, 4, 31, "Output",ExpressionUUID->"c8091f4a-5f4e-4825-8f81-9f45e172d6aa"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[135989, 4037, 95, 0, 18, "Subsubsubsection",ExpressionUUID->"7d78b511-90fd-4761-8f10-3141e2fe0e2b"],
Cell[136087, 4039, 144, 2, 20, "Text",ExpressionUUID->"b106c9cd-a53e-44d2-957e-437c85490082"],
Cell[CellGroupData[{
Cell[136256, 4045, 361, 6, 33, "Item1Numbered",ExpressionUUID->"f5a3b4e4-1aa9-4627-ba3c-e191ea21732f"],
Cell[136620, 4053, 317, 5, 33, "Item1Numbered",ExpressionUUID->"1e395f72-7e47-4ff3-b659-c3d297a9c3b4"],
Cell[136940, 4060, 328, 10, 20, "Item1Numbered",ExpressionUUID->"208ee43a-2fa1-411e-ae6a-ada4025afbc7"],
Cell[CellGroupData[{
Cell[137293, 4074, 241, 5, 19, "Item2",ExpressionUUID->"34363c08-2a94-46fa-8a58-c3d891d87fd4"],
Cell[137537, 4081, 314, 8, 32, "Item2",ExpressionUUID->"c00062e0-b79e-4ce1-bc05-20c57a0186bf"]
}, Open  ]],
Cell[137866, 4092, 575, 13, 34, "Item1Numbered",ExpressionUUID->"973691e3-f2c6-44b5-bf5b-0b89afcb170d"]
}, Open  ]],
Cell[138456, 4108, 98, 0, 20, "Text",ExpressionUUID->"f4bd4754-3f0b-4699-bf4b-24cacf7de99c"],
Cell[138557, 4110, 1314, 36, 203, "Input",ExpressionUUID->"2ea470f6-13ae-4643-8025-c38bce85f7f3",
 InitializationCell->True],
Cell[139874, 4148, 1158, 26, 90, "Text",ExpressionUUID->"c825b27d-a50f-4278-9b26-620ac28632ca"],
Cell[141035, 4176, 1035, 28, 78, "Text",ExpressionUUID->"a86eb70f-d205-41d2-bf70-ce9688d8bd73"],
Cell[142073, 4206, 667, 16, 59, "Text",ExpressionUUID->"5e50ba9a-14e9-4aae-8149-f162c99fac62"],
Cell[142743, 4224, 175, 4, 24, "Text",ExpressionUUID->"4e65ece0-d83e-492f-a8b1-3cff74095e50"],
Cell[CellGroupData[{
Cell[142943, 4232, 152, 3, 31, "Input",ExpressionUUID->"44115001-d8c0-4356-96ac-246fdff861ee"],
Cell[143098, 4237, 176, 4, 31, "Output",ExpressionUUID->"158bdcdc-bd71-46ca-a01e-d24e57071254"]
}, Open  ]],
Cell[CellGroupData[{
Cell[143311, 4246, 342, 10, 31, "Input",ExpressionUUID->"e054a56d-18a2-4b67-8591-505562370abc"],
Cell[143656, 4258, 186, 4, 31, "Output",ExpressionUUID->"9571ea5a-9868-4c6d-ad12-a970519d4f37"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[143903, 4269, 103, 0, 18, "Subsubsection",ExpressionUUID->"9e1a4a2b-5703-4a5a-95a2-55bd11435859"],
Cell[144009, 4271, 416, 6, 50, "Text",ExpressionUUID->"ce5a3476-de32-4c37-b7e9-e39af87044bd"],
Cell[144428, 4279, 280, 6, 39, "Text",ExpressionUUID->"badef55c-a252-49e0-ac4e-df48a55749b9"],
Cell[CellGroupData[{
Cell[144733, 4289, 215, 5, 31, "Input",ExpressionUUID->"35ad0a21-68d9-4445-b0d4-de5b161936f6",
 InitializationCell->True],
Cell[144951, 4296, 176, 4, 31, "Output",ExpressionUUID->"d87b241a-400c-4104-bfbe-5c81713574cc"]
}, Open  ]],
Cell[CellGroupData[{
Cell[145164, 4305, 250, 7, 31, "Input",ExpressionUUID->"f79840f8-0775-43c4-b738-d1a2102089aa",
 InitializationCell->True],
Cell[145417, 4314, 189, 4, 31, "Output",ExpressionUUID->"8a54bac5-271e-41b8-86c2-41b72d1eb943"]
}, Open  ]],
Cell[145621, 4321, 373, 8, 39, "Text",ExpressionUUID->"5101f1ec-b298-4cca-bb14-cff27eb708f5"],
Cell[CellGroupData[{
Cell[146019, 4333, 108, 0, 18, "Subsubsubsection",ExpressionUUID->"fc55c09b-367a-4462-ab67-694918c9c2b7"],
Cell[146130, 4335, 1451, 44, 58, "Text",ExpressionUUID->"7b17f846-ffaf-41b4-a9d7-5f3e3477c7dd"],
Cell[CellGroupData[{
Cell[147606, 4383, 346, 9, 31, "Input",ExpressionUUID->"23455d46-0565-47f1-bad9-46eaa0d0df21"],
Cell[147955, 4394, 115, 2, 31, "Output",ExpressionUUID->"66bda1d2-0b9b-4a7c-b4da-b03a1f2b367b"]
}, Open  ]],
Cell[148085, 4399, 463, 11, 62, "Text",ExpressionUUID->"083dfe74-dae1-4335-8607-100ebc94b5f2"],
Cell[148551, 4412, 1283, 32, 68, "Text",ExpressionUUID->"bb942c0e-4e1f-4f63-984f-089565066b12"],
Cell[CellGroupData[{
Cell[149859, 4448, 346, 10, 31, "Input",ExpressionUUID->"c3dafc4e-c25d-456b-9efd-27b7cccbc99b"],
Cell[150208, 4460, 238, 7, 31, "Output",ExpressionUUID->"1130a896-68bb-4070-be0b-54724a4dfba8"]
}, Open  ]],
Cell[150461, 4470, 405, 11, 40, "Text",ExpressionUUID->"e2709b16-e66b-4a09-b27d-6bb25b3341b5"],
Cell[CellGroupData[{
Cell[150891, 4485, 242, 6, 31, "Input",ExpressionUUID->"e1ad949b-aa01-4bb1-9e8d-37f270e300a2"],
Cell[151136, 4493, 309, 8, 31, "Output",ExpressionUUID->"a51bc274-d022-430e-b420-82e12d537658"]
}, Open  ]],
Cell[151460, 4504, 126, 0, 20, "Text",ExpressionUUID->"94767f99-ab6b-4b2f-a033-40aa31cadc58"],
Cell[CellGroupData[{
Cell[151611, 4508, 280, 8, 31, "Input",ExpressionUUID->"a50ec113-2d30-41f8-a8c6-17149fb2c7c6"],
Cell[151894, 4518, 115, 2, 31, "Output",ExpressionUUID->"6750ae62-b5c3-4eee-9a24-ced7bac8cc33"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[152058, 4526, 121, 0, 18, "Subsubsubsection",ExpressionUUID->"679898b5-6a97-49c3-bddd-a59099117499"],
Cell[152182, 4528, 924, 12, 110, "Text",ExpressionUUID->"928fd145-cf55-46f2-ae21-c89e6e14ba7b"],
Cell[153109, 4542, 1287, 25, 102, "Text",ExpressionUUID->"0fc627f3-e4cf-46ac-a091-5b8f0ae1be78"],
Cell[154399, 4569, 1336, 34, 222, "Input",ExpressionUUID->"0fbb5a2d-dc4c-43fc-8b5a-684ed39e3e86",
 InitializationCell->True],
Cell[155738, 4605, 683, 21, 58, "Text",ExpressionUUID->"b783806f-62b1-4283-b522-86eb5fe73f80"],
Cell[156424, 4628, 1499, 38, 116, "Text",ExpressionUUID->"ae9f0b87-79a3-4e76-9025-6bae648620e2"],
Cell[157926, 4668, 1017, 21, 85, "Text",ExpressionUUID->"f95fa800-7040-4f64-8002-38861780310b"],
Cell[158946, 4691, 2865, 77, 161, "Text",ExpressionUUID->"9b0900d9-d64a-44c5-bf86-79b7178a81e0"],
Cell[161814, 4770, 1209, 26, 84, "Text",ExpressionUUID->"5f137c2f-e206-435f-83f4-aa0cf08bd103"],
Cell[163026, 4798, 1013, 28, 74, "Text",ExpressionUUID->"f6fe86db-584d-4c8e-b4ef-b1493c61d64a"],
Cell[CellGroupData[{
Cell[164064, 4830, 573, 15, 108, "Input",ExpressionUUID->"93572eda-4778-4835-8971-171851e0a0ab"],
Cell[CellGroupData[{
Cell[164662, 4849, 200, 5, 24, "Print",ExpressionUUID->"227b85b6-d0c4-4b58-8b37-0e649b58aed0"],
Cell[164865, 4856, 199, 5, 24, "Print",ExpressionUUID->"9e20801f-b026-4df6-9bbb-3871bf614df7"],
Cell[165067, 4863, 199, 5, 24, "Print",ExpressionUUID->"8064f83c-c4c5-469d-a57c-39d483862a56"],
Cell[165269, 4870, 198, 5, 24, "Print",ExpressionUUID->"d389b949-2a0d-4a34-b37f-8de268d89633"],
Cell[165470, 4877, 199, 5, 24, "Print",ExpressionUUID->"9d030824-ec5a-45cd-81df-f3b8937d8621"],
Cell[165672, 4884, 198, 5, 24, "Print",ExpressionUUID->"bdde56ea-a378-4b37-b064-7688a9b92071"],
Cell[165873, 4891, 198, 5, 24, "Print",ExpressionUUID->"e776aeab-0322-4c55-8b0d-e1fa6a70e9a2"],
Cell[166074, 4898, 197, 5, 24, "Print",ExpressionUUID->"687da84f-8636-4627-bf71-3cc8d8d542ea"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[166344, 4911, 114, 0, 18, "Subsubsection",ExpressionUUID->"161f7fa9-700b-450d-943a-2f6a224bea2c"],
Cell[166461, 4913, 326, 7, 39, "Text",ExpressionUUID->"ffb71287-8a08-4147-bece-d6ef27785827"],
Cell[166790, 4922, 104, 0, 20, "Text",ExpressionUUID->"1e62e130-31af-4947-a8fb-5e28260ddd54"],
Cell[CellGroupData[{
Cell[166919, 4926, 818, 18, 67, "Item1Numbered",ExpressionUUID->"2aa43262-b75a-447a-915e-ee43e55be074"],
Cell[167740, 4946, 885, 25, 50, "Item1Numbered",ExpressionUUID->"68da14e6-0fff-469d-bdca-a07e6df07db0"],
Cell[168628, 4973, 684, 16, 45, "Item1Numbered",ExpressionUUID->"e7120b9b-d409-44e2-8f20-a29c697b49a9"]
}, Open  ]],
Cell[169327, 4992, 1825, 45, 279, "Input",ExpressionUUID->"8e85afbb-95ad-4d00-a6c4-f2baea508919",
 InitializationCell->True],
Cell[171155, 5039, 637, 18, 35, "Text",ExpressionUUID->"590c705a-ad4f-47da-8438-a62801eb5ab8"],
Cell[CellGroupData[{
Cell[171817, 5061, 388, 13, 31, "Input",ExpressionUUID->"3e1257a4-36c8-44e7-9683-be0addd70a28"],
Cell[172208, 5076, 114, 2, 31, "Output",ExpressionUUID->"86a7e7a7-b4e5-4658-9d24-947631796a13"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[172383, 5085, 248, 7, 33, "Subsection",ExpressionUUID->"53c75699-a838-4dd1-ba94-9aed834605a6",
 CellTags->"Section3c"],
Cell[172634, 5094, 1195, 28, 85, "Text",ExpressionUUID->"089511e4-4183-4d25-ae0a-ed8a2eb60f18"],
Cell[173832, 5124, 769, 17, 69, "Text",ExpressionUUID->"6349eb35-5181-40f2-bd6a-57a5be2a984d"],
Cell[174604, 5143, 255, 6, 21, "Text",ExpressionUUID->"5f43e0ae-e3f1-44c0-ba1a-e3def6f7d1d0"],
Cell[CellGroupData[{
Cell[174884, 5153, 346, 10, 31, "Input",ExpressionUUID->"a1a24401-7c63-418a-87c0-7e2479e27034"],
Cell[175233, 5165, 1380, 44, 51, "Output",ExpressionUUID->"1f2f8385-f12f-4907-8493-aa4a743adf2c"]
}, Open  ]],
Cell[176628, 5212, 294, 6, 21, "Text",ExpressionUUID->"c0590f50-f258-48e8-8d26-6e92c4d54dfb"],
Cell[CellGroupData[{
Cell[176947, 5222, 387, 11, 31, "Input",ExpressionUUID->"c94bea44-7abe-4352-ae72-1511f6c96846"],
Cell[177337, 5235, 1160, 36, 51, "Output",ExpressionUUID->"46aee8d0-3216-4b01-bf89-1a7a25a8122e"]
}, Open  ]],
Cell[178512, 5274, 1639, 46, 88, "Text",ExpressionUUID->"bea6d659-1289-4363-9cea-8630c8b2dadf"],
Cell[CellGroupData[{
Cell[180176, 5324, 307, 9, 31, "Input",ExpressionUUID->"39d0ede0-3a1f-4f84-9ad1-f349fd9d2aee"],
Cell[180486, 5335, 553, 17, 31, "Output",ExpressionUUID->"e60fc088-4425-4d56-ab7e-5990f41193fa"]
}, Open  ]],
Cell[181054, 5355, 500, 15, 21, "Text",ExpressionUUID->"b509f69b-52b9-4260-a583-d3d082adf72f"],
Cell[CellGroupData[{
Cell[181579, 5374, 521, 15, 70, "Input",ExpressionUUID->"fefe3f2e-a4d3-4606-b3f7-d0831c42d79c"],
Cell[182103, 5391, 3654, 115, 146, "Output",ExpressionUUID->"df292302-00b9-499e-8baf-09e13e16417b"]
}, Open  ]],
Cell[185772, 5509, 174, 3, 20, "Text",ExpressionUUID->"0c428db2-4613-4aca-895a-3b0360cfe609"],
Cell[185949, 5514, 620, 18, 70, "Input",ExpressionUUID->"13b35d7b-2450-4a70-947e-31f1b19ad99f",
 InitializationCell->True],
Cell[186572, 5534, 659, 18, 36, "Text",ExpressionUUID->"ad0bee34-d159-42f9-8963-f8b3421b9fe4"],
Cell[187234, 5554, 677, 22, 46, "Equation",ExpressionUUID->"9566868b-5d57-4b3e-b748-8c87e82467f6"],
Cell[187914, 5578, 677, 22, 46, "Equation",ExpressionUUID->"9df1633e-cdf9-4211-b173-e65e72eb35f1"],
Cell[188594, 5602, 826, 27, 47, "Equation",ExpressionUUID->"ce646161-14ef-499e-8772-7ee7507bf7ca"],
Cell[189423, 5631, 852, 28, 47, "Equation",ExpressionUUID->"2853657b-6d84-492c-90e7-b59b33bc0e0e"],
Cell[190278, 5661, 4593, 132, 393, "Input",ExpressionUUID->"121fac05-c88f-4de2-9bee-58da1667db8e",
 InitializationCell->True],
Cell[194874, 5795, 899, 18, 68, "Text",ExpressionUUID->"3f20d0fa-6cdf-414f-9473-888f98f09aff"],
Cell[CellGroupData[{
Cell[195798, 5817, 202, 5, 31, "Input",ExpressionUUID->"91f6f630-56c0-4b1f-80ab-36a09d449a93"],
Cell[196003, 5824, 415, 12, 31, "Output",ExpressionUUID->"9c816004-d8fc-4d85-a06c-391a212a0c45"]
}, Open  ]],
Cell[196433, 5839, 270, 6, 21, "Text",ExpressionUUID->"1892006b-bd60-4fe1-b464-19e04701a0dc"],
Cell[CellGroupData[{
Cell[196728, 5849, 234, 7, 31, "Input",ExpressionUUID->"24718d7c-b820-43c2-a982-0aa293491ffd"],
Cell[196965, 5858, 326, 11, 81, "Output",ExpressionUUID->"804080e6-df66-47c8-b4c1-333c1382e76c"]
}, Open  ]],
Cell[197306, 5872, 724, 18, 43, "Text",ExpressionUUID->"491aa4a8-4c96-4def-b8d9-44e13aef428b"],
Cell[198033, 5892, 1036, 27, 127, "Input",ExpressionUUID->"4c311128-1f68-42e2-83f7-423da98c22f2",
 InitializationCell->True],
Cell[199072, 5921, 342, 8, 20, "Text",ExpressionUUID->"1b6cde39-6ee4-4254-bfe7-91d47596fc1e"],
Cell[CellGroupData[{
Cell[199439, 5933, 143, 3, 31, "Input",ExpressionUUID->"442e29ca-df46-4ea8-a893-fef67e6a102f"],
Cell[199585, 5938, 855, 15, 149, "Output",ExpressionUUID->"0df03c5f-e0f7-4b9f-9c3f-0d0894678032"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[200501, 5960, 127, 1, 55, "Section",ExpressionUUID->"7ac4187e-7018-405a-a934-849880f911c8",
 CellTags->"Section4"],
Cell[200631, 5963, 491, 11, 35, "Text",ExpressionUUID->"fb515fb4-4e9b-490d-ad8c-7bb7989064d9"],
Cell[201125, 5976, 815, 20, 39, "Text",ExpressionUUID->"66681dec-7ab8-48ef-a7e3-b7980ebedeaf"],
Cell[201943, 5998, 214, 6, 31, "Input",ExpressionUUID->"259a7f79-e340-44b3-aa00-47add05c7af1",
 InitializationCell->True],
Cell[202160, 6006, 185, 3, 20, "Text",ExpressionUUID->"afc2a70c-bd58-45f9-8194-3866cd378523"],
Cell[CellGroupData[{
Cell[202370, 6013, 139, 3, 31, "Input",ExpressionUUID->"16928c9c-9c17-4385-a76e-c5ab6c6ba14e"],
Cell[202512, 6018, 114, 2, 31, "Output",ExpressionUUID->"073b5552-c3d0-4c80-b10b-f21a2e87d63a"]
}, Open  ]],
Cell[CellGroupData[{
Cell[202663, 6025, 157, 4, 31, "Input",ExpressionUUID->"81277a35-5c49-4523-9238-8584b1079d5a"],
Cell[202823, 6031, 115, 2, 31, "Output",ExpressionUUID->"1e1197b4-d1f3-49a2-b940-ef9366134a20"]
}, Open  ]],
Cell[CellGroupData[{
Cell[202975, 6038, 155, 2, 32, "Subsection",ExpressionUUID->"86ae9358-2b36-46f6-ae75-fdd8851cce21",
 PageBreakWithin->False,
 CellTags->"Section4a"],
Cell[203133, 6042, 908, 23, 51, "Text",ExpressionUUID->"51b611d2-d9c9-4952-bace-54263f121c80",
 PageBreakAbove->False,
 PageBreakWithin->False],
Cell[CellGroupData[{
Cell[204066, 6069, 194, 5, 31, "Input",ExpressionUUID->"a672e207-a1dc-4018-bbe0-dc4a6ba64267"],
Cell[204263, 6076, 186, 5, 31, "Output",ExpressionUUID->"87abafd8-9258-4d53-bd64-6517c7f54b93"]
}, Open  ]],
Cell[204464, 6084, 308, 6, 20, "Text",ExpressionUUID->"14c615b0-2616-4bd9-a437-66a81e7561b1"],
Cell[CellGroupData[{
Cell[204797, 6094, 209, 6, 31, "Input",ExpressionUUID->"3fbb54c3-a59b-4674-ba44-39b8e837bc88"],
Cell[205009, 6102, 200, 6, 31, "Output",ExpressionUUID->"b4058d61-bbfc-4b0f-9f51-ab2395c2720c"]
}, Open  ]],
Cell[205224, 6111, 1215, 34, 51, "Text",ExpressionUUID->"b8c7d35f-9d26-4d45-8923-0e876cdebde7"],
Cell[CellGroupData[{
Cell[206464, 6149, 243, 7, 31, "Input",ExpressionUUID->"2bc09a72-5b22-413c-873c-98fc5d47d67a"],
Cell[206710, 6158, 249, 8, 34, "Output",ExpressionUUID->"ac25050d-b7f3-457a-887d-2dabacbee653"]
}, Open  ]],
Cell[206974, 6169, 949, 22, 55, "Text",ExpressionUUID->"7ec7bc49-9aa6-47ee-9aad-e1f774e1e38e"],
Cell[CellGroupData[{
Cell[207948, 6195, 288, 8, 31, "Input",ExpressionUUID->"4c2e7f24-78a6-46fe-a078-11d498eddd01"],
Cell[208239, 6205, 297, 10, 34, "Output",ExpressionUUID->"c975001c-9951-45ba-bf72-4d24565ea1fb"]
}, Open  ]],
Cell[208551, 6218, 957, 30, 37, "Text",ExpressionUUID->"282b2b93-1967-4848-89d0-5820524025e0"]
}, Open  ]],
Cell[CellGroupData[{
Cell[209545, 6253, 138, 1, 32, "Subsection",ExpressionUUID->"64525962-1926-46a2-9954-94bc18205665",
 CellTags->"Section4b"],
Cell[209686, 6256, 567, 13, 51, "Text",ExpressionUUID->"5de76538-fba7-40a6-8be4-358ad4fc77bc"],
Cell[CellGroupData[{
Cell[210278, 6273, 246, 7, 31, "Input",ExpressionUUID->"2f4a9328-cdee-4bbf-a3a2-e29656b36d20"],
Cell[210527, 6282, 114, 2, 31, "Output",ExpressionUUID->"0b730876-2f31-4997-ada1-9e69742324bd"]
}, Open  ]],
Cell[CellGroupData[{
Cell[210678, 6289, 281, 8, 31, "Input",ExpressionUUID->"e6f630bb-9a65-4e5a-b543-b60a98907f62"],
Cell[210962, 6299, 114, 2, 31, "Output",ExpressionUUID->"2ef8fc0c-da37-4df5-a3fb-b531a1e82c82"]
}, Open  ]],
Cell[CellGroupData[{
Cell[211113, 6306, 327, 9, 31, "Input",ExpressionUUID->"001cca99-3401-4c81-89bb-648c2ee633e1"],
Cell[211443, 6317, 115, 2, 31, "Output",ExpressionUUID->"78a88562-b7f4-43ba-9430-8e3cdad7e196"]
}, Open  ]],
Cell[211573, 6322, 760, 21, 37, "Text",ExpressionUUID->"9d01af5a-0d6a-42e5-8ec4-5967b3be3992"],
Cell[CellGroupData[{
Cell[212358, 6347, 285, 9, 31, "Input",ExpressionUUID->"c159063e-43cf-47da-a734-abbf1a7309a3"],
Cell[212646, 6358, 115, 2, 31, "Output",ExpressionUUID->"204f488c-a8ba-4a6c-beb4-f9310637a049"]
}, Open  ]],
Cell[212776, 6363, 141, 2, 20, "Text",ExpressionUUID->"1a94f2e9-3a01-466d-aa29-12f89b68ad86"],
Cell[CellGroupData[{
Cell[212942, 6369, 289, 9, 31, "Input",ExpressionUUID->"68e229c7-a331-4932-8735-d496c12bf297"],
Cell[213234, 6380, 114, 2, 31, "Output",ExpressionUUID->"b1b77307-cccf-457d-add5-21f60f1cd7c4"]
}, Open  ]],
Cell[213363, 6385, 958, 25, 57, "Text",ExpressionUUID->"0a29036b-133f-4220-88af-efe2d5c6c29c"],
Cell[CellGroupData[{
Cell[214346, 6414, 258, 7, 31, "Input",ExpressionUUID->"6ef81ea4-8830-4025-a388-67eb3a9db41f"],
Cell[214607, 6423, 114, 2, 31, "Output",ExpressionUUID->"ef97b549-cf0f-49d9-991d-4bbd1a52784c"]
}, Open  ]],
Cell[214736, 6428, 503, 13, 38, "Text",ExpressionUUID->"4251d830-2e08-4793-84ff-c61a26dba6b1"],
Cell[CellGroupData[{
Cell[215264, 6445, 227, 6, 31, "Input",ExpressionUUID->"d8ec0d51-bb2d-4821-bbd4-548386240dc1"],
Cell[215494, 6453, 186, 5, 31, "Output",ExpressionUUID->"be7336c3-8144-4f21-9bdd-3af42c3d51ea"]
}, Open  ]],
Cell[215695, 6461, 362, 8, 36, "Text",ExpressionUUID->"5ae01562-6f36-4754-bfbf-76390ee2a503"],
Cell[CellGroupData[{
Cell[216082, 6473, 240, 7, 31, "Input",ExpressionUUID->"8a4daccc-ab9d-4bd6-ba76-068fa380d212"],
Cell[216325, 6482, 539, 18, 35, "Output",ExpressionUUID->"8ba2d043-29d2-47eb-bf4e-32242813f243"]
}, Open  ]],
Cell[216879, 6503, 481, 10, 50, "Text",ExpressionUUID->"8446cfe2-3d02-4da8-bc7e-fdfdb702b4a2"],
Cell[CellGroupData[{
Cell[217385, 6517, 258, 7, 31, "Input",ExpressionUUID->"640e90ee-ced2-4099-a756-9a04c183b67d"],
Cell[217646, 6526, 186, 5, 31, "Output",ExpressionUUID->"94f876e5-31c4-48d2-8e14-4ca61f7a0f66"]
}, Open  ]],
Cell[217847, 6534, 1095, 28, 66, "Text",ExpressionUUID->"7a85d388-2186-43ec-9bcf-7c7375fa32da"],
Cell[CellGroupData[{
Cell[218967, 6566, 287, 9, 31, "Input",ExpressionUUID->"6474f60d-5e31-43f2-877d-5798c3b9e23b"],
Cell[219257, 6577, 140, 3, 31, "Output",ExpressionUUID->"fb8c1ad2-ffc3-4eec-9ec9-20ee2f8bb10a"]
}, Open  ]],
Cell[219412, 6583, 443, 11, 20, "Text",ExpressionUUID->"f7a3c70c-36ef-402b-ab02-e0508216c4b4"],
Cell[219858, 6596, 238, 5, 21, "Text",ExpressionUUID->"489b0158-549f-45f6-8b2e-3dadd3b1a25c"],
Cell[CellGroupData[{
Cell[220121, 6605, 302, 9, 31, "Input",ExpressionUUID->"6eadd3e4-9309-4856-8f12-7961297be089"],
Cell[220426, 6616, 147, 3, 31, "Output",ExpressionUUID->"34b3fb7f-ef73-4d42-96b7-b3ccad09f337"]
}, Open  ]],
Cell[220588, 6622, 863, 22, 53, "Text",ExpressionUUID->"43f05aad-22c7-4308-bb11-b9d76341b7fb"],
Cell[CellGroupData[{
Cell[221476, 6648, 287, 9, 31, "Input",ExpressionUUID->"f43b30b6-2f4c-452c-8936-c31d1caece33"],
Cell[221766, 6659, 114, 2, 31, "Output",ExpressionUUID->"67771b68-2c10-407a-bf3d-d261b5c00f46"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[221941, 6668, 119, 1, 55, "Section",ExpressionUUID->"4a07aace-d433-46de-b92c-4cb22ecf3437",
 CellTags->"Section5"],
Cell[222063, 6671, 220, 3, 35, "Text",ExpressionUUID->"0b61273c-bb7c-4c10-acd4-b49739288700"],
Cell[222286, 6676, 1199, 37, 57, "Text",ExpressionUUID->"8b99d014-b907-47d5-ab92-8e52d201b907"],
Cell[CellGroupData[{
Cell[223510, 6717, 429, 13, 31, "Input",ExpressionUUID->"0f86b7f9-19d0-4e3d-be53-a718f1007574"],
Cell[223942, 6732, 413, 13, 34, "Output",ExpressionUUID->"4652fbed-fd9a-4624-8985-9d1fad2b2480"]
}, Open  ]],
Cell[224370, 6748, 308, 9, 21, "Text",ExpressionUUID->"84929a53-abf8-4e40-9a3c-a90774f6b94a"],
Cell[CellGroupData[{
Cell[224703, 6761, 473, 14, 31, "Input",ExpressionUUID->"84b0be10-8795-444f-ad28-125dce348c04"],
Cell[225179, 6777, 114, 2, 31, "Output",ExpressionUUID->"7529b4b7-7d2a-4170-a816-f3c57b238561"]
}, Open  ]],
Cell[225308, 6782, 445, 10, 50, "Text",ExpressionUUID->"72e246b3-d2b9-4d77-9691-2af223f49e62"],
Cell[225756, 6794, 783, 24, 38, "Text",ExpressionUUID->"43b95d99-1523-4b05-adbc-e4a3613fd0af"],
Cell[CellGroupData[{
Cell[226564, 6822, 328, 9, 31, "Input",ExpressionUUID->"1a1043b3-828d-43c9-9fdf-34f0f8545e28"],
Cell[226895, 6833, 322, 10, 34, "Output",ExpressionUUID->"1d3cf1e8-c19e-4f89-b2c3-822a3d4d90d6"]
}, Open  ]],
Cell[227232, 6846, 244, 6, 21, "Text",ExpressionUUID->"06c1a8de-020e-4524-8933-eebff973714d"],
Cell[CellGroupData[{
Cell[227501, 6856, 371, 11, 31, "Input",ExpressionUUID->"a35148aa-2642-48f0-a414-25c61903c077"],
Cell[227875, 6869, 114, 2, 31, "Output",ExpressionUUID->"98b371f1-ef7d-480c-a2bb-8978ab09c438"]
}, Open  ]],
Cell[228004, 6874, 150, 2, 20, "Text",ExpressionUUID->"0664b181-e07f-4b85-807c-c0e93453b30b"],
Cell[CellGroupData[{
Cell[228179, 6880, 409, 12, 31, "Input",ExpressionUUID->"4877038d-69de-46dd-b81e-43bc1fa60c3d"],
Cell[228591, 6894, 115, 2, 31, "Output",ExpressionUUID->"47249de4-dbdc-4eea-84d3-8e7b4d21540c"]
}, Open  ]],
Cell[228721, 6899, 183, 3, 20, "Text",ExpressionUUID->"9eaa143b-a604-4050-8cae-e4cd2b5943df"],
Cell[CellGroupData[{
Cell[228929, 6906, 330, 9, 31, "Input",ExpressionUUID->"baaf4ddd-98cf-4b76-9761-965917df9eb0"],
Cell[229262, 6917, 324, 10, 34, "Output",ExpressionUUID->"bb512481-28d8-4ad7-92ce-8f276f419e0b"]
}, Open  ]],
Cell[CellGroupData[{
Cell[229623, 6932, 373, 11, 31, "Input",ExpressionUUID->"dc93abf4-bb11-4d8d-8b7f-856977a538f8"],
Cell[229999, 6945, 115, 2, 31, "Output",ExpressionUUID->"4677bd0a-9d4c-470a-b24d-3fa7c3c288b2"]
}, Open  ]],
Cell[230129, 6950, 256, 6, 20, "Text",ExpressionUUID->"adf88b03-e3cd-45d8-b7a8-b0faeee4b0ed"],
Cell[CellGroupData[{
Cell[230410, 6960, 388, 12, 31, "Input",ExpressionUUID->"eb7e8640-6cc1-4194-8ddb-7c4eea24cfbb"],
Cell[230801, 6974, 346, 11, 34, "Output",ExpressionUUID->"51129930-71c8-4207-8048-d4fd39646ede"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[231196, 6991, 119, 1, 55, "Section",ExpressionUUID->"e06179c6-6f6b-4807-bdb1-99f50d6e5b2b",
 CellTags->"Section6"],
Cell[231318, 6994, 1236, 28, 80, "Text",ExpressionUUID->"f3ba0ae7-1647-4ed1-8d5a-29591b5472e1"],
Cell[232557, 7024, 507, 12, 36, "Text",ExpressionUUID->"244cf37f-f649-4164-99a7-92cc147eebf8"],
Cell[CellGroupData[{
Cell[233089, 7040, 364, 11, 31, "Input",ExpressionUUID->"490814b9-376c-45f3-a657-8e7fe95f2e6e"],
Cell[233456, 7053, 114, 2, 31, "Output",ExpressionUUID->"6332d034-48b1-467a-93ed-4b3d12df5a4b"]
}, Open  ]],
Cell[233585, 7058, 588, 11, 54, "Text",ExpressionUUID->"b50a04f5-0196-40e0-bc28-7cb203ccf830"],
Cell[234176, 7071, 924, 27, 108, "Input",ExpressionUUID->"c00ae3f1-d4fd-4f09-9d72-952c8f8d9f90",
 InitializationCell->True],
Cell[235103, 7100, 2467, 70, 135, "Text",ExpressionUUID->"18282196-0f65-43e9-8736-b6579d98e4ae"],
Cell[237573, 7172, 203, 3, 20, "Text",ExpressionUUID->"279e3b66-ff76-4b8f-b1ac-9642aa97b7be"],
Cell[CellGroupData[{
Cell[237801, 7179, 571, 17, 31, "Input",ExpressionUUID->"ce18db38-6a82-46c1-b5dd-bec1b7e96a67"],
Cell[238375, 7198, 114, 2, 31, "Output",ExpressionUUID->"dae47ddb-c27d-448c-a004-6fd055ca6cb9"]
}, Open  ]],
Cell[238504, 7203, 759, 12, 80, "Text",ExpressionUUID->"0b75df42-e462-49ec-a0b6-c7a22093ac1d"],
Cell[CellGroupData[{
Cell[239288, 7219, 131, 1, 32, "Subsection",ExpressionUUID->"419e1445-3d3c-4d63-afcd-5c63a0f11b57",
 CellTags->"Section6a"],
Cell[239422, 7222, 430, 7, 54, "Text",ExpressionUUID->"12053fd6-8be0-476f-8b8b-f5a119ae24f8"],
Cell[CellGroupData[{
Cell[239877, 7233, 108, 0, 18, "Subsubsection",ExpressionUUID->"b8e3d83c-2944-4a3b-a295-8471e60e8e6d"],
Cell[239988, 7235, 852, 19, 70, "Text",ExpressionUUID->"b72dbf63-eebf-4ac8-b7e4-5af65134be13"],
Cell[240843, 7256, 912, 19, 68, "Text",ExpressionUUID->"d036b96c-7179-4e75-92dc-0d519eff32de"],
Cell[241758, 7277, 276, 4, 35, "Text",ExpressionUUID->"9fca836f-2b53-4e06-bc9c-bd7ddd658e0e"],
Cell[242037, 7283, 2763, 78, 184, "Input",ExpressionUUID->"ccb5ca0d-b983-4743-b5e1-bd07225e3cd7",
 InitializationCell->True]
}, Open  ]],
Cell[CellGroupData[{
Cell[244837, 7366, 105, 0, 18, "Subsubsection",ExpressionUUID->"fdf4c3ea-a9b8-406b-a35a-a039d4e5517c"],
Cell[244945, 7368, 554, 9, 69, "Text",ExpressionUUID->"aab27610-665a-4251-9661-08952c4e2943"],
Cell[245502, 7379, 735, 14, 73, "Text",ExpressionUUID->"0a3c79f7-6223-45ef-b6e8-fabc3b3952ca"],
Cell[246240, 7395, 1494, 38, 203, "Input",ExpressionUUID->"3e70121a-f82a-4fe4-80b4-b147340ed8dd",
 InitializationCell->True],
Cell[247737, 7435, 382, 8, 39, "Text",ExpressionUUID->"c371730f-f4a7-49da-887d-45b5ba0595de"],
Cell[CellGroupData[{
Cell[248144, 7447, 544, 16, 51, "Input",ExpressionUUID->"ccaa5bab-bc19-4466-95c8-02f60e78b9d0"],
Cell[248691, 7465, 4118, 143, 146, "Output",ExpressionUUID->"332eb686-9dbb-4565-8dd7-937e1d3d7e57"]
}, Open  ]],
Cell[CellGroupData[{
Cell[252846, 7613, 142, 3, 31, "Input",ExpressionUUID->"23a1e5dc-980b-4927-bc48-b3a3527b1cb6"],
Cell[252991, 7618, 112, 2, 31, "Output",ExpressionUUID->"31eadad1-c9d9-43c4-862d-0d01b4023a2c"]
}, Open  ]],
Cell[253118, 7623, 691, 9, 80, "Text",ExpressionUUID->"7937960c-5973-4f21-8d7e-c24f475fe275"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[253870, 7639, 123, 1, 55, "Section",ExpressionUUID->"3a9a9222-9952-41f3-bb49-0db02ae48c98",
 CellTags->"Section7"],
Cell[253996, 7642, 356, 9, 35, "Text",ExpressionUUID->"21bd053e-ce3a-434c-a459-dd4b0ffd6a17"],
Cell[254355, 7653, 523, 7, 50, "Text",ExpressionUUID->"a3c2462e-625d-4be2-bd60-d2be885753ee"],
Cell[CellGroupData[{
Cell[254903, 7664, 125, 1, 32, "Subsection",ExpressionUUID->"32432fd3-2627-40b3-9d93-d341eaa4b9a5",
 CellTags->"Section7a"],
Cell[255031, 7667, 450, 6, 50, "Text",ExpressionUUID->"347bbfbc-6416-472d-a0a8-84f12b5d7d1f"],
Cell[255484, 7675, 1776, 44, 241, "Input",ExpressionUUID->"8fc457a5-2be1-4c6b-91be-9d46b043bbc2",
 InitializationCell->True],
Cell[257263, 7721, 1044, 26, 74, "Text",ExpressionUUID->"49e148c7-9b2f-45c1-93a5-1376ee500842"],
Cell[CellGroupData[{
Cell[258332, 7751, 148, 3, 31, "Input",ExpressionUUID->"e735fa90-d6a8-4e80-8689-00cdcf138305"],
Cell[258483, 7756, 166, 4, 31, "Output",ExpressionUUID->"081934df-b589-4d68-a07c-32b742cb3e3f"]
}, Open  ]],
Cell[258664, 7763, 411, 7, 39, "Text",ExpressionUUID->"4a17aa5a-8baa-4018-b85d-16e22a005a19"],
Cell[259078, 7772, 542, 15, 89, "Input",ExpressionUUID->"1c87f228-b4df-426b-9c82-a7c8ea44d40a",
 InitializationCell->True],
Cell[259623, 7789, 233, 3, 20, "Text",ExpressionUUID->"d5a8d1b1-b56e-4000-b656-40a66a48db39"],
Cell[259859, 7794, 641, 16, 58, "Text",ExpressionUUID->"2051935b-2ae4-4803-b5c2-7d2e178f21b9"],
Cell[260503, 7812, 149, 2, 20, "Text",ExpressionUUID->"57e48b89-ec4e-4c53-bcee-b90fb1c9d9fa"],
Cell[CellGroupData[{
Cell[260677, 7818, 121, 2, 31, "Input",ExpressionUUID->"e7e0e15b-8165-456b-b14e-8f0dcf384dea"],
Cell[260801, 7822, 111, 2, 31, "Output",ExpressionUUID->"5bfdf293-f8de-42a5-81b5-c27c0731e66a"]
}, Open  ]],
Cell[260927, 7827, 170, 3, 20, "Text",ExpressionUUID->"4379f5b3-c0cd-4891-a57b-8e6d161b2a5e"],
Cell[261100, 7832, 2202, 57, 107, "Text",ExpressionUUID->"d12ddd17-5e87-4c6e-81f3-fe32414281f4"]
}, Open  ]],
Cell[CellGroupData[{
Cell[263339, 7894, 106, 1, 32, "Subsection",ExpressionUUID->"5b91512a-700d-41ea-bb4f-278a5b7bb292",
 CellTags->"Section7b"],
Cell[263448, 7897, 645, 9, 65, "Text",ExpressionUUID->"ed18ce04-1080-43d0-bb16-4c1e55f17b74"],
Cell[264096, 7908, 631, 12, 54, "Text",ExpressionUUID->"6a867a18-4acf-48bf-99fb-5c4b574027bc"],
Cell[264730, 7922, 6060, 178, 221, "Text",ExpressionUUID->"aaa9ad2c-a178-44c2-8247-7507e30c3fb0"],
Cell[270793, 8102, 986, 25, 62, "Text",ExpressionUUID->"034c0b5d-31ed-42b0-af1e-9d5b1d95c2cc"],
Cell[271782, 8129, 435, 9, 39, "Text",ExpressionUUID->"500ee821-93ed-40d1-ae7d-19c3135ab35e"],
Cell[272220, 8140, 440, 6, 50, "Text",ExpressionUUID->"6b0ca991-dc94-487d-81b9-3ce6773ce830"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[272709, 8152, 127, 1, 55, "Section",ExpressionUUID->"5d2577e6-7ebe-4b05-847f-864155adbfb9",
 CellTags->"Section8"],
Cell[272839, 8155, 268, 5, 35, "Text",ExpressionUUID->"8d24c167-b932-401c-b05e-76ec874d945b"],
Cell[CellGroupData[{
Cell[273132, 8164, 117, 1, 32, "Subsection",ExpressionUUID->"25ef834a-f737-40ac-9540-62433ce5153a",
 CellTags->"Section8a"],
Cell[273252, 8167, 582, 10, 65, "Text",ExpressionUUID->"8361d0c9-edbb-47d8-9d88-09452d9e2137"],
Cell[273837, 8179, 356, 7, 35, "Text",ExpressionUUID->"c74367d7-5d14-4c12-a2f8-6b24c998a2d1"],
Cell[274196, 8188, 801, 13, 92, "Text",ExpressionUUID->"45f5b6bb-587d-4381-88f0-ad7acc05848f"],
Cell[275000, 8203, 1466, 42, 119, "Text",ExpressionUUID->"b2e01b20-95ef-4828-81d9-30ad8131f357"],
Cell[276469, 8247, 1637, 42, 241, "Input",ExpressionUUID->"12ccf089-a4ac-45a9-918b-bc9349b34335",
 InitializationCell->True],
Cell[278109, 8291, 437, 10, 36, "Text",ExpressionUUID->"5b064910-0274-48f7-9b7b-615134d7b32c"],
Cell[CellGroupData[{
Cell[278571, 8305, 148, 3, 31, "Input",ExpressionUUID->"af866d32-98e1-49cd-b6b1-2deaf87b2a82"],
Cell[278722, 8310, 286, 7, 31, "Output",ExpressionUUID->"42225575-9a0c-4c31-bd38-a4c98b4acd24"]
}, Open  ]],
Cell[279023, 8320, 1380, 37, 112, "Text",ExpressionUUID->"cffa194a-b080-48b7-9794-0911927dfb8a"],
Cell[280406, 8359, 905, 25, 89, "Input",ExpressionUUID->"286890b6-8ea6-409a-9be1-b731d7c378ce",
 InitializationCell->True],
Cell[281314, 8386, 362, 7, 35, "Text",ExpressionUUID->"16c77cfc-a202-4eb8-8743-e6c1e0efca81"],
Cell[CellGroupData[{
Cell[281701, 8397, 165, 3, 31, "Input",ExpressionUUID->"179419a0-c55c-40bf-ab72-59ab99f8c512"],
Cell[281869, 8402, 273, 7, 24, "Print",ExpressionUUID->"68f385bd-05a6-4527-936d-630b95d3f4d5"]
}, Open  ]],
Cell[282157, 8412, 398, 9, 35, "Text",ExpressionUUID->"88bbf723-aaad-4182-8bee-ca51012a3837"]
}, Open  ]],
Cell[CellGroupData[{
Cell[282592, 8426, 117, 1, 32, "Subsection",ExpressionUUID->"071f504d-87ac-4c0e-8ded-e5ae18d17d68",
 CellTags->"Section8b"],
Cell[282712, 8429, 578, 10, 50, "Text",ExpressionUUID->"c713bc56-8db1-4aef-8752-a75bda46ac03"],
Cell[283293, 8441, 821, 19, 77, "Text",ExpressionUUID->"3ca39aa3-931a-4b6c-b965-4e19664d0631"],
Cell[284117, 8462, 2537, 69, 176, "Text",ExpressionUUID->"003218bb-abca-40df-93ef-56772d7f3b14"],
Cell[286657, 8533, 107, 0, 20, "Text",ExpressionUUID->"1e8407e0-4c8d-4d47-a89d-53f0f2dcfebf"],
Cell[286767, 8535, 1362, 36, 184, "Input",ExpressionUUID->"266a20da-7396-449c-b4a1-9110f554cd74",
 InitializationCell->True],
Cell[CellGroupData[{
Cell[288154, 8575, 117, 2, 31, "Input",ExpressionUUID->"91dfe631-a752-4d74-baea-18663e18093b"],
Cell[288274, 8579, 114, 2, 31, "Output",ExpressionUUID->"ce76a974-b9aa-457d-b858-9a2c8b337450"]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[288449, 8588, 170, 3, 55, "Section",ExpressionUUID->"09a943cc-d17b-479d-aedd-574567ffe38f",
 CellTags->"Solutions"],
Cell[CellGroupData[{
Cell[288644, 8595, 126, 2, 32, "Subsection",ExpressionUUID->"026465c8-9bc9-4ddc-8018-06a0a9dd7aab",
 CellTags->"SolutionsCP3"],
Cell[288773, 8599, 256, 4, 55, "Problem",ExpressionUUID->"95975f1c-a365-4c44-bfdd-bdfa6403909d"],
Cell[289032, 8605, 737, 15, 70, "Text",ExpressionUUID->"034c5eb9-12a2-49e2-bf77-8ba6936cb8ae"],
Cell[289772, 8622, 946, 23, 96, "Text",ExpressionUUID->"743b96c4-e30f-40cc-9de8-d0753f49df6b"],
Cell[290721, 8647, 210, 4, 24, "Text",ExpressionUUID->"d597577a-4b53-43c3-a885-4eaf0cead99e"],
Cell[290934, 8653, 1564, 40, 222, "Input",ExpressionUUID->"32ced984-af76-4424-b839-8c9a76bb94ac",
 InitializationCell->True],
Cell[292501, 8695, 164, 3, 20, "Text",ExpressionUUID->"996a2cb6-c964-4918-9fc3-d589c9a33608"],
Cell[CellGroupData[{
Cell[292690, 8702, 398, 13, 31, "Input",ExpressionUUID->"c320feee-2663-4412-a043-eff5b25321c3"],
Cell[CellGroupData[{
Cell[293113, 8719, 200, 5, 24, "Print",ExpressionUUID->"2509f8ce-6f44-4f2c-961e-f96255f2b0e2"],
Cell[293316, 8726, 197, 5, 24, "Print",ExpressionUUID->"e568c8a7-92e1-4e41-9928-b561aea44920"]
}, Open  ]],
Cell[293528, 8734, 114, 2, 31, "Output",ExpressionUUID->"acc8852b-a67c-404b-a822-e138252f6897"]
}, Open  ]],
Cell[CellGroupData[{
Cell[293679, 8741, 359, 11, 31, "Input",ExpressionUUID->"c47b397f-ed0f-48b0-88ac-cac815eccef6"],
Cell[CellGroupData[{
Cell[294063, 8756, 199, 5, 24, "Print",ExpressionUUID->"4a988a9a-b964-41b4-9301-2aa0424020a3"],
Cell[294265, 8763, 199, 5, 24, "Print",ExpressionUUID->"94eb0e6f-6a1f-46e9-b5bc-0f1e55a1984c"],
Cell[294467, 8770, 198, 5, 24, "Print",ExpressionUUID->"d25db85c-384e-4edd-8ab1-4a34074cba51"],
Cell[294668, 8777, 199, 5, 24, "Print",ExpressionUUID->"7b1963b9-53ad-4586-867c-a5c6815f0015"],
Cell[294870, 8784, 198, 5, 24, "Print",ExpressionUUID->"12424bea-e87e-49e9-ba93-0823b0013002"],
Cell[295071, 8791, 198, 5, 24, "Print",ExpressionUUID->"eb2ad963-ad32-4751-bad9-ee4ec55bd2f6"]
}, Open  ]],
Cell[295284, 8799, 114, 2, 31, "Output",ExpressionUUID->"0f44145d-e7a9-44f5-8402-c99315522fe6"]
}, Open  ]],
Cell[CellGroupData[{
Cell[295435, 8806, 605, 20, 31, "Input",ExpressionUUID->"c1f4eeac-62e8-403d-a6d3-1b44807fad9c"],
Cell[296043, 8828, 115, 2, 31, "Output",ExpressionUUID->"6aa7d22f-1d5f-4fd6-b684-78d71f15a6a7"]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[296207, 8836, 138, 2, 32, "Subsection",ExpressionUUID->"fd6cf4a1-4e4c-4114-9cb4-f1ddfa8e875c",
 CellTags->"SolutionsCE1"],
Cell[296348, 8840, 172, 3, 42, "Problem",ExpressionUUID->"fa71b863-380b-4543-bba1-eea108d07e02"],
Cell[296523, 8845, 991, 27, 40, "Text",ExpressionUUID->"62d3ccde-03fc-415d-9c31-9e22b65afd6e"],
Cell[297517, 8874, 924, 21, 55, "Text",ExpressionUUID->"2c91ace3-bfcc-4f69-b63e-be6a09a47ee0"],
Cell[298444, 8897, 230, 3, 35, "Text",ExpressionUUID->"50fba01e-1e12-4b56-9f36-a075af3a91ef"],
Cell[298677, 8902, 335, 5, 35, "Text",ExpressionUUID->"70d63c11-2a57-465e-9bbd-6abd18a4d069"],
Cell[299015, 8909, 791, 25, 32, "Equation",ExpressionUUID->"154231d9-115e-43a0-8471-a3097705bf0e"],
Cell[299809, 8936, 911, 17, 87, "Text",ExpressionUUID->"4bc39f49-c52d-4444-8bb8-e68954278f64"],
Cell[300723, 8955, 1349, 31, 87, "Text",ExpressionUUID->"68f04b60-529e-491d-99d6-eb715a638fe5"],
Cell[302075, 8988, 629, 19, 41, "Text",ExpressionUUID->"d70facfd-01a9-4bef-9ba8-93c44e1cfd60"],
Cell[302707, 9009, 481, 12, 40, "Text",ExpressionUUID->"4baa9ebd-8d8f-42f1-b8aa-7e6c9519b8d0"],
Cell[303191, 9023, 1719, 45, 241, "Input",ExpressionUUID->"96bff4b1-9f5d-4e0d-9265-ae0daec90558",
 InitializationCell->True],
Cell[304913, 9070, 688, 16, 57, "Text",ExpressionUUID->"07de1971-8364-4f7a-ab3d-48df2d6e7b0b"],
Cell[CellGroupData[{
Cell[305626, 9090, 282, 8, 31, "Input",ExpressionUUID->"9bd694d6-b90d-412c-a33c-7a4539b152c1"],
Cell[305911, 9100, 231, 6, 31, "Output",ExpressionUUID->"99c6a28b-c37f-446e-b0d5-01d15eb0bf47"]
}, Open  ]],
Cell[306157, 9109, 367, 10, 24, "Text",ExpressionUUID->"8eb9a145-9944-4771-9d60-be282db55fbe"],
Cell[CellGroupData[{
Cell[306549, 9123, 214, 5, 31, "Input",ExpressionUUID->"fd118ec4-1e28-4cf9-9aac-7c7c85ca9cd3"],
Cell[306766, 9130, 472, 9, 51, "Output",ExpressionUUID->"52d56bf2-109f-4404-bf2d-e0e0f21b3ddf"]
}, Open  ]],
Cell[307253, 9142, 144, 2, 20, "Text",ExpressionUUID->"03a6f649-09c7-4b59-b69f-d363cd784031"],
Cell[CellGroupData[{
Cell[307422, 9148, 217, 5, 31, "Input",ExpressionUUID->"176f7d42-cd15-4452-95d4-1f46e8d5ddbf"],
Cell[307642, 9155, 1816, 27, 165, "Output",ExpressionUUID->"fcd7a8bb-16a6-43a0-9a4d-754d97d490b2"]
}, Open  ]],
Cell[309473, 9185, 173, 3, 20, "Text",ExpressionUUID->"25d2d075-decc-4ffa-9ba0-206bd0eab2cc"],
Cell[CellGroupData[{
Cell[309671, 9192, 219, 5, 31, "Input",ExpressionUUID->"28ceebdf-84d5-4df5-8641-06d2ee820aa2"],
Cell[309893, 9199, 4354, 60, 393, "Output",ExpressionUUID->"da21e875-1353-42f5-81fe-b84c0ca00e40"]
}, Open  ]],
Cell[314262, 9262, 145, 2, 20, "Text",ExpressionUUID->"9420b59f-4b48-4f5f-a4f0-d1bb997de63a"],
Cell[CellGroupData[{
Cell[314432, 9268, 452, 13, 31, "Input",ExpressionUUID->"291fa3b7-d4dd-4f49-839e-d08e771bd892"],
Cell[CellGroupData[{
Cell[314909, 9285, 134, 3, 24, "Print",ExpressionUUID->"639c0b90-0d56-4e5a-baea-566ed78c5d49"],
Cell[315046, 9290, 135, 3, 24, "Print",ExpressionUUID->"1e30ac27-47b5-4ea3-a5f9-2c4b4bf3af37"]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]],
Cell[CellGroupData[{
Cell[315254, 9301, 107, 1, 55, "Section",ExpressionUUID->"92716c2a-19ce-43d4-a6c4-d610d8366903",
 CellTags->"Exercises"],
Cell[CellGroupData[{
Cell[315386, 9306, 252, 8, 24, "Item1Exercise",ExpressionUUID->"7d428c3f-6251-471f-9ed9-e23251ed9e00"],
Cell[315641, 9316, 246, 4, 33, "Item1Exercise",ExpressionUUID->"9aa5e341-fa86-481b-9387-4309afc5e580"],
Cell[315890, 9322, 186, 3, 20, "Item1Exercise",ExpressionUUID->"122d71df-1e99-49e6-900f-06a649e0c80d"],
Cell[316079, 9327, 511, 12, 34, "Item1Exercise",ExpressionUUID->"04313464-b7ea-41a0-ae5e-9ef1a4920a83"],
Cell[316593, 9341, 494, 14, 37, "Item1Exercise",ExpressionUUID->"4f29a222-b8a9-429c-ae80-ee1da8c6cb86"],
Cell[CellGroupData[{
Cell[317112, 9359, 1395, 32, 85, "Item1Exercise",ExpressionUUID->"03eaf90e-03a9-49c4-afc0-c6b452efbeea",
 CellGroupingRules->{GroupTogetherGrouping, 17001.}],
Cell[318510, 9393, 490, 16, 31, "myCode",ExpressionUUID->"29a53037-2cc7-4012-b0e3-34d580d8279b",
 Evaluatable->False,
 CellGroupingRules->{GroupTogetherGrouping, 17001.},
 InitializationCell->False],
Cell[319003, 9411, 315, 8, 16, "ExerciseContinuation",ExpressionUUID->"74656744-47f3-4581-b863-75a42356afcd",
 CellGroupingRules->{GroupTogetherGrouping, 17001.}],
Cell[319321, 9421, 385, 12, 31, "Output",ExpressionUUID->"4799d08e-1b33-494d-8cd8-5ae3a6805032",
 CellGroupingRules->{GroupTogetherGrouping, 17001.}]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}, Open  ]]
}
]
*)

